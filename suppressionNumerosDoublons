' =====================================================
' MACRO : Supprimer les doublons dans la façade PDI
' Analyse la façade générée et supprime les numéros en doublons
' Tient compte des extensions (A, Bis, Ter, etc.)
' =====================================================

Sub SupprimerDoublonsFacade()
    Dim wsFacade As Worksheet
    Dim wsAccueil As Worksheet
    Dim dictNumeros As Object
    Dim dictPositions As Object
    Dim derniereLigne As Long
    Dim ligneActuelle As Long
    Dim colonneActuelle As Long
    Dim contenuCellule As String
    Dim numeroExtrait As String
    Dim rngCellule As Range
    Dim compteurSupprimes As Long
    Dim msgResultat As String
    
    ' Vérifier que la feuille Facade_PDI existe
    On Error GoTo FacadeInexistante
    Set wsFacade = ThisWorkbook.Sheets("Facade_PDI")
    Set wsAccueil = ThisWorkbook.Sheets("Accueil")
    On Error GoTo 0
    
    ' Créer les dictionnaires pour traquer les numéros et leurs positions
    Set dictNumeros = CreateObject("Scripting.Dictionary")
    Set dictPositions = CreateObject("Scripting.Dictionary")
    
    ' Désactiver les mises à jour pour améliorer les performances
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    ' Trouver la dernière ligne utilisée dans la façade
    derniereLigne = wsFacade.UsedRange.Rows.Count
    compteurSupprimes = 0
    
    ' PHASE 1 : Analyser toutes les cellules et identifier les doublons
    msgResultat = "ANALYSE DE LA FAÇADE PDI" & vbCrLf & vbCrLf
    
    ' Parcourir toutes les lignes de numéros (lignes impaires : 1, 3, 5, etc.)
    For ligneActuelle = 1 To derniereLigne Step 2
        For colonneActuelle = 1 To 26 ' Colonnes A à Z
            Set rngCellule = wsFacade.Cells(ligneActuelle, colonneActuelle)
            
            ' Ignorer les cellules vides
            If rngCellule.Value <> "" Then
                contenuCellule = CStr(rngCellule.Value)
                
                ' Extraire le ou les numéros de la cellule
                Call AnalyserContenuCellule(contenuCellule, dictNumeros, dictPositions, ligneActuelle, colonneActuelle)
            End If
        Next colonneActuelle
    Next ligneActuelle
    
    ' PHASE 2 : Identifier et traiter les doublons
    Dim numerosCles As Variant
    Dim cle As Variant
    Dim positions As Collection
    Dim positionInfo As String
    Dim i As Long
    
    numerosCles = dictNumeros.Keys
    
    For Each cle In numerosCles
        Set positions = dictNumeros(cle)
        
        ' Si plus d'une position pour ce numéro, c'est un doublon
        If positions.Count > 1 Then
            msgResultat = msgResultat & "DOUBLON DÉTECTÉ : " & cle & " (" & positions.Count & " occurrences)" & vbCrLf
            
            ' Garder la première occurrence et supprimer les autres
            For i = 2 To positions.Count
                positionInfo = positions(i)
                Call SupprimerCelluleFacade(wsFacade, positionInfo)
                compteurSupprimes = compteurSupprimes + 1
                msgResultat = msgResultat & "  - Supprimé en position : " & positionInfo & vbCrLf
            Next i
            
            msgResultat = msgResultat & vbCrLf
        End If
    Next cle
    
    ' PHASE 3 : Nettoyer et réorganiser la façade
    Call NettoyerEspacesVides(wsFacade)
    
    ' Réactiver les mises à jour
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    
    ' Message de résultat
    If compteurSupprimes > 0 Then
        msgResultat = msgResultat & "RÉSULTAT :" & vbCrLf
        msgResultat = msgResultat & "✓ " & compteurSupprimes & " doublons supprimés avec succès !" & vbCrLf
        msgResultat = msgResultat & "✓ Façade réorganisée automatiquement"
        
        MsgBox msgResultat, vbInformation, "Suppression des doublons terminée"
    Else
        MsgBox "✓ Aucun doublon détecté dans la façade !" & vbCrLf & _
               "La façade est déjà optimisée.", vbInformation, "Analyse terminée"
    End If
    
    Exit Sub
    
FacadeInexistante:
    MsgBox "❌ Erreur : La feuille 'Facade_PDI' n'existe pas !" & vbCrLf & _
           "Veuillez d'abord générer la façade avec la macro principale.", _
           vbCritical, "Façade introuvable"
End Sub

' =====================================================
' SUB : Analyser le contenu d'une cellule et extraire les numéros
' =====================================================
Sub AnalyserContenuCellule(contenu As String, dictNumeros As Object, dictPositions As Object, ligne As Long, colonne As Long)
    Dim lignes As Variant
    Dim i As Integer
    Dim ligneTexte As String
    Dim numerosExtraits As Collection
    Dim numero As Variant
    Dim positionInfo As String
    
    ' Diviser le contenu par les sauts de ligne
    If InStr(contenu, vbCrLf) > 0 Then
        lignes = Split(contenu, vbCrLf)
        ' Prendre seulement la première ligne (qui contient les numéros)
        ligneTexte = Trim(lignes(0))
    Else
        ligneTexte = Trim(contenu)
    End If
    
    ' Enlever les symboles en début (triangle, carré, etc.)
    ligneTexte = NettoyerSymboles(ligneTexte)
    
    ' Extraire tous les numéros de cette ligne
    Set numerosExtraits = ExtraireNumerosPDI(ligneTexte)
    
    ' Ajouter chaque numéro au dictionnaire
    positionInfo = "L" & ligne & "C" & colonne
    
    For Each numero In numerosExtraits
        If Not dictNumeros.Exists(numero) Then
            ' Créer une nouvelle collection pour ce numéro
            Set dictNumeros(numero) = New Collection
        End If
        
        ' Ajouter cette position à la liste des positions pour ce numéro
        dictNumeros(numero).Add positionInfo
    Next numero
End Sub

' =====================================================
' FONCTION : Nettoyer les symboles en début de texte
' =====================================================
Function NettoyerSymboles(texte As String) As String
    Dim result As String
    result = Trim(texte)
    
    ' Enlever les symboles Unicode en début
    If Len(result) > 0 Then
        ' Triangle (Bat P)
        If Left(result, 1) = ChrW(&H25B2) Then
            result = Trim(Mid(result, 2))
        End If
        
        ' Carré (Bat C)
        If Left(result, 1) = ChrW(&H25A0) Then
            result = Trim(Mid(result, 2))
        End If
        
        ' Cercle blanc (multi-voies)
        If Left(result, 1) = ChrW(&H25CB) Then
            result = Trim(Mid(result, 2))
        End If
    End If
    
    NettoyerSymboles = result
End Function

' =====================================================
' FONCTION : Extraire tous les numéros PDI d'une chaîne
' =====================================================
Function ExtraireNumerosPDI(texte As String) As Collection
    Dim numerosCollection As Collection
    Dim segments As Variant
    Dim i As Integer
    Dim segment As String
    Dim numeroNormalise As String
    
    Set numerosCollection = New Collection
    
    ' Diviser par "/" pour les voies multiples
    If InStr(texte, " / ") > 0 Then
        segments = Split(texte, " / ")
    Else
        ' Diviser par "-" pour les plages de numéros
        If InStr(texte, "-") > 0 Then
            segments = Split(texte, "-")
        Else
            ' Un seul numéro
            ReDim segments(0)
            segments(0) = texte
        End If
    End If
    
    ' Traiter chaque segment
    For i = 0 To UBound(segments)
        segment = Trim(segments(i))
        If segment <> "" Then
            numeroNormalise = NormaliserNumeroPDI(segment)
            If numeroNormalise <> "" Then
                ' Éviter les doublons dans la même cellule
                On Error Resume Next
                numerosCollection.Add numeroNormalise, numeroNormalise
                On Error GoTo 0
            End If
        End If
    Next i
    
    Set ExtraireNumerosPDI = numerosCollection
End Function

' =====================================================
' FONCTION : Normaliser un numéro PDI (gérer les extensions)
' =====================================================
Function NormaliserNumeroPDI(numeroRaw As String) As String
    Dim numero As String
    Dim pattern As String
    Dim regex As Object
    Dim matches As Object
    
    numero = Trim(numeroRaw)
    
    ' Créer un objet regex pour extraire les numéros avec extensions
    Set regex = CreateObject("VBScript.RegExp")
    
    ' Pattern pour capturer : numéro + extension optionnelle
    ' Exemples : "3", "3A", "34", "34Ter", "8Bis", "125 A", "12 BIS"
    regex.pattern = "(\d+)\s*(A|B|C|D|E|F|BIS|TER|QUATER|bis|ter|quater)?"
    regex.IgnoreCase = True
    regex.Global = False
    
    Set matches = regex.Execute(numero)
    
    If matches.Count > 0 Then
        Dim numeroBase As String
        Dim extension As String
        
        numeroBase = matches(0).SubMatches(0)
        extension = matches(0).SubMatches(1)
        
        ' Normaliser l'extension
        If extension <> "" Then
            extension = UCase(Trim(extension))
            NormaliserNumeroPDI = numeroBase & " " & extension
        Else
            NormaliserNumeroPDI = numeroBase
        End If
    Else
        ' Si pas de match, retourner vide
        NormaliserNumeroPDI = ""
    End If
End Function

' =====================================================
' SUB : Supprimer une cellule de la façade
' =====================================================
Sub SupprimerCelluleFacade(ws As Worksheet, positionInfo As String)
    Dim ligne As Long
    Dim colonne As Long
    Dim rngHaut As Range
    Dim rngBas As Range
    
    ' Extraire ligne et colonne de la position (format "L1C2")
    ligne = CLng(Mid(positionInfo, 2, InStr(positionInfo, "C") - 2))
    colonne = CLng(Mid(positionInfo, InStr(positionInfo, "C") + 1))
    
    ' Supprimer le contenu des deux cellules (haut et bas)
    Set rngHaut = ws.Cells(ligne, colonne)
    Set rngBas = ws.Cells(ligne + 1, colonne)
    
    ' Si les cellules sont fusionnées, défusionner d'abord
    If rngHaut.MergeCells Then
        rngHaut.MergeArea.UnMerge
    End If
    
    If rngBas.MergeCells Then
        rngBas.MergeArea.UnMerge
    End If
    
    ' Vider le contenu et le formatage
    With rngHaut
        .ClearContents
        .ClearFormats
    End With
    
    With rngBas
        .ClearContents
        .ClearFormats
    End With
End Sub

' =====================================================
' SUB : Nettoyer les espaces vides et réorganiser
' =====================================================
Sub NettoyerEspacesVides(ws As Worksheet)
    Dim ligne As Long
    Dim colonne As Long
    Dim derniereLigne As Long
    Dim derniereColonneUtilisee As Long
    Dim espaceVide As Boolean
    
    derniereLigne = ws.UsedRange.Rows.Count
    
    ' Pour chaque ligne de casiers (lignes impaires)
    For ligne = 1 To derniereLigne Step 2
        ' Compacter les cellules vers la gauche
        Call CompacterLigneVersGauche(ws, ligne)
    Next ligne
    
    ' Supprimer les lignes complètement vides à la fin
    Call SupprimerLignesVidesFinales(ws)
End Sub

' =====================================================
' SUB : Compacter une ligne vers la gauche
' =====================================================
Sub CompacterLigneVersGauche(ws As Worksheet, ligne As Long)
    Dim colSource As Long
    Dim colDestination As Long
    Dim rngHautSource As Range
    Dim rngBasSource As Range
    Dim rngHautDest As Range
    Dim rngBasDest As Range
    
    colDestination = 1
    
    ' Parcourir toutes les colonnes
    For colSource = 1 To 26
        Set rngHautSource = ws.Cells(ligne, colSource)
        Set rngBasSource = ws.Cells(ligne + 1, colSource)
        
        ' Si la cellule source n'est pas vide
        If rngHautSource.Value <> "" Then
            ' Si source et destination sont différentes, déplacer
            If colSource <> colDestination Then
                Set rngHautDest = ws.Cells(ligne, colDestination)
                Set rngBasDest = ws.Cells(ligne + 1, colDestination)
                
                ' Copier le contenu et le formatage
                Call CopierCelluleComplete(rngHautSource, rngHautDest)
                Call CopierCelluleComplete(rngBasSource, rngBasDest)
                
                ' Vider la source
                rngHautSource.ClearContents
                rngHautSource.ClearFormats
                rngBasSource.ClearContents
                rngBasSource.ClearFormats
            End If
            
            colDestination = colDestination + 1
        End If
    Next colSource
End Sub

' =====================================================
' SUB : Copier une cellule complète (contenu + formatage)
' =====================================================
Sub CopierCelluleComplete(source As Range, destination As Range)
    ' Copier le contenu
    destination.Value = source.Value
    
    ' Copier le formatage
    destination.NumberFormat = source.NumberFormat
    destination.HorizontalAlignment = source.HorizontalAlignment
    destination.VerticalAlignment = source.VerticalAlignment
    destination.WrapText = source.WrapText
    destination.Font.Name = source.Font.Name
    destination.Font.Size = source.Font.Size
    destination.Font.Bold = source.Font.Bold
    destination.Font.Color = source.Font.Color
    destination.Font.Underline = source.Font.Underline
    destination.Interior.Color = source.Interior.Color
    destination.Interior.ColorIndex = source.Interior.ColorIndex
    destination.Borders.LineStyle = source.Borders.LineStyle
    destination.Borders.Weight = source.Borders.Weight
End Sub

' =====================================================
' SUB : Supprimer les lignes vides en fin de façade
' =====================================================
Sub SupprimerLignesVidesFinales(ws As Worksheet)
    Dim ligne As Long
    Dim derniereLigne As Long
    Dim ligneVide As Boolean
    Dim colonne As Long
    
    derniereLigne = ws.UsedRange.Rows.Count
    
    ' Parcourir de bas en haut
    For ligne = derniereLigne To 1 Step -2
        ligneVide = True
        
        ' Vérifier si la ligne est vide
        For colonne = 1 To 26
            If ws.Cells(ligne, colonne).Value <> "" Or ws.Cells(ligne + 1, colonne).Value <> "" Then
                ligneVide = False
                Exit For
            End If
        Next colonne
        
        ' Si la ligne est vide, la supprimer
        If ligneVide Then
            ws.Rows(ligne & ":" & (ligne + 1)).Delete
        Else
            ' Dès qu'on trouve une ligne non vide, on arrête
            Exit For
        End If
    Next ligne
End Sub

' =====================================================
' MACRO DE TEST : Analyser la façade sans supprimer
' =====================================================
Sub AnalyserDoublonsSansSupprimer()
    Dim wsFacade As Worksheet
    Dim dictNumeros As Object
    Dim dictPositions As Object
    Dim derniereLigne As Long
    Dim ligneActuelle As Long
    Dim colonneActuelle As Long
    Dim contenuCellule As String
    Dim rngCellule As Range
    Dim msgAnalyse As String
    Dim compteurDoublons As Long
    
    ' Vérifier que la feuille Facade_PDI existe
    On Error GoTo FacadeInexistante
    Set wsFacade = ThisWorkbook.Sheets("Facade_PDI")
    On Error GoTo 0
    
    ' Créer les dictionnaires
    Set dictNumeros = CreateObject("Scripting.Dictionary")
    Set dictPositions = CreateObject("Scripting.Dictionary")
    
    ' Analyser la façade
    derniereLigne = wsFacade.UsedRange.Rows.Count
    compteurDoublons = 0
    
    msgAnalyse = "📊 ANALYSE DES DOUBLONS DANS LA FAÇADE" & vbCrLf & vbCrLf
    
    ' Parcourir toutes les cellules
    For ligneActuelle = 1 To derniereLigne Step 2
        For colonneActuelle = 1 To 26
            Set rngCellule = wsFacade.Cells(ligneActuelle, colonneActuelle)
            
            If rngCellule.Value <> "" Then
                contenuCellule = CStr(rngCellule.Value)
                Call AnalyserContenuCellule(contenuCellule, dictNumeros, dictPositions, ligneActuelle, colonneActuelle)
            End If
        Next colonneActuelle
    Next ligneActuelle
    
    ' Analyser les résultats
    Dim numerosCles As Variant
    Dim cle As Variant
    Dim positions As Collection
    
    numerosCles = dictNumeros.Keys
    
    For Each cle in numerosCles
        Set positions = dictNumeros(cle)
        
        If positions.Count > 1 Then
            compteurDoublons = compteurDoublons + 1
            msgAnalyse = msgAnalyse & "🔄 DOUBLON : " & cle & " (" & positions.Count & " fois)" & vbCrLf
            
            Dim pos As Variant
            For Each pos In positions
                msgAnalyse = msgAnalyse & "    • " & pos & vbCrLf
            Next pos
            msgAnalyse = msgAnalyse & vbCrLf
        End If
    Next cle
    
    ' Résultat final
    If compteurDoublons > 0 Then
        msgAnalyse = msgAnalyse & "📈 RÉSUMÉ :" & vbCrLf
        msgAnalyse = msgAnalyse & "• " & compteurDoublons & " numéros en doublon détectés" & vbCrLf
        msgAnalyse = msgAnalyse & "• Utilisez 'SupprimerDoublonsFacade' pour les corriger"
    Else
        msgAnalyse = "✅ EXCELLENTE NOUVELLE !" & vbCrLf & vbCrLf
        msgAnalyse = msgAnalyse & "Aucun doublon détecté dans la façade." & vbCrLf
        msgAnalyse = msgAnalyse & "La façade est parfaitement optimisée !"
    End If
    
    MsgBox msgAnalyse, vbInformation, "Analyse des doublons"
    Exit Sub
    
FacadeInexistante:
    MsgBox "❌ Erreur : La feuille 'Facade_PDI' n'existe pas !" & vbCrLf & _
           "Veuillez d'abord générer la façade.", vbCritical, "Façade introuvable"
End Sub
