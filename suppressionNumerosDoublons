' =====================================================
' MACRO : Nettoyer les doublons √† l'int√©rieur de chaque case PDI
' Analyse seulement le contenu interne de chaque case sans modifier la structure
' Exemple : "51-49-47-67-51-51A-51B-89" devient "49-47-67-51-51A-51B-89"
' =====================================================

Sub NettoyerDoublonsInternesCases()
    Dim wsFacade As Worksheet
    Dim derniereLigne As Long
    Dim ligneActuelle As Long
    Dim colonneActuelle As Long
    Dim rngCellule As Range
    Dim contenuOriginal As String
    Dim contenuNettoye As String
    Dim compteurCasesModifiees As Long
    Dim msgResultat As String
    
    ' V√©rifier que la feuille Facade_PDI existe
    On Error GoTo FacadeInexistante
    Set wsFacade = ThisWorkbook.Sheets("Facade_PDI")
    On Error GoTo 0
    
    ' D√©sactiver les mises √† jour pour am√©liorer les performances
    Application.ScreenUpdating = False
    
    ' Trouver la derni√®re ligne utilis√©e dans la fa√ßade
    derniereLigne = wsFacade.UsedRange.Rows.Count
    compteurCasesModifiees = 0
    
    msgResultat = "üßπ NETTOYAGE DES DOUBLONS INTERNES" & vbCrLf & vbCrLf
    
    ' Parcourir seulement les lignes impaires (lignes des num√©ros PDI)
    For ligneActuelle = 1 To derniereLigne Step 2
        colonneActuelle = 1
        
        Do While colonneActuelle <= 26 ' Colonnes A √† Z
            Set rngCellule = wsFacade.Cells(ligneActuelle, colonneActuelle)
            
            ' Si la cellule n'est pas vide, nettoyer son contenu
            If rngCellule.Value <> "" Then
                contenuOriginal = CStr(rngCellule.Value)
                contenuNettoye = NettoyerContenuCase(contenuOriginal)
                
                ' Si le contenu a chang√©, le mettre √† jour
                If contenuOriginal <> contenuNettoye Then
                    rngCellule.Value = contenuNettoye
                    compteurCasesModifiees = compteurCasesModifiees + 1
                    
                    msgResultat = msgResultat & "Case L" & ligneActuelle & "C" & colonneActuelle & " :" & vbCrLf
                    msgResultat = msgResultat & "  Avant : " & contenuOriginal & vbCrLf
                    msgResultat = msgResultat & "  Apr√®s : " & contenuNettoye & vbCrLf & vbCrLf
                End If
                
                ' G√©rer les cellules fusionn√©es pour avancer correctement
                If rngCellule.MergeCells Then
                    colonneActuelle = colonneActuelle + rngCellule.MergeArea.Columns.Count
                Else
                    colonneActuelle = colonneActuelle + 1
                End If
            Else
                colonneActuelle = colonneActuelle + 1
            End If
        Loop
    Next ligneActuelle
    
    ' R√©activer les mises √† jour
    Application.ScreenUpdating = True
    
    ' Message de r√©sultat
    If compteurCasesModifiees > 0 Then
        msgResultat = msgResultat & "‚úÖ R√âSULTAT :" & vbCrLf
        msgResultat = msgResultat & "‚Ä¢ " & compteurCasesModifiees & " cases nettoy√©es" & vbCrLf
        msgResultat = msgResultat & "‚Ä¢ Structure de la fa√ßade pr√©serv√©e" & vbCrLf
        msgResultat = msgResultat & "‚Ä¢ Formatage conserv√©"
        
        MsgBox msgResultat, vbInformation, "Nettoyage termin√©"
    Else
        MsgBox "‚úÖ Aucun doublon interne d√©tect√© !" & vbCrLf & _
               "Toutes les cases sont d√©j√† optimis√©es.", vbInformation, "Analyse termin√©e"
    End If
    
    Exit Sub
    
FacadeInexistante:
    MsgBox "‚ùå Erreur : La feuille 'Facade_PDI' n'existe pas !" & vbCrLf & _
           "Veuillez d'abord g√©n√©rer la fa√ßade avec la macro principale.", _
           vbCritical, "Fa√ßade introuvable"
End Sub

' =====================================================
' FONCTION : Nettoyer le contenu d'une case individuelle
' =====================================================
Function NettoyerContenuCase(contenuOriginal As String) As String
    Dim lignes As Variant
    Dim ligneNumeros As String
    Dim ligneObservations As String
    Dim numerosNettoyes As String
    
    ' S√©parer les num√©ros des observations (saut de ligne)
    If InStr(contenuOriginal, vbCrLf) > 0 Then
        lignes = Split(contenuOriginal, vbCrLf)
        ligneNumeros = Trim(lignes(0))
        If UBound(lignes) >= 1 Then
            ligneObservations = Trim(lignes(1))
        Else
            ligneObservations = ""
        End If
    Else
        ligneNumeros = Trim(contenuOriginal)
        ligneObservations = ""
    End If
    
    ' Nettoyer seulement la ligne des num√©ros
    numerosNettoyes = SupprimerDoublonsNumeros(ligneNumeros)
    
    ' Reconstituer le contenu
    If ligneObservations <> "" Then
        NettoyerContenuCase = numerosNettoyes & vbCrLf & ligneObservations
    Else
        NettoyerContenuCase = numerosNettoyes
    End If
End Function

' =====================================================
' FONCTION : Supprimer les doublons dans une cha√Æne de num√©ros
' =====================================================
Function SupprimerDoublonsNumeros(chaineNumeros As String) As String
    Dim symboleDebut As String
    Dim chaineNettoyee As String
    Dim segments As Variant
    Dim i As Integer
    Dim dictNumeros As Object
    Dim numerosUniques As Collection
    Dim numeroNormalise As String
    Dim resultat As String
    
    ' Conserver le symbole en d√©but (triangle, carr√©, etc.)
    symboleDebut = ExtraireSymboleDebut(chaineNumeros)
    chaineNettoyee = EnleverSymboleDebut(chaineNumeros)
    
    ' Si la cha√Æne est vide apr√®s nettoyage, retourner le symbole seul
    If Trim(chaineNettoyee) = "" Then
        SupprimerDoublonsNumeros = symboleDebut
        Exit Function
    End If
    
    ' Cr√©er un dictionnaire pour traquer les num√©ros d√©j√† vus
    Set dictNumeros = CreateObject("Scripting.Dictionary")
    Set numerosUniques = New Collection
    
    ' S√©parer par diff√©rents d√©limiteurs possibles
    ' D'abord par "/" (voies multiples), puis par "-" (plages)
    If InStr(chaineNettoyee, " / ") > 0 Then
        ' Voies multiples : traiter chaque partie s√©par√©ment
        segments = Split(chaineNettoyee, " / ")
        For i = 0 To UBound(segments)
            Dim partieNettoyee As String
            partieNettoyee = SupprimerDoublonsPartie(Trim(segments(i)), dictNumeros)
            If partieNettoyee <> "" Then
                If numerosUniques.Count = 0 Then
                    numerosUniques.Add partieNettoyee
                Else
                    numerosUniques.Add " / " & partieNettoyee
                End If
            End If
        Next i
    Else
        ' Pas de voies multiples : traiter directement
        Dim partieUnique As String
        partieUnique = SupprimerDoublonsPartie(chaineNettoyee, dictNumeros)
        If partieUnique <> "" Then
            numerosUniques.Add partieUnique
        End If
    End If
    
    ' Reconstituer le r√©sultat
    resultat = ""
    For i = 1 To numerosUniques.Count
        resultat = resultat & numerosUniques(i)
    Next i
    
    SupprimerDoublonsNumeros = symboleDebut & resultat
End Function

' =====================================================
' FONCTION : Supprimer les doublons dans une partie de num√©ros
' =====================================================
Function SupprimerDoublonsPartie(partie As String, dictNumeros As Object) As String
    Dim elements As Variant
    Dim i As Integer
    Dim element As String
    Dim numeroNormalise As String
    Dim resultats As Collection
    Dim resultat As String
    
    Set resultats = New Collection
    
    ' S√©parer par tirets (pour les plages comme "51-49-47")
    If InStr(partie, "-") > 0 Then
        elements = Split(partie, "-")
    Else
        ' Un seul √©l√©ment
        ReDim elements(0)
        elements(0) = partie
    End If
    
    ' Traiter chaque √©l√©ment
    For i = 0 To UBound(elements)
        element = Trim(elements(i))
        If element <> "" Then
            numeroNormalise = NormaliserNumero(element)
            
            ' Ajouter seulement si pas d√©j√† vu
            If Not dictNumeros.Exists(numeroNormalise) Then
                dictNumeros.Add numeroNormalise, True
                
                ' Ajouter le d√©limiteur appropri√©
                If resultats.Count = 0 Then
                    resultats.Add element
                Else
                    resultats.Add "-" & element
                End If
            End If
        End If
    Next i
    
    ' Reconstituer la partie
    resultat = ""
    For i = 1 To resultats.Count
        resultat = resultat & resultats(i)
    Next i
    
    SupprimerDoublonsPartie = resultat
End Function

' =====================================================
' FONCTION : Normaliser un num√©ro pour la comparaison
' =====================================================
Function NormaliserNumero(numero As String) As String
    Dim numeroNettoye As String
    Dim regex As Object
    Dim matches As Object
    
    numeroNettoye = UCase(Trim(numero))
    
    ' Cr√©er un regex pour extraire num√©ro + extension
    Set regex = CreateObject("VBScript.RegExp")
    regex.pattern = "^(\d+)\s*([A-Z]*|BIS|TER|QUATER)?$"
    regex.IgnoreCase = True
    
    Set matches = regex.Execute(numeroNettoye)
    
    If matches.Count > 0 Then
        Dim numeroBase As String
        Dim extension As String
        
        numeroBase = matches(0).SubMatches(0)
        extension = matches(0).SubMatches(1)
        
        If extension <> "" Then
            NormaliserNumero = numeroBase & " " & extension
        Else
            NormaliserNumero = numeroBase
        End If
    Else
        ' Si pas de match, retourner tel quel
        NormaliserNumero = numeroNettoye
    End If
End Function

' =====================================================
' FONCTION : Extraire le symbole en d√©but de cha√Æne
' =====================================================
Function ExtraireSymboleDebut(texte As String) As String
    Dim premier As String
    
    If Len(texte) = 0 Then
        ExtraireSymboleDebut = ""
        Exit Function
    End If
    
    premier = Left(texte, 1)
    
    ' V√©rifier si c'est un symbole Unicode
    If premier = ChrW(&H25B2) Or premier = ChrW(&H25A0) Or premier = ChrW(&H25CB) Then
        ' Inclure l'espace qui suit si pr√©sent
        If Len(texte) > 1 And Mid(texte, 2, 1) = " " Then
            ExtraireSymboleDebut = Left(texte, 2)
        Else
            ExtraireSymboleDebut = premier
        End If
    Else
        ExtraireSymboleDebut = ""
    End If
End Function

' =====================================================
' FONCTION : Enlever le symbole en d√©but de cha√Æne
' =====================================================
Function EnleverSymboleDebut(texte As String) As String
    Dim symbole As String
    symbole = ExtraireSymboleDebut(texte)
    
    If symbole <> "" Then
        EnleverSymboleDebut = Trim(Mid(texte, Len(symbole) + 1))
    Else
        EnleverSymboleDebut = texte
    End If
End Function

' =====================================================
' MACRO DE TEST : Analyser sans modifier
' =====================================================
Sub AnalyserDoublonsInternesSansModifier()
    Dim wsFacade As Worksheet
    Dim derniereLigne As Long
    Dim ligneActuelle As Long
    Dim colonneActuelle As Long
    Dim rngCellule As Range
    Dim contenuOriginal As String
    Dim contenuNettoye As String
    Dim compteurDoublons As Long
    Dim msgAnalyse As String
    
    ' V√©rifier que la feuille Facade_PDI existe
    On Error GoTo FacadeInexistante
    Set wsFacade = ThisWorkbook.Sheets("Facade_PDI")
    On Error GoTo 0
    
    ' Analyser la fa√ßade
    derniereLigne = wsFacade.UsedRange.Rows.Count
    compteurDoublons = 0
    
    msgAnalyse = "üîç ANALYSE DES DOUBLONS INTERNES" & vbCrLf & vbCrLf
    
    ' Parcourir seulement les lignes impaires
    For ligneActuelle = 1 To derniereLigne Step 2
        colonneActuelle = 1
        
        Do While colonneActuelle <= 26
            Set rngCellule = wsFacade.Cells(ligneActuelle, colonneActuelle)
            
            If rngCellule.Value <> "" Then
                contenuOriginal = CStr(rngCellule.Value)
                contenuNettoye = NettoyerContenuCase(contenuOriginal)
                
                If contenuOriginal <> contenuNettoye Then
                    compteurDoublons = compteurDoublons + 1
                    msgAnalyse = msgAnalyse & "üîÑ Case L" & ligneActuelle & "C" & colonneActuelle & " :" & vbCrLf
                    msgAnalyse = msgAnalyse & "  Actuel : " & contenuOriginal & vbCrLf
                    msgAnalyse = msgAnalyse & "  Optimis√© : " & contenuNettoye & vbCrLf & vbCrLf
                End If
                
                ' G√©rer les cellules fusionn√©es
                If rngCellule.MergeCells Then
                    colonneActuelle = colonneActuelle + rngCellule.MergeArea.Columns.Count
                Else
                    colonneActuelle = colonneActuelle + 1
                End If
            Else
                colonneActuelle = colonneActuelle + 1
            End If
        Loop
    Next ligneActuelle
    
    ' R√©sultat final
    If compteurDoublons > 0 Then
        msgAnalyse = msgAnalyse & "üìä R√âSUM√â :" & vbCrLf
        msgAnalyse = msgAnalyse & "‚Ä¢ " & compteurDoublons & " cases contiennent des doublons" & vbCrLf
        msgAnalyse = msgAnalyse & "‚Ä¢ Utilisez 'NettoyerDoublonsInternesCases' pour les corriger"
    Else
        msgAnalyse = "‚úÖ PARFAIT !" & vbCrLf & vbCrLf
        msgAnalyse = msgAnalyse & "Aucun doublon interne d√©tect√©." & vbCrLf
        msgAnalyse = msgAnalyse & "Toutes les cases sont optimis√©es !"
    End If
    
    MsgBox msgAnalyse, vbInformation, "Analyse des doublons internes"
    Exit Sub
    
FacadeInexistante:
    MsgBox "‚ùå Erreur : La feuille 'Facade_PDI' n'existe pas !" & vbCrLf & _
           "Veuillez d'abord g√©n√©rer la fa√ßade.", vbCritical, "Fa√ßade introuvable"
End Sub
