' =====================================================
' MACRO : Supprimer les doublons dans la façade PDI
' Analyse la façade générée et supprime les numéros en doublons
' Tient compte des extensions (A, Bis, Ter, etc.)
' =====================================================

Sub SupprimerDoublonsFacade()
    Dim wsFacade As Worksheet
    Dim wsAccueil As Worksheet
    Dim dictNumeros As Object
    Dim dictPositions As Object
    Dim derniereLigne As Long
    Dim ligneActuelle As Long
    Dim colonneActuelle As Long
    Dim contenuCellule As String
    Dim numeroExtrait As String
    Dim rngCellule As Range
    Dim compteurSupprimes As Long
    Dim msgResultat As String
    
    ' Vérifier que la feuille Facade_PDI existe
    On Error GoTo FacadeInexistante
    Set wsFacade = ThisWorkbook.Sheets("Facade_PDI")
    Set wsAccueil = ThisWorkbook.Sheets("Accueil")
    On Error GoTo 0
    
    ' Créer les dictionnaires pour traquer les numéros et leurs positions
    Set dictNumeros = CreateObject("Scripting.Dictionary")
    Set dictPositions = CreateObject("Scripting.Dictionary")
    
    ' Désactiver les mises à jour pour améliorer les performances
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    ' Trouver la dernière ligne utilisée dans la façade
    derniereLigne = wsFacade.UsedRange.Rows.Count
    compteurSupprimes = 0
    
    ' PHASE 1 : Analyser toutes les cellules et identifier les doublons
    msgResultat = "ANALYSE DE LA FAÇADE PDI" & vbCrLf & vbCrLf
    
    ' Parcourir toutes les lignes de numéros (lignes impaires : 1, 3, 5, etc.)
    For ligneActuelle = 1 To derniereLigne Step 2
        colonneActuelle = 1
        
        Do While colonneActuelle <= 26 ' Colonnes A à Z
            Set rngCellule = wsFacade.Cells(ligneActuelle, colonneActuelle)
            
            ' Ignorer les cellules vides
            If rngCellule.Value <> "" Then
                contenuCellule = CStr(rngCellule.Value)
                
                ' Déterminer la largeur de la cellule (fusionnée ou non)
                Dim largeurCellule As Integer
                If rngCellule.MergeCells Then
                    largeurCellule = rngCellule.MergeArea.Columns.Count
                Else
                    largeurCellule = 1
                End If
                
                ' Extraire le ou les numéros de la cellule
                Call AnalyserContenuCellule(contenuCellule, dictNumeros, dictPositions, ligneActuelle, colonneActuelle, largeurCellule)
                
                ' Passer à la colonne suivante après la zone fusionnée
                colonneActuelle = colonneActuelle + largeurCellule
            Else
                colonneActuelle = colonneActuelle + 1
            End If
        Loop
    Next ligneActuelle
    
    ' PHASE 2 : Identifier et traiter les doublons
    Dim numerosCles As Variant
    Dim cle As Variant
    Dim positions As Collection
    Dim positionInfo As String
    Dim i As Long
    
    numerosCles = dictNumeros.Keys
    
    For Each cle In numerosCles
        Set positions = dictNumeros(cle)
        
        ' Si plus d'une position pour ce numéro, c'est un doublon
        If positions.Count > 1 Then
            msgResultat = msgResultat & "DOUBLON DÉTECTÉ : " & cle & " (" & positions.Count & " occurrences)" & vbCrLf
            
            ' Garder la première occurrence et supprimer les autres
            For i = 2 To positions.Count
                positionInfo = positions(i)
                Call SupprimerCelluleFacade(wsFacade, positionInfo)
                compteurSupprimes = compteurSupprimes + 1
                msgResultat = msgResultat & "  - Supprimé en position : " & positionInfo & vbCrLf
            Next i
            
            msgResultat = msgResultat & vbCrLf
        End If
    Next cle
    
    ' PHASE 3 : Nettoyer et réorganiser la façade
    Call NettoyerEspacesVides(wsFacade)
    
    ' Réactiver les mises à jour
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    
    ' Message de résultat
    If compteurSupprimes > 0 Then
        msgResultat = msgResultat & "RÉSULTAT :" & vbCrLf
        msgResultat = msgResultat & "✓ " & compteurSupprimes & " doublons supprimés avec succès !" & vbCrLf
        msgResultat = msgResultat & "✓ Façade réorganisée automatiquement"
        
        MsgBox msgResultat, vbInformation, "Suppression des doublons terminée"
    Else
        MsgBox "✓ Aucun doublon détecté dans la façade !" & vbCrLf & _
               "La façade est déjà optimisée.", vbInformation, "Analyse terminée"
    End If
    
    Exit Sub
    
FacadeInexistante:
    MsgBox "❌ Erreur : La feuille 'Facade_PDI' n'existe pas !" & vbCrLf & _
           "Veuillez d'abord générer la façade avec la macro principale.", _
           vbCritical, "Façade introuvable"
End Sub

' =====================================================
' SUB : Analyser le contenu d'une cellule et extraire les numéros
' =====================================================
Sub AnalyserContenuCellule(contenu As String, dictNumeros As Object, dictPositions As Object, ligne As Long, colonne As Long, largeur As Integer)
    Dim lignes As Variant
    Dim i As Integer
    Dim ligneTexte As String
    Dim numerosExtraits As Collection
    Dim numero As Variant
    Dim positionInfo As String
    
    ' Diviser le contenu par les sauts de ligne
    If InStr(contenu, vbCrLf) > 0 Then
        lignes = Split(contenu, vbCrLf)
        ' Prendre seulement la première ligne (qui contient les numéros)
        ligneTexte = Trim(lignes(0))
    Else
        ligneTexte = Trim(contenu)
    End If
    
    ' Enlever les symboles en début (triangle, carré, etc.)
    ligneTexte = NettoyerSymboles(ligneTexte)
    
    ' Extraire tous les numéros de cette ligne
    Set numerosExtraits = ExtraireNumerosPDI(ligneTexte)
    
    ' Créer l'info de position avec la largeur pour les cellules fusionnées
    If largeur > 1 Then
        positionInfo = "L" & ligne & "C" & colonne & "-" & (colonne + largeur - 1) & " (largeur:" & largeur & ")"
    Else
        positionInfo = "L" & ligne & "C" & colonne
    End If
    
    ' Ajouter chaque numéro au dictionnaire
    For Each numero In numerosExtraits
        If Not dictNumeros.Exists(numero) Then
            ' Créer une nouvelle collection pour ce numéro
            Set dictNumeros(numero) = New Collection
        End If
        
        ' Ajouter cette position à la liste des positions pour ce numéro
        dictNumeros(numero).Add positionInfo
    Next numero
End Sub

' =====================================================
' FONCTION : Nettoyer les symboles en début de texte
' =====================================================
Function NettoyerSymboles(texte As String) As String
    Dim result As String
    result = Trim(texte)
    
    ' Enlever les symboles Unicode en début
    If Len(result) > 0 Then
        ' Triangle (Bat P)
        If Left(result, 1) = ChrW(&H25B2) Then
            result = Trim(Mid(result, 2))
        End If
        
        ' Carré (Bat C)
        If Left(result, 1) = ChrW(&H25A0) Then
            result = Trim(Mid(result, 2))
        End If
        
        ' Cercle blanc (multi-voies)
        If Left(result, 1) = ChrW(&H25CB) Then
            result = Trim(Mid(result, 2))
        End If
    End If
    
    NettoyerSymboles = result
End Function

' =====================================================
' FONCTION : Extraire tous les numéros PDI d'une chaîne
' =====================================================
Function ExtraireNumerosPDI(texte As String) As Collection
    Dim numerosCollection As Collection
    Dim segments As Variant
    Dim i As Integer
    Dim segment As String
    Dim numeroNormalise As String
    
    Set numerosCollection = New Collection
    
    ' Diviser par "/" pour les voies multiples
    If InStr(texte, " / ") > 0 Then
        segments = Split(texte, " / ")
    Else
        ' Diviser par "-" pour les plages de numéros
        If InStr(texte, "-") > 0 Then
            segments = Split(texte, "-")
        Else
            ' Un seul numéro
            ReDim segments(0)
            segments(0) = texte
        End If
    End If
    
    ' Traiter chaque segment
    For i = 0 To UBound(segments)
        segment = Trim(segments(i))
        If segment <> "" Then
            numeroNormalise = NormaliserNumeroPDI(segment)
            If numeroNormalise <> "" Then
                ' Éviter les doublons dans la même cellule
                On Error Resume Next
                numerosCollection.Add numeroNormalise, numeroNormalise
                On Error GoTo 0
            End If
        End If
    Next i
    
    Set ExtraireNumerosPDI = numerosCollection
End Function

' =====================================================
' FONCTION : Normaliser un numéro PDI (gérer les extensions)
' =====================================================
Function NormaliserNumeroPDI(numeroRaw As String) As String
    Dim numero As String
    Dim pattern As String
    Dim regex As Object
    Dim matches As Object
    
    numero = Trim(numeroRaw)
    
    ' Créer un objet regex pour extraire les numéros avec extensions
    Set regex = CreateObject("VBScript.RegExp")
    
    ' Pattern pour capturer : numéro + extension optionnelle
    ' Exemples : "3", "3A", "34", "34Ter", "8Bis", "125 A", "12 BIS"
    regex.pattern = "(\d+)\s*(A|B|C|D|E|F|BIS|TER|QUATER|bis|ter|quater)?"
    regex.IgnoreCase = True
    regex.Global = False
    
    Set matches = regex.Execute(numero)
    
    If matches.Count > 0 Then
        Dim numeroBase As String
        Dim extension As String
        
        numeroBase = matches(0).SubMatches(0)
        extension = matches(0).SubMatches(1)
        
        ' Normaliser l'extension
        If extension <> "" Then
            extension = UCase(Trim(extension))
            NormaliserNumeroPDI = numeroBase & " " & extension
        Else
            NormaliserNumeroPDI = numeroBase
        End If
    Else
        ' Si pas de match, retourner vide
        NormaliserNumeroPDI = ""
    End If
End Function

' =====================================================
' SUB : Supprimer une cellule de la façade (gestion cellules fusionnées)
' =====================================================
Sub SupprimerCelluleFacade(ws As Worksheet, positionInfo As String)
    Dim ligne As Long
    Dim colonneDebut As Long
    Dim colonneFin As Long
    Dim largeur As Integer
    Dim rngHaut As Range
    Dim rngBas As Range
    Dim i As Long
    
    ' Parser l'information de position
    If InStr(positionInfo, "-") > 0 Then
        ' Format: "L1C2-5 (largeur:4)" pour cellules fusionnées
        Dim parties As Variant
        parties = Split(positionInfo, " ")
        Dim coordonnees As String
        coordonnees = parties(0) ' "L1C2-5"
        
        ' Extraire ligne
        ligne = CLng(Mid(coordonnees, 2, InStr(coordonnees, "C") - 2))
        
        ' Extraire colonnes début et fin
        Dim partieColonnes As String
        partieColonnes = Mid(coordonnees, InStr(coordonnees, "C") + 1) ' "2-5"
        
        If InStr(partieColonnes, "-") > 0 Then
            colonneDebut = CLng(Left(partieColonnes, InStr(partieColonnes, "-") - 1))
            colonneFin = CLng(Mid(partieColonnes, InStr(partieColonnes, "-") + 1))
            largeur = colonneFin - colonneDebut + 1
        Else
            colonneDebut = CLng(partieColonnes)
            colonneFin = colonneDebut
            largeur = 1
        End If
    Else
        ' Format simple: "L1C2"
        ligne = CLng(Mid(positionInfo, 2, InStr(positionInfo, "C") - 2))
        colonneDebut = CLng(Mid(positionInfo, InStr(positionInfo, "C") + 1))
        colonneFin = colonneDebut
        largeur = 1
    End If
    
    ' Définir les plages à supprimer (ligne du haut et ligne du bas)
    Set rngHaut = ws.Range(ws.Cells(ligne, colonneDebut), ws.Cells(ligne, colonneFin))
    Set rngBas = ws.Range(ws.Cells(ligne + 1, colonneDebut), ws.Cells(ligne + 1, colonneFin))
    
    ' Défusionner si nécessaire
    If rngHaut.MergeCells Then
        rngHaut.UnMerge
    End If
    
    If rngBas.MergeCells Then
        rngBas.UnMerge
    End If
    
    ' Vider le contenu et le formatage pour toute la largeur
    For i = colonneDebut To colonneFin
        With ws.Cells(ligne, i)
            .ClearContents
            .ClearFormats
        End With
        
        With ws.Cells(ligne + 1, i)
            .ClearContents
            .ClearFormats
        End With
    Next i
End Sub

' =====================================================
' SUB : Nettoyer les espaces vides et réorganiser
' =====================================================
Sub NettoyerEspacesVides(ws As Worksheet)
    Dim ligne As Long
    Dim colonne As Long
    Dim derniereLigne As Long
    Dim derniereColonneUtilisee As Long
    Dim espaceVide As Boolean
    
    derniereLigne = ws.UsedRange.Rows.Count
    
    ' Pour chaque ligne de casiers (lignes impaires)
    For ligne = 1 To derniereLigne Step 2
        ' Compacter les cellules vers la gauche
        Call CompacterLigneVersGauche(ws, ligne)
    Next ligne
    
    ' Supprimer les lignes complètement vides à la fin
    Call SupprimerLignesVidesFinales(ws)
End Sub

' =====================================================
' SUB : Compacter une ligne vers la gauche (gestion des cellules fusionnées)
' =====================================================
Sub CompacterLigneVersGauche(ws As Worksheet, ligne As Long)
    Dim colSource As Long
    Dim colDestination As Long
    Dim rngHautSource As Range
    Dim rngBasSource As Range
    Dim rngHautDest As Range
    Dim rngBasDest As Range
    Dim largeurSource As Integer
    Dim largeurDest As Integer
    Dim i As Long
    
    colDestination = 1
    colSource = 1
    
    ' Parcourir toutes les colonnes
    Do While colSource <= 26
        Set rngHautSource = ws.Cells(ligne, colSource)
        Set rngBasSource = ws.Cells(ligne + 1, colSource)
        
        ' Si la cellule source n'est pas vide
        If rngHautSource.Value <> "" Then
            ' Déterminer la largeur de la cellule source
            If rngHautSource.MergeCells Then
                largeurSource = rngHautSource.MergeArea.Columns.Count
            Else
                largeurSource = 1
            End If
            
            ' Si source et destination sont différentes, déplacer
            If colSource <> colDestination Then
                ' Défusionner les cellules source
                If rngHautSource.MergeCells Then
                    rngHautSource.MergeArea.UnMerge
                End If
                If rngBasSource.MergeCells Then
                    rngBasSource.MergeArea.UnMerge
                End If
                
                ' Copier cellule par cellule pour toute la largeur
                For i = 0 To largeurSource - 1
                    Set rngHautDest = ws.Cells(ligne, colDestination + i)
                    Set rngBasDest = ws.Cells(ligne + 1, colDestination + i)
                    
                    ' Copier le contenu et le formatage
                    Call CopierCelluleComplete(ws.Cells(ligne, colSource + i), rngHautDest)
                    Call CopierCelluleComplete(ws.Cells(ligne + 1, colSource + i), rngBasDest)
                    
                    ' Vider la source
                    ws.Cells(ligne, colSource + i).ClearContents
                    ws.Cells(ligne, colSource + i).ClearFormats
                    ws.Cells(ligne + 1, colSource + i).ClearContents
                    ws.Cells(ligne + 1, colSource + i).ClearFormats
                Next i
                
                ' Refusionner à la destination si nécessaire
                If largeurSource > 1 Then
                    Set rngHautDest = ws.Range(ws.Cells(ligne, colDestination), ws.Cells(ligne, colDestination + largeurSource - 1))
                    Set rngBasDest = ws.Range(ws.Cells(ligne + 1, colDestination), ws.Cells(ligne + 1, colDestination + largeurSource - 1))
                    
                    rngHautDest.Merge
                    rngBasDest.Merge
                End If
            End If
            
            ' Avancer les positions
            colDestination = colDestination + largeurSource
            colSource = colSource + largeurSource
        Else
            colSource = colSource + 1
        End If
    Loop
End Sub

' =====================================================
' SUB : Copier une cellule complète (contenu + formatage)
' =====================================================
Sub CopierCelluleComplete(source As Range, destination As Range)
    ' Copier le contenu
    destination.Value = source.Value
    
    ' Copier le formatage
    destination.NumberFormat = source.NumberFormat
    destination.HorizontalAlignment = source.HorizontalAlignment
    destination.VerticalAlignment = source.VerticalAlignment
    destination.WrapText = source.WrapText
    destination.Font.Name = source.Font.Name
    destination.Font.Size = source.Font.Size
    destination.Font.Bold = source.Font.Bold
    destination.Font.Color = source.Font.Color
    destination.Font.Underline = source.Font.Underline
    destination.Interior.Color = source.Interior.Color
    destination.Interior.ColorIndex = source.Interior.ColorIndex
    destination.Borders.LineStyle = source.Borders.LineStyle
    destination.Borders.Weight = source.Borders.Weight
End Sub

' =====================================================
' SUB : Supprimer les lignes vides en fin de façade
' =====================================================
Sub SupprimerLignesVidesFinales(ws As Worksheet)
    Dim ligne As Long
    Dim derniereLigne As Long
    Dim ligneVide As Boolean
    Dim colonne As Long
    
    derniereLigne = ws.UsedRange.Rows.Count
    
    ' Parcourir de bas en haut
    For ligne = derniereLigne To 1 Step -2
        ligneVide = True
        
        ' Vérifier si la ligne est vide
        For colonne = 1 To 26
            If ws.Cells(ligne, colonne).Value <> "" Or ws.Cells(ligne + 1, colonne).Value <> "" Then
                ligneVide = False
                Exit For
            End If
        Next colonne
        
        ' Si la ligne est vide, la supprimer
        If ligneVide Then
            ws.Rows(ligne & ":" & (ligne + 1)).Delete
        Else
            ' Dès qu'on trouve une ligne non vide, on arrête
            Exit For
        End If
    Next ligne
End Sub

' =====================================================
' MACRO DE TEST : Analyser la façade sans supprimer
' =====================================================
Sub AnalyserDoublonsSansSupprimer()
    Dim wsFacade As Worksheet
    Dim dictNumeros As Object
    Dim dictPositions As Object
    Dim derniereLigne As Long
    Dim ligneActuelle As Long
    Dim colonneActuelle As Long
    Dim contenuCellule As String
    Dim rngCellule As Range
    Dim msgAnalyse As String
    Dim compteurDoublons As Long
    
    ' Vérifier que la feuille Facade_PDI existe
    On Error GoTo FacadeInexistante
    Set wsFacade = ThisWorkbook.Sheets("Facade_PDI")
    On Error GoTo 0
    
    ' Créer les dictionnaires
    Set dictNumeros = CreateObject("Scripting.Dictionary")
    Set dictPositions = CreateObject("Scripting.Dictionary")
    
    ' Analyser la façade
    derniereLigne = wsFacade.UsedRange.Rows.Count
    compteurDoublons = 0
    
    msgAnalyse = "📊 ANALYSE DES DOUBLONS DANS LA FAÇADE" & vbCrLf & vbCrLf
    
    ' Parcourir toutes les cellules avec gestion des cellules fusionnées
    For ligneActuelle = 1 To derniereLigne Step 2
        colonneActuelle = 1
        
        Do While colonneActuelle <= 26
            Set rngCellule = wsFacade.Cells(ligneActuelle, colonneActuelle)
            
            If rngCellule.Value <> "" Then
                contenuCellule = CStr(rngCellule.Value)
                
                ' Déterminer la largeur de la cellule
                Dim largeurCellule As Integer
                If rngCellule.MergeCells Then
                    largeurCellule = rngCellule.MergeArea.Columns.Count
                Else
                    largeurCellule = 1
                End If
                
                Call AnalyserContenuCellule(contenuCellule, dictNumeros, dictPositions, ligneActuelle, colonneActuelle, largeurCellule)
                
                ' Passer à la colonne suivante après la zone fusionnée
                colonneActuelle = colonneActuelle + largeurCellule
            Else
                colonneActuelle = colonneActuelle + 1
            End If
        Loop
    Next ligneActuelle
    
    ' Analyser les résultats
    Dim numerosCles As Variant
    Dim cle As Variant
    Dim positions As Collection
    
    numerosCles = dictNumeros.Keys
    
    For Each cle in numerosCles
        Set positions = dictNumeros(cle)
        
        If positions.Count > 1 Then
            compteurDoublons = compteurDoublons + 1
            msgAnalyse = msgAnalyse & "🔄 DOUBLON : " & cle & " (" & positions.Count & " fois)" & vbCrLf
            
            Dim pos As Variant
            For Each pos In positions
                msgAnalyse = msgAnalyse & "    • " & pos & vbCrLf
            Next pos
            msgAnalyse = msgAnalyse & vbCrLf
        End If
    Next cle
    
    ' Résultat final
    If compteurDoublons > 0 Then
        msgAnalyse = msgAnalyse & "📈 RÉSUMÉ :" & vbCrLf
        msgAnalyse = msgAnalyse & "• " & compteurDoublons & " numéros en doublon détectés" & vbCrLf
        msgAnalyse = msgAnalyse & "• Utilisez 'SupprimerDoublonsFacade' pour les corriger"
    Else
        msgAnalyse = "✅ EXCELLENTE NOUVELLE !" & vbCrLf & vbCrLf
        msgAnalyse = msgAnalyse & "Aucun doublon détecté dans la façade." & vbCrLf
        msgAnalyse = msgAnalyse & "La façade est parfaitement optimisée !"
    End If
    
    MsgBox msgAnalyse, vbInformation, "Analyse des doublons"
    Exit Sub
    
FacadeInexistante:
    MsgBox "❌ Erreur : La feuille 'Facade_PDI' n'existe pas !" & vbCrLf & _
           "Veuillez d'abord générer la façade.", vbCritical, "Façade introuvable"
End Sub
