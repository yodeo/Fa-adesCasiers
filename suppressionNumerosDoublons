' =====================================================
' MACRO : Supprimer les doublons dans la fa√ßade PDI
' Analyse la fa√ßade g√©n√©r√©e et supprime les num√©ros en doublons
' Tient compte des extensions (A, Bis, Ter, etc.)
' =====================================================

Sub SupprimerDoublonsFacade()
    Dim wsFacade As Worksheet
    Dim wsAccueil As Worksheet
    Dim dictNumeros As Object
    Dim dictPositions As Object
    Dim derniereLigne As Long
    Dim ligneActuelle As Long
    Dim colonneActuelle As Long
    Dim contenuCellule As String
    Dim numeroExtrait As String
    Dim rngCellule As Range
    Dim compteurSupprimes As Long
    Dim msgResultat As String
    
    ' V√©rifier que la feuille Facade_PDI existe
    On Error GoTo FacadeInexistante
    Set wsFacade = ThisWorkbook.Sheets("Facade_PDI")
    Set wsAccueil = ThisWorkbook.Sheets("Accueil")
    On Error GoTo 0
    
    ' Cr√©er les dictionnaires pour traquer les num√©ros et leurs positions
    Set dictNumeros = CreateObject("Scripting.Dictionary")
    Set dictPositions = CreateObject("Scripting.Dictionary")
    
    ' D√©sactiver les mises √† jour pour am√©liorer les performances
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    ' Trouver la derni√®re ligne utilis√©e dans la fa√ßade
    derniereLigne = wsFacade.UsedRange.Rows.Count
    compteurSupprimes = 0
    
    ' PHASE 1 : Analyser toutes les cellules et identifier les doublons
    msgResultat = "ANALYSE DE LA FA√áADE PDI" & vbCrLf & vbCrLf
    
    ' Parcourir toutes les lignes de num√©ros (lignes impaires : 1, 3, 5, etc.)
    For ligneActuelle = 1 To derniereLigne Step 2
        For colonneActuelle = 1 To 26 ' Colonnes A √† Z
            Set rngCellule = wsFacade.Cells(ligneActuelle, colonneActuelle)
            
            ' Ignorer les cellules vides
            If rngCellule.Value <> "" Then
                contenuCellule = CStr(rngCellule.Value)
                
                ' Extraire le ou les num√©ros de la cellule
                Call AnalyserContenuCellule(contenuCellule, dictNumeros, dictPositions, ligneActuelle, colonneActuelle)
            End If
        Next colonneActuelle
    Next ligneActuelle
    
    ' PHASE 2 : Identifier et traiter les doublons
    Dim numerosCles As Variant
    Dim cle As Variant
    Dim positions As Collection
    Dim positionInfo As String
    Dim i As Long
    
    numerosCles = dictNumeros.Keys
    
    For Each cle In numerosCles
        Set positions = dictNumeros(cle)
        
        ' Si plus d'une position pour ce num√©ro, c'est un doublon
        If positions.Count > 1 Then
            msgResultat = msgResultat & "DOUBLON D√âTECT√â : " & cle & " (" & positions.Count & " occurrences)" & vbCrLf
            
            ' Garder la premi√®re occurrence et supprimer les autres
            For i = 2 To positions.Count
                positionInfo = positions(i)
                Call SupprimerCelluleFacade(wsFacade, positionInfo)
                compteurSupprimes = compteurSupprimes + 1
                msgResultat = msgResultat & "  - Supprim√© en position : " & positionInfo & vbCrLf
            Next i
            
            msgResultat = msgResultat & vbCrLf
        End If
    Next cle
    
    ' PHASE 3 : Nettoyer et r√©organiser la fa√ßade
    Call NettoyerEspacesVides(wsFacade)
    
    ' R√©activer les mises √† jour
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    
    ' Message de r√©sultat
    If compteurSupprimes > 0 Then
        msgResultat = msgResultat & "R√âSULTAT :" & vbCrLf
        msgResultat = msgResultat & "‚úì " & compteurSupprimes & " doublons supprim√©s avec succ√®s !" & vbCrLf
        msgResultat = msgResultat & "‚úì Fa√ßade r√©organis√©e automatiquement"
        
        MsgBox msgResultat, vbInformation, "Suppression des doublons termin√©e"
    Else
        MsgBox "‚úì Aucun doublon d√©tect√© dans la fa√ßade !" & vbCrLf & _
               "La fa√ßade est d√©j√† optimis√©e.", vbInformation, "Analyse termin√©e"
    End If
    
    Exit Sub
    
FacadeInexistante:
    MsgBox "‚ùå Erreur : La feuille 'Facade_PDI' n'existe pas !" & vbCrLf & _
           "Veuillez d'abord g√©n√©rer la fa√ßade avec la macro principale.", _
           vbCritical, "Fa√ßade introuvable"
End Sub

' =====================================================
' SUB : Analyser le contenu d'une cellule et extraire les num√©ros
' =====================================================
Sub AnalyserContenuCellule(contenu As String, dictNumeros As Object, dictPositions As Object, ligne As Long, colonne As Long)
    Dim lignes As Variant
    Dim i As Integer
    Dim ligneTexte As String
    Dim numerosExtraits As Collection
    Dim numero As Variant
    Dim positionInfo As String
    
    ' Diviser le contenu par les sauts de ligne
    If InStr(contenu, vbCrLf) > 0 Then
        lignes = Split(contenu, vbCrLf)
        ' Prendre seulement la premi√®re ligne (qui contient les num√©ros)
        ligneTexte = Trim(lignes(0))
    Else
        ligneTexte = Trim(contenu)
    End If
    
    ' Enlever les symboles en d√©but (triangle, carr√©, etc.)
    ligneTexte = NettoyerSymboles(ligneTexte)
    
    ' Extraire tous les num√©ros de cette ligne
    Set numerosExtraits = ExtraireNumerosPDI(ligneTexte)
    
    ' Ajouter chaque num√©ro au dictionnaire
    positionInfo = "L" & ligne & "C" & colonne
    
    For Each numero In numerosExtraits
        If Not dictNumeros.Exists(numero) Then
            ' Cr√©er une nouvelle collection pour ce num√©ro
            Set dictNumeros(numero) = New Collection
        End If
        
        ' Ajouter cette position √† la liste des positions pour ce num√©ro
        dictNumeros(numero).Add positionInfo
    Next numero
End Sub

' =====================================================
' FONCTION : Nettoyer les symboles en d√©but de texte
' =====================================================
Function NettoyerSymboles(texte As String) As String
    Dim result As String
    result = Trim(texte)
    
    ' Enlever les symboles Unicode en d√©but
    If Len(result) > 0 Then
        ' Triangle (Bat P)
        If Left(result, 1) = ChrW(&H25B2) Then
            result = Trim(Mid(result, 2))
        End If
        
        ' Carr√© (Bat C)
        If Left(result, 1) = ChrW(&H25A0) Then
            result = Trim(Mid(result, 2))
        End If
        
        ' Cercle blanc (multi-voies)
        If Left(result, 1) = ChrW(&H25CB) Then
            result = Trim(Mid(result, 2))
        End If
    End If
    
    NettoyerSymboles = result
End Function

' =====================================================
' FONCTION : Extraire tous les num√©ros PDI d'une cha√Æne
' =====================================================
Function ExtraireNumerosPDI(texte As String) As Collection
    Dim numerosCollection As Collection
    Dim segments As Variant
    Dim i As Integer
    Dim segment As String
    Dim numeroNormalise As String
    
    Set numerosCollection = New Collection
    
    ' Diviser par "/" pour les voies multiples
    If InStr(texte, " / ") > 0 Then
        segments = Split(texte, " / ")
    Else
        ' Diviser par "-" pour les plages de num√©ros
        If InStr(texte, "-") > 0 Then
            segments = Split(texte, "-")
        Else
            ' Un seul num√©ro
            ReDim segments(0)
            segments(0) = texte
        End If
    End If
    
    ' Traiter chaque segment
    For i = 0 To UBound(segments)
        segment = Trim(segments(i))
        If segment <> "" Then
            numeroNormalise = NormaliserNumeroPDI(segment)
            If numeroNormalise <> "" Then
                ' √âviter les doublons dans la m√™me cellule
                On Error Resume Next
                numerosCollection.Add numeroNormalise, numeroNormalise
                On Error GoTo 0
            End If
        End If
    Next i
    
    Set ExtraireNumerosPDI = numerosCollection
End Function

' =====================================================
' FONCTION : Normaliser un num√©ro PDI (g√©rer les extensions)
' =====================================================
Function NormaliserNumeroPDI(numeroRaw As String) As String
    Dim numero As String
    Dim pattern As String
    Dim regex As Object
    Dim matches As Object
    
    numero = Trim(numeroRaw)
    
    ' Cr√©er un objet regex pour extraire les num√©ros avec extensions
    Set regex = CreateObject("VBScript.RegExp")
    
    ' Pattern pour capturer : num√©ro + extension optionnelle
    ' Exemples : "3", "3A", "34", "34Ter", "8Bis", "125 A", "12 BIS"
    regex.pattern = "(\d+)\s*(A|B|C|D|E|F|BIS|TER|QUATER|bis|ter|quater)?"
    regex.IgnoreCase = True
    regex.Global = False
    
    Set matches = regex.Execute(numero)
    
    If matches.Count > 0 Then
        Dim numeroBase As String
        Dim extension As String
        
        numeroBase = matches(0).SubMatches(0)
        extension = matches(0).SubMatches(1)
        
        ' Normaliser l'extension
        If extension <> "" Then
            extension = UCase(Trim(extension))
            NormaliserNumeroPDI = numeroBase & " " & extension
        Else
            NormaliserNumeroPDI = numeroBase
        End If
    Else
        ' Si pas de match, retourner vide
        NormaliserNumeroPDI = ""
    End If
End Function

' =====================================================
' SUB : Supprimer une cellule de la fa√ßade
' =====================================================
Sub SupprimerCelluleFacade(ws As Worksheet, positionInfo As String)
    Dim ligne As Long
    Dim colonne As Long
    Dim rngHaut As Range
    Dim rngBas As Range
    
    ' Extraire ligne et colonne de la position (format "L1C2")
    ligne = CLng(Mid(positionInfo, 2, InStr(positionInfo, "C") - 2))
    colonne = CLng(Mid(positionInfo, InStr(positionInfo, "C") + 1))
    
    ' Supprimer le contenu des deux cellules (haut et bas)
    Set rngHaut = ws.Cells(ligne, colonne)
    Set rngBas = ws.Cells(ligne + 1, colonne)
    
    ' Si les cellules sont fusionn√©es, d√©fusionner d'abord
    If rngHaut.MergeCells Then
        rngHaut.MergeArea.UnMerge
    End If
    
    If rngBas.MergeCells Then
        rngBas.MergeArea.UnMerge
    End If
    
    ' Vider le contenu et le formatage
    With rngHaut
        .ClearContents
        .ClearFormats
    End With
    
    With rngBas
        .ClearContents
        .ClearFormats
    End With
End Sub

' =====================================================
' SUB : Nettoyer les espaces vides et r√©organiser
' =====================================================
Sub NettoyerEspacesVides(ws As Worksheet)
    Dim ligne As Long
    Dim colonne As Long
    Dim derniereLigne As Long
    Dim derniereColonneUtilisee As Long
    Dim espaceVide As Boolean
    
    derniereLigne = ws.UsedRange.Rows.Count
    
    ' Pour chaque ligne de casiers (lignes impaires)
    For ligne = 1 To derniereLigne Step 2
        ' Compacter les cellules vers la gauche
        Call CompacterLigneVersGauche(ws, ligne)
    Next ligne
    
    ' Supprimer les lignes compl√®tement vides √† la fin
    Call SupprimerLignesVidesFinales(ws)
End Sub

' =====================================================
' SUB : Compacter une ligne vers la gauche
' =====================================================
Sub CompacterLigneVersGauche(ws As Worksheet, ligne As Long)
    Dim colSource As Long
    Dim colDestination As Long
    Dim rngHautSource As Range
    Dim rngBasSource As Range
    Dim rngHautDest As Range
    Dim rngBasDest As Range
    
    colDestination = 1
    
    ' Parcourir toutes les colonnes
    For colSource = 1 To 26
        Set rngHautSource = ws.Cells(ligne, colSource)
        Set rngBasSource = ws.Cells(ligne + 1, colSource)
        
        ' Si la cellule source n'est pas vide
        If rngHautSource.Value <> "" Then
            ' Si source et destination sont diff√©rentes, d√©placer
            If colSource <> colDestination Then
                Set rngHautDest = ws.Cells(ligne, colDestination)
                Set rngBasDest = ws.Cells(ligne + 1, colDestination)
                
                ' Copier le contenu et le formatage
                Call CopierCelluleComplete(rngHautSource, rngHautDest)
                Call CopierCelluleComplete(rngBasSource, rngBasDest)
                
                ' Vider la source
                rngHautSource.ClearContents
                rngHautSource.ClearFormats
                rngBasSource.ClearContents
                rngBasSource.ClearFormats
            End If
            
            colDestination = colDestination + 1
        End If
    Next colSource
End Sub

' =====================================================
' SUB : Copier une cellule compl√®te (contenu + formatage)
' =====================================================
Sub CopierCelluleComplete(source As Range, destination As Range)
    ' Copier le contenu
    destination.Value = source.Value
    
    ' Copier le formatage
    destination.NumberFormat = source.NumberFormat
    destination.HorizontalAlignment = source.HorizontalAlignment
    destination.VerticalAlignment = source.VerticalAlignment
    destination.WrapText = source.WrapText
    destination.Font.Name = source.Font.Name
    destination.Font.Size = source.Font.Size
    destination.Font.Bold = source.Font.Bold
    destination.Font.Color = source.Font.Color
    destination.Font.Underline = source.Font.Underline
    destination.Interior.Color = source.Interior.Color
    destination.Interior.ColorIndex = source.Interior.ColorIndex
    destination.Borders.LineStyle = source.Borders.LineStyle
    destination.Borders.Weight = source.Borders.Weight
End Sub

' =====================================================
' SUB : Supprimer les lignes vides en fin de fa√ßade
' =====================================================
Sub SupprimerLignesVidesFinales(ws As Worksheet)
    Dim ligne As Long
    Dim derniereLigne As Long
    Dim ligneVide As Boolean
    Dim colonne As Long
    
    derniereLigne = ws.UsedRange.Rows.Count
    
    ' Parcourir de bas en haut
    For ligne = derniereLigne To 1 Step -2
        ligneVide = True
        
        ' V√©rifier si la ligne est vide
        For colonne = 1 To 26
            If ws.Cells(ligne, colonne).Value <> "" Or ws.Cells(ligne + 1, colonne).Value <> "" Then
                ligneVide = False
                Exit For
            End If
        Next colonne
        
        ' Si la ligne est vide, la supprimer
        If ligneVide Then
            ws.Rows(ligne & ":" & (ligne + 1)).Delete
        Else
            ' D√®s qu'on trouve une ligne non vide, on arr√™te
            Exit For
        End If
    Next ligne
End Sub

' =====================================================
' MACRO DE TEST : Analyser la fa√ßade sans supprimer
' =====================================================
Sub AnalyserDoublonsSansSupprimer()
    Dim wsFacade As Worksheet
    Dim dictNumeros As Object
    Dim dictPositions As Object
    Dim derniereLigne As Long
    Dim ligneActuelle As Long
    Dim colonneActuelle As Long
    Dim contenuCellule As String
    Dim rngCellule As Range
    Dim msgAnalyse As String
    Dim compteurDoublons As Long
    
    ' V√©rifier que la feuille Facade_PDI existe
    On Error GoTo FacadeInexistante
    Set wsFacade = ThisWorkbook.Sheets("Facade_PDI")
    On Error GoTo 0
    
    ' Cr√©er les dictionnaires
    Set dictNumeros = CreateObject("Scripting.Dictionary")
    Set dictPositions = CreateObject("Scripting.Dictionary")
    
    ' Analyser la fa√ßade
    derniereLigne = wsFacade.UsedRange.Rows.Count
    compteurDoublons = 0
    
    msgAnalyse = "üìä ANALYSE DES DOUBLONS DANS LA FA√áADE" & vbCrLf & vbCrLf
    
    ' Parcourir toutes les cellules
    For ligneActuelle = 1 To derniereLigne Step 2
        For colonneActuelle = 1 To 26
            Set rngCellule = wsFacade.Cells(ligneActuelle, colonneActuelle)
            
            If rngCellule.Value <> "" Then
                contenuCellule = CStr(rngCellule.Value)
                Call AnalyserContenuCellule(contenuCellule, dictNumeros, dictPositions, ligneActuelle, colonneActuelle)
            End If
        Next colonneActuelle
    Next ligneActuelle
    
    ' Analyser les r√©sultats
    Dim numerosCles As Variant
    Dim cle As Variant
    Dim positions As Collection
    
    numerosCles = dictNumeros.Keys
    
    For Each cle in numerosCles
        Set positions = dictNumeros(cle)
        
        If positions.Count > 1 Then
            compteurDoublons = compteurDoublons + 1
            msgAnalyse = msgAnalyse & "üîÑ DOUBLON : " & cle & " (" & positions.Count & " fois)" & vbCrLf
            
            Dim pos As Variant
            For Each pos In positions
                msgAnalyse = msgAnalyse & "    ‚Ä¢ " & pos & vbCrLf
            Next pos
            msgAnalyse = msgAnalyse & vbCrLf
        End If
    Next cle
    
    ' R√©sultat final
    If compteurDoublons > 0 Then
        msgAnalyse = msgAnalyse & "üìà R√âSUM√â :" & vbCrLf
        msgAnalyse = msgAnalyse & "‚Ä¢ " & compteurDoublons & " num√©ros en doublon d√©tect√©s" & vbCrLf
        msgAnalyse = msgAnalyse & "‚Ä¢ Utilisez 'SupprimerDoublonsFacade' pour les corriger"
    Else
        msgAnalyse = "‚úÖ EXCELLENTE NOUVELLE !" & vbCrLf & vbCrLf
        msgAnalyse = msgAnalyse & "Aucun doublon d√©tect√© dans la fa√ßade." & vbCrLf
        msgAnalyse = msgAnalyse & "La fa√ßade est parfaitement optimis√©e !"
    End If
    
    MsgBox msgAnalyse, vbInformation, "Analyse des doublons"
    Exit Sub
    
FacadeInexistante:
    MsgBox "‚ùå Erreur : La feuille 'Facade_PDI' n'existe pas !" & vbCrLf & _
           "Veuillez d'abord g√©n√©rer la fa√ßade.", vbCritical, "Fa√ßade introuvable"
End Sub
