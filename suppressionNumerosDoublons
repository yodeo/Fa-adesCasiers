' =====================================================
' MACRO : Supprimer les doublons dans la fa√ßade PDI
' Analyse la fa√ßade g√©n√©r√©e et supprime les num√©ros en doublons
' Tient compte des extensions (A, Bis, Ter, etc.)
' =====================================================

Sub SupprimerDoublonsFacade()
    Dim wsFacade As Worksheet
    Dim wsAccueil As Worksheet
    Dim dictNumeros As Object
    Dim dictPositions As Object
    Dim derniereLigne As Long
    Dim ligneActuelle As Long
    Dim colonneActuelle As Long
    Dim contenuCellule As String
    Dim numeroExtrait As String
    Dim rngCellule As Range
    Dim compteurSupprimes As Long
    Dim msgResultat As String
    
    ' V√©rifier que la feuille Facade_PDI existe
    On Error GoTo FacadeInexistante
    Set wsFacade = ThisWorkbook.Sheets("Facade_PDI")
    Set wsAccueil = ThisWorkbook.Sheets("Accueil")
    On Error GoTo 0
    
    ' Cr√©er les dictionnaires pour traquer les num√©ros et leurs positions
    Set dictNumeros = CreateObject("Scripting.Dictionary")
    Set dictPositions = CreateObject("Scripting.Dictionary")
    
    ' D√©sactiver les mises √† jour pour am√©liorer les performances
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    ' Trouver la derni√®re ligne utilis√©e dans la fa√ßade
    derniereLigne = wsFacade.UsedRange.Rows.Count
    compteurSupprimes = 0
    
    ' PHASE 1 : Analyser toutes les cellules et identifier les doublons
    msgResultat = "ANALYSE DE LA FA√áADE PDI" & vbCrLf & vbCrLf
    
    ' Parcourir toutes les lignes de num√©ros (lignes impaires : 1, 3, 5, etc.)
    For ligneActuelle = 1 To derniereLigne Step 2
        colonneActuelle = 1
        
        Do While colonneActuelle <= 26 ' Colonnes A √† Z
            Set rngCellule = wsFacade.Cells(ligneActuelle, colonneActuelle)
            
            ' Ignorer les cellules vides
            If rngCellule.Value <> "" Then
                contenuCellule = CStr(rngCellule.Value)
                
                ' D√©terminer la largeur de la cellule (fusionn√©e ou non)
                Dim largeurCellule As Integer
                If rngCellule.MergeCells Then
                    largeurCellule = rngCellule.MergeArea.Columns.Count
                Else
                    largeurCellule = 1
                End If
                
                ' Extraire le ou les num√©ros de la cellule
                Call AnalyserContenuCellule(contenuCellule, dictNumeros, dictPositions, ligneActuelle, colonneActuelle, largeurCellule)
                
                ' Passer √† la colonne suivante apr√®s la zone fusionn√©e
                colonneActuelle = colonneActuelle + largeurCellule
            Else
                colonneActuelle = colonneActuelle + 1
            End If
        Loop
    Next ligneActuelle
    
    ' PHASE 2 : Identifier et traiter les doublons
    Dim numerosCles As Variant
    Dim cle As Variant
    Dim positions As Collection
    Dim positionInfo As String
    Dim i As Long
    
    numerosCles = dictNumeros.Keys
    
    For Each cle In numerosCles
        Set positions = dictNumeros(cle)
        
        ' Si plus d'une position pour ce num√©ro, c'est un doublon
        If positions.Count > 1 Then
            msgResultat = msgResultat & "DOUBLON D√âTECT√â : " & cle & " (" & positions.Count & " occurrences)" & vbCrLf
            
            ' Garder la premi√®re occurrence et supprimer les autres
            For i = 2 To positions.Count
                positionInfo = positions(i)
                Call SupprimerCelluleFacade(wsFacade, positionInfo)
                compteurSupprimes = compteurSupprimes + 1
                msgResultat = msgResultat & "  - Supprim√© en position : " & positionInfo & vbCrLf
            Next i
            
            msgResultat = msgResultat & vbCrLf
        End If
    Next cle
    
    ' PHASE 3 : Nettoyer et r√©organiser la fa√ßade
    Call NettoyerEspacesVides(wsFacade)
    
    ' R√©activer les mises √† jour
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    
    ' Message de r√©sultat
    If compteurSupprimes > 0 Then
        msgResultat = msgResultat & "R√âSULTAT :" & vbCrLf
        msgResultat = msgResultat & "‚úì " & compteurSupprimes & " doublons supprim√©s avec succ√®s !" & vbCrLf
        msgResultat = msgResultat & "‚úì Fa√ßade r√©organis√©e automatiquement"
        
        MsgBox msgResultat, vbInformation, "Suppression des doublons termin√©e"
    Else
        MsgBox "‚úì Aucun doublon d√©tect√© dans la fa√ßade !" & vbCrLf & _
               "La fa√ßade est d√©j√† optimis√©e.", vbInformation, "Analyse termin√©e"
    End If
    
    Exit Sub
    
FacadeInexistante:
    MsgBox "‚ùå Erreur : La feuille 'Facade_PDI' n'existe pas !" & vbCrLf & _
           "Veuillez d'abord g√©n√©rer la fa√ßade avec la macro principale.", _
           vbCritical, "Fa√ßade introuvable"
End Sub

' =====================================================
' SUB : Analyser le contenu d'une cellule et extraire les num√©ros
' =====================================================
Sub AnalyserContenuCellule(contenu As String, dictNumeros As Object, dictPositions As Object, ligne As Long, colonne As Long, largeur As Integer)
    Dim lignes As Variant
    Dim i As Integer
    Dim ligneTexte As String
    Dim numerosExtraits As Collection
    Dim numero As Variant
    Dim positionInfo As String
    
    ' Diviser le contenu par les sauts de ligne
    If InStr(contenu, vbCrLf) > 0 Then
        lignes = Split(contenu, vbCrLf)
        ' Prendre seulement la premi√®re ligne (qui contient les num√©ros)
        ligneTexte = Trim(lignes(0))
    Else
        ligneTexte = Trim(contenu)
    End If
    
    ' Enlever les symboles en d√©but (triangle, carr√©, etc.)
    ligneTexte = NettoyerSymboles(ligneTexte)
    
    ' Extraire tous les num√©ros de cette ligne
    Set numerosExtraits = ExtraireNumerosPDI(ligneTexte)
    
    ' Cr√©er l'info de position avec la largeur pour les cellules fusionn√©es
    If largeur > 1 Then
        positionInfo = "L" & ligne & "C" & colonne & "-" & (colonne + largeur - 1) & " (largeur:" & largeur & ")"
    Else
        positionInfo = "L" & ligne & "C" & colonne
    End If
    
    ' Ajouter chaque num√©ro au dictionnaire
    For Each numero In numerosExtraits
        If Not dictNumeros.Exists(numero) Then
            ' Cr√©er une nouvelle collection pour ce num√©ro
            Set dictNumeros(numero) = New Collection
        End If
        
        ' Ajouter cette position √† la liste des positions pour ce num√©ro
        dictNumeros(numero).Add positionInfo
    Next numero
End Sub

' =====================================================
' FONCTION : Nettoyer les symboles en d√©but de texte
' =====================================================
Function NettoyerSymboles(texte As String) As String
    Dim result As String
    result = Trim(texte)
    
    ' Enlever les symboles Unicode en d√©but
    If Len(result) > 0 Then
        ' Triangle (Bat P)
        If Left(result, 1) = ChrW(&H25B2) Then
            result = Trim(Mid(result, 2))
        End If
        
        ' Carr√© (Bat C)
        If Left(result, 1) = ChrW(&H25A0) Then
            result = Trim(Mid(result, 2))
        End If
        
        ' Cercle blanc (multi-voies)
        If Left(result, 1) = ChrW(&H25CB) Then
            result = Trim(Mid(result, 2))
        End If
    End If
    
    NettoyerSymboles = result
End Function

' =====================================================
' FONCTION : Extraire tous les num√©ros PDI d'une cha√Æne
' =====================================================
Function ExtraireNumerosPDI(texte As String) As Collection
    Dim numerosCollection As Collection
    Dim segments As Variant
    Dim i As Integer
    Dim segment As String
    Dim numeroNormalise As String
    
    Set numerosCollection = New Collection
    
    ' Diviser par "/" pour les voies multiples
    If InStr(texte, " / ") > 0 Then
        segments = Split(texte, " / ")
    Else
        ' Diviser par "-" pour les plages de num√©ros
        If InStr(texte, "-") > 0 Then
            segments = Split(texte, "-")
        Else
            ' Un seul num√©ro
            ReDim segments(0)
            segments(0) = texte
        End If
    End If
    
    ' Traiter chaque segment
    For i = 0 To UBound(segments)
        segment = Trim(segments(i))
        If segment <> "" Then
            numeroNormalise = NormaliserNumeroPDI(segment)
            If numeroNormalise <> "" Then
                ' √âviter les doublons dans la m√™me cellule
                On Error Resume Next
                numerosCollection.Add numeroNormalise, numeroNormalise
                On Error GoTo 0
            End If
        End If
    Next i
    
    Set ExtraireNumerosPDI = numerosCollection
End Function

' =====================================================
' FONCTION : Normaliser un num√©ro PDI (g√©rer les extensions)
' =====================================================
Function NormaliserNumeroPDI(numeroRaw As String) As String
    Dim numero As String
    Dim pattern As String
    Dim regex As Object
    Dim matches As Object
    
    numero = Trim(numeroRaw)
    
    ' Cr√©er un objet regex pour extraire les num√©ros avec extensions
    Set regex = CreateObject("VBScript.RegExp")
    
    ' Pattern pour capturer : num√©ro + extension optionnelle
    ' Exemples : "3", "3A", "34", "34Ter", "8Bis", "125 A", "12 BIS"
    regex.pattern = "(\d+)\s*(A|B|C|D|E|F|BIS|TER|QUATER|bis|ter|quater)?"
    regex.IgnoreCase = True
    regex.Global = False
    
    Set matches = regex.Execute(numero)
    
    If matches.Count > 0 Then
        Dim numeroBase As String
        Dim extension As String
        
        numeroBase = matches(0).SubMatches(0)
        extension = matches(0).SubMatches(1)
        
        ' Normaliser l'extension
        If extension <> "" Then
            extension = UCase(Trim(extension))
            NormaliserNumeroPDI = numeroBase & " " & extension
        Else
            NormaliserNumeroPDI = numeroBase
        End If
    Else
        ' Si pas de match, retourner vide
        NormaliserNumeroPDI = ""
    End If
End Function

' =====================================================
' SUB : Supprimer une cellule de la fa√ßade (gestion cellules fusionn√©es)
' =====================================================
Sub SupprimerCelluleFacade(ws As Worksheet, positionInfo As String)
    Dim ligne As Long
    Dim colonneDebut As Long
    Dim colonneFin As Long
    Dim largeur As Integer
    Dim rngHaut As Range
    Dim rngBas As Range
    Dim i As Long
    
    ' Parser l'information de position
    If InStr(positionInfo, "-") > 0 Then
        ' Format: "L1C2-5 (largeur:4)" pour cellules fusionn√©es
        Dim parties As Variant
        parties = Split(positionInfo, " ")
        Dim coordonnees As String
        coordonnees = parties(0) ' "L1C2-5"
        
        ' Extraire ligne
        ligne = CLng(Mid(coordonnees, 2, InStr(coordonnees, "C") - 2))
        
        ' Extraire colonnes d√©but et fin
        Dim partieColonnes As String
        partieColonnes = Mid(coordonnees, InStr(coordonnees, "C") + 1) ' "2-5"
        
        If InStr(partieColonnes, "-") > 0 Then
            colonneDebut = CLng(Left(partieColonnes, InStr(partieColonnes, "-") - 1))
            colonneFin = CLng(Mid(partieColonnes, InStr(partieColonnes, "-") + 1))
            largeur = colonneFin - colonneDebut + 1
        Else
            colonneDebut = CLng(partieColonnes)
            colonneFin = colonneDebut
            largeur = 1
        End If
    Else
        ' Format simple: "L1C2"
        ligne = CLng(Mid(positionInfo, 2, InStr(positionInfo, "C") - 2))
        colonneDebut = CLng(Mid(positionInfo, InStr(positionInfo, "C") + 1))
        colonneFin = colonneDebut
        largeur = 1
    End If
    
    ' D√©finir les plages √† supprimer (ligne du haut et ligne du bas)
    Set rngHaut = ws.Range(ws.Cells(ligne, colonneDebut), ws.Cells(ligne, colonneFin))
    Set rngBas = ws.Range(ws.Cells(ligne + 1, colonneDebut), ws.Cells(ligne + 1, colonneFin))
    
    ' D√©fusionner si n√©cessaire
    If rngHaut.MergeCells Then
        rngHaut.UnMerge
    End If
    
    If rngBas.MergeCells Then
        rngBas.UnMerge
    End If
    
    ' Vider le contenu et le formatage pour toute la largeur
    For i = colonneDebut To colonneFin
        With ws.Cells(ligne, i)
            .ClearContents
            .ClearFormats
        End With
        
        With ws.Cells(ligne + 1, i)
            .ClearContents
            .ClearFormats
        End With
    Next i
End Sub

' =====================================================
' SUB : Nettoyer les espaces vides et r√©organiser
' =====================================================
Sub NettoyerEspacesVides(ws As Worksheet)
    Dim ligne As Long
    Dim colonne As Long
    Dim derniereLigne As Long
    Dim derniereColonneUtilisee As Long
    Dim espaceVide As Boolean
    
    derniereLigne = ws.UsedRange.Rows.Count
    
    ' Pour chaque ligne de casiers (lignes impaires)
    For ligne = 1 To derniereLigne Step 2
        ' Compacter les cellules vers la gauche
        Call CompacterLigneVersGauche(ws, ligne)
    Next ligne
    
    ' Supprimer les lignes compl√®tement vides √† la fin
    Call SupprimerLignesVidesFinales(ws)
End Sub

' =====================================================
' SUB : Compacter une ligne vers la gauche (gestion des cellules fusionn√©es)
' =====================================================
Sub CompacterLigneVersGauche(ws As Worksheet, ligne As Long)
    Dim colSource As Long
    Dim colDestination As Long
    Dim rngHautSource As Range
    Dim rngBasSource As Range
    Dim rngHautDest As Range
    Dim rngBasDest As Range
    Dim largeurSource As Integer
    Dim largeurDest As Integer
    Dim i As Long
    
    colDestination = 1
    colSource = 1
    
    ' Parcourir toutes les colonnes
    Do While colSource <= 26
        Set rngHautSource = ws.Cells(ligne, colSource)
        Set rngBasSource = ws.Cells(ligne + 1, colSource)
        
        ' Si la cellule source n'est pas vide
        If rngHautSource.Value <> "" Then
            ' D√©terminer la largeur de la cellule source
            If rngHautSource.MergeCells Then
                largeurSource = rngHautSource.MergeArea.Columns.Count
            Else
                largeurSource = 1
            End If
            
            ' Si source et destination sont diff√©rentes, d√©placer
            If colSource <> colDestination Then
                ' D√©fusionner les cellules source
                If rngHautSource.MergeCells Then
                    rngHautSource.MergeArea.UnMerge
                End If
                If rngBasSource.MergeCells Then
                    rngBasSource.MergeArea.UnMerge
                End If
                
                ' Copier cellule par cellule pour toute la largeur
                For i = 0 To largeurSource - 1
                    Set rngHautDest = ws.Cells(ligne, colDestination + i)
                    Set rngBasDest = ws.Cells(ligne + 1, colDestination + i)
                    
                    ' Copier le contenu et le formatage
                    Call CopierCelluleComplete(ws.Cells(ligne, colSource + i), rngHautDest)
                    Call CopierCelluleComplete(ws.Cells(ligne + 1, colSource + i), rngBasDest)
                    
                    ' Vider la source
                    ws.Cells(ligne, colSource + i).ClearContents
                    ws.Cells(ligne, colSource + i).ClearFormats
                    ws.Cells(ligne + 1, colSource + i).ClearContents
                    ws.Cells(ligne + 1, colSource + i).ClearFormats
                Next i
                
                ' Refusionner √† la destination si n√©cessaire
                If largeurSource > 1 Then
                    Set rngHautDest = ws.Range(ws.Cells(ligne, colDestination), ws.Cells(ligne, colDestination + largeurSource - 1))
                    Set rngBasDest = ws.Range(ws.Cells(ligne + 1, colDestination), ws.Cells(ligne + 1, colDestination + largeurSource - 1))
                    
                    rngHautDest.Merge
                    rngBasDest.Merge
                End If
            End If
            
            ' Avancer les positions
            colDestination = colDestination + largeurSource
            colSource = colSource + largeurSource
        Else
            colSource = colSource + 1
        End If
    Loop
End Sub

' =====================================================
' SUB : Copier une cellule compl√®te (contenu + formatage)
' =====================================================
Sub CopierCelluleComplete(source As Range, destination As Range)
    ' Copier le contenu
    destination.Value = source.Value
    
    ' Copier le formatage
    destination.NumberFormat = source.NumberFormat
    destination.HorizontalAlignment = source.HorizontalAlignment
    destination.VerticalAlignment = source.VerticalAlignment
    destination.WrapText = source.WrapText
    destination.Font.Name = source.Font.Name
    destination.Font.Size = source.Font.Size
    destination.Font.Bold = source.Font.Bold
    destination.Font.Color = source.Font.Color
    destination.Font.Underline = source.Font.Underline
    destination.Interior.Color = source.Interior.Color
    destination.Interior.ColorIndex = source.Interior.ColorIndex
    destination.Borders.LineStyle = source.Borders.LineStyle
    destination.Borders.Weight = source.Borders.Weight
End Sub

' =====================================================
' SUB : Supprimer les lignes vides en fin de fa√ßade
' =====================================================
Sub SupprimerLignesVidesFinales(ws As Worksheet)
    Dim ligne As Long
    Dim derniereLigne As Long
    Dim ligneVide As Boolean
    Dim colonne As Long
    
    derniereLigne = ws.UsedRange.Rows.Count
    
    ' Parcourir de bas en haut
    For ligne = derniereLigne To 1 Step -2
        ligneVide = True
        
        ' V√©rifier si la ligne est vide
        For colonne = 1 To 26
            If ws.Cells(ligne, colonne).Value <> "" Or ws.Cells(ligne + 1, colonne).Value <> "" Then
                ligneVide = False
                Exit For
            End If
        Next colonne
        
        ' Si la ligne est vide, la supprimer
        If ligneVide Then
            ws.Rows(ligne & ":" & (ligne + 1)).Delete
        Else
            ' D√®s qu'on trouve une ligne non vide, on arr√™te
            Exit For
        End If
    Next ligne
End Sub

' =====================================================
' MACRO DE TEST : Analyser la fa√ßade sans supprimer
' =====================================================
Sub AnalyserDoublonsSansSupprimer()
    Dim wsFacade As Worksheet
    Dim dictNumeros As Object
    Dim dictPositions As Object
    Dim derniereLigne As Long
    Dim ligneActuelle As Long
    Dim colonneActuelle As Long
    Dim contenuCellule As String
    Dim rngCellule As Range
    Dim msgAnalyse As String
    Dim compteurDoublons As Long
    
    ' V√©rifier que la feuille Facade_PDI existe
    On Error GoTo FacadeInexistante
    Set wsFacade = ThisWorkbook.Sheets("Facade_PDI")
    On Error GoTo 0
    
    ' Cr√©er les dictionnaires
    Set dictNumeros = CreateObject("Scripting.Dictionary")
    Set dictPositions = CreateObject("Scripting.Dictionary")
    
    ' Analyser la fa√ßade
    derniereLigne = wsFacade.UsedRange.Rows.Count
    compteurDoublons = 0
    
    msgAnalyse = "üìä ANALYSE DES DOUBLONS DANS LA FA√áADE" & vbCrLf & vbCrLf
    
    ' Parcourir toutes les cellules avec gestion des cellules fusionn√©es
    For ligneActuelle = 1 To derniereLigne Step 2
        colonneActuelle = 1
        
        Do While colonneActuelle <= 26
            Set rngCellule = wsFacade.Cells(ligneActuelle, colonneActuelle)
            
            If rngCellule.Value <> "" Then
                contenuCellule = CStr(rngCellule.Value)
                
                ' D√©terminer la largeur de la cellule
                Dim largeurCellule As Integer
                If rngCellule.MergeCells Then
                    largeurCellule = rngCellule.MergeArea.Columns.Count
                Else
                    largeurCellule = 1
                End If
                
                Call AnalyserContenuCellule(contenuCellule, dictNumeros, dictPositions, ligneActuelle, colonneActuelle, largeurCellule)
                
                ' Passer √† la colonne suivante apr√®s la zone fusionn√©e
                colonneActuelle = colonneActuelle + largeurCellule
            Else
                colonneActuelle = colonneActuelle + 1
            End If
        Loop
    Next ligneActuelle
    
    ' Analyser les r√©sultats
    Dim numerosCles As Variant
    Dim cle As Variant
    Dim positions As Collection
    
    numerosCles = dictNumeros.Keys
    
    For Each cle in numerosCles
        Set positions = dictNumeros(cle)
        
        If positions.Count > 1 Then
            compteurDoublons = compteurDoublons + 1
            msgAnalyse = msgAnalyse & "üîÑ DOUBLON : " & cle & " (" & positions.Count & " fois)" & vbCrLf
            
            Dim pos As Variant
            For Each pos In positions
                msgAnalyse = msgAnalyse & "    ‚Ä¢ " & pos & vbCrLf
            Next pos
            msgAnalyse = msgAnalyse & vbCrLf
        End If
    Next cle
    
    ' R√©sultat final
    If compteurDoublons > 0 Then
        msgAnalyse = msgAnalyse & "üìà R√âSUM√â :" & vbCrLf
        msgAnalyse = msgAnalyse & "‚Ä¢ " & compteurDoublons & " num√©ros en doublon d√©tect√©s" & vbCrLf
        msgAnalyse = msgAnalyse & "‚Ä¢ Utilisez 'SupprimerDoublonsFacade' pour les corriger"
    Else
        msgAnalyse = "‚úÖ EXCELLENTE NOUVELLE !" & vbCrLf & vbCrLf
        msgAnalyse = msgAnalyse & "Aucun doublon d√©tect√© dans la fa√ßade." & vbCrLf
        msgAnalyse = msgAnalyse & "La fa√ßade est parfaitement optimis√©e !"
    End If
    
    MsgBox msgAnalyse, vbInformation, "Analyse des doublons"
    Exit Sub
    
FacadeInexistante:
    MsgBox "‚ùå Erreur : La feuille 'Facade_PDI' n'existe pas !" & vbCrLf & _
           "Veuillez d'abord g√©n√©rer la fa√ßade.", vbCritical, "Fa√ßade introuvable"
End Sub
