' =====================================================
' SUB : Simplification des bornes de numéros PDI - VERSION ULTRA-SIMPLIFIÉE
' =====================================================
Sub SimplificationBornesNumPDI()
    Dim ws As Worksheet
    Dim wsFacade As Worksheet
    Dim lastRow As Long
    Dim lastCol As Long
    Dim dataParCellule As Object
    Dim i As Long, j As Long
    Dim nbModifiees As Long
    
    ' Vérifier qu'on est sur la bonne feuille
    Set ws = ActiveSheet
    Set wsFacade = ws
    
    ' Trouver les limites de la feuille
    lastRow = wsFacade.Cells(wsFacade.Rows.Count, 1).End(xlUp).Row
    lastCol = 26 ' Colonnes A à Z
    
    ' Dictionnaire pour indexer les données par cellule et voie
    Set dataParCellule = CreateObject("Scripting.Dictionary")
    
    Application.ScreenUpdating = False
    
    ' === PASSAGE 1 : INDEXER TOUS LES NUMÉROS PAR CELLULE ET VOIE ===
    Call IndexerTousLesNumerosFacadeAmelioree(wsFacade, lastRow, lastCol, dataParCellule)
    
    ' === PASSAGE 2 : TRAITEMENT ET GÉNÉRATION DES BORNES ULTRA-SIMPLIFIÉES ===
    nbModifiees = 0
    
    For i = 1 To lastRow Step 2 ' Lignes impaires (numéros PDI)
        For j = 1 To lastCol
            Dim celluleNum As Range
            Set celluleNum = wsFacade.Cells(i, j)
            
            Dim valeurNum As String
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                ' Obtenir le libellé de voie correspondant
                Dim voie As String
                voie = ObtenirLibelleVoiePDI(wsFacade, i, j)
                
                ' Obtenir le libellé de voie complet (avec cercle blanc si multi-voies)
                Dim voieComplete As String
                voieComplete = Trim(CStr(wsFacade.Cells(i + 1, j).Value))
                
                Dim adresse As String
                adresse = celluleNum.Address
                
                If voie <> "" And dataParCellule.Exists(voie) And dataParCellule(voie).Exists(adresse) Then
                    ' Récupérer les numéros utilisés dans d'autres cellules de la même voie
                    Dim autresP As Object
                    Dim autresI As Object
                    Set autresP = CreateObject("Scripting.Dictionary")
                    Set autresI = CreateObject("Scripting.Dictionary")
                    
                    ' Collecter les exclusions
                    Dim otherAdr As Variant
                    For Each otherAdr In dataParCellule(voie).Keys
                        If otherAdr <> adresse Then
                            Dim numeroObj As Object
                            For Each numeroObj In dataParCellule(voie)(otherAdr)("pairs")
                                autresP(numeroObj("numeroBase")) = True
                            Next
                            For Each numeroObj In dataParCellule(voie)(otherAdr)("impairs")
                                autresI(numeroObj("numeroBase")) = True
                            Next
                        End If
                    Next
                    
                    ' Générer le nouveau texte avec bornes ultra-simplifiées
                    Dim nouveauTexte As String
                    nouveauTexte = GenererTexteBornesUltraSimplifiees(dataParCellule(voie)(adresse)("pairs"), _
                                                                     dataParCellule(voie)(adresse)("impairs"), _
                                                                     autresP, autresI, valeurNum, voieComplete)
                    
                    If nouveauTexte <> "" And nouveauTexte <> celluleNum.Value Then
                        ' Conserver le formatage existant
                        Dim formatOriginal As Variant
                        Dim couleurFond As Long
                        Dim couleurTexte As Long
                        Dim estGras As Boolean
                        
                        formatOriginal = celluleNum.NumberFormat
                        couleurFond = celluleNum.Interior.Color
                        couleurTexte = celluleNum.Font.Color
                        estGras = celluleNum.Font.Bold
                        
                        ' Mettre à jour la valeur
                        celluleNum.Value = nouveauTexte
                        
                        ' Restaurer le formatage
                        celluleNum.NumberFormat = formatOriginal
                        celluleNum.Interior.Color = couleurFond
                        celluleNum.Font.Color = couleurTexte
                        celluleNum.Font.Bold = estGras
                        
                        ' Réappliquer le formatage différencié
                        Call AppliquerFormatageDifferencieBornes(celluleNum, nouveauTexte)
                        
                        nbModifiees = nbModifiees + 1
                    End If
                End If
            End If
        Next j
    Next i
    
    Application.ScreenUpdating = True
    
    ' Message de confirmation
    MsgBox "Simplification ultra des bornes terminée." & vbCrLf & _
           "Nombre de cellules modifiées : " & nbModifiees, _
           vbInformation, "Bornes Ultra-Simplifiées"
End Sub

' =====================================================
' SUB : Indexer tous les numéros de la façade - VERSION AMÉLIORÉE
' =====================================================
Sub IndexerTousLesNumerosFacadeAmelioree(ws As Worksheet, lastRow As Long, lastCol As Long, dataParCellule As Object)
    Dim i As Long, j As Long
    
    For i = 1 To lastRow Step 2 ' Lignes impaires (numéros PDI)
        For j = 1 To lastCol
            Dim celluleNum As Range
            Set celluleNum = ws.Cells(i, j)
            
            Dim valeurNum As String
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                Dim voie As String
                voie = ObtenirLibelleVoiePDI(ws, i, j)
                
                If voie <> "" Then
                    Dim adresse As String
                    adresse = celluleNum.Address
                    
                    ' Créer la structure de données si nécessaire
                    If Not dataParCellule.Exists(voie) Then
                        dataParCellule.Add voie, CreateObject("Scripting.Dictionary")
                    End If
                    
                    If Not dataParCellule(voie).Exists(adresse) Then
                        Dim pairImp As Object
                        Set pairImp = CreateObject("Scripting.Dictionary")
                        pairImp.Add "pairs", New Collection
                        pairImp.Add "impairs", New Collection
                        dataParCellule(voie).Add adresse, pairImp
                    End If
                    
                    ' Extraire les numéros avec extensions
                    Dim collPairs As Collection
                    Dim collImpairs As Collection
                    Set collPairs = New Collection
                    Set collImpairs = New Collection
                    
                    Call ExtraireNumerosAvecExtensionsAmelioree(valeurNum, collPairs, collImpairs)
                    
                    ' Ajouter aux collections
                    Dim numeroObj As Object
                    For Each numeroObj In collPairs
                        dataParCellule(voie)(adresse)("pairs").Add numeroObj
                    Next
                    For Each numeroObj In collImpairs
                        dataParCellule(voie)(adresse)("impairs").Add numeroObj
                    Next
                End If
            End If
        Next j
    Next i
End Sub

' =====================================================
' SUB : Extraire les numéros avec extensions - VERSION AMÉLIORÉE
' =====================================================
Sub ExtraireNumerosAvecExtensionsAmelioree(valeur As String, ByRef numsP As Collection, ByRef numsI As Collection)
    On Error Resume Next
    
    ' Expression régulière pour capturer numéros avec extensions
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.Pattern = "(\d+)\s*([a-zA-Z]|bis|ter|quater)?"
    reg.Global = True
    reg.IgnoreCase = True
    
    Dim matches As Object
    Set matches = reg.Execute(valeur)
    
    Dim i As Long
    Dim numeroBase As Long
    Dim extension As String
    Dim numeroObj As Object
    
    For i = 0 To matches.Count - 1
        numeroBase = CLng(matches(i).SubMatches(0))
        extension = Trim(CStr(matches(i).SubMatches(1)))
        
        If Err.Number = 0 And numeroBase > 0 Then
            ' Créer un objet représentant le numéro avec extension
            Set numeroObj = CreerObjetNumeroAmelioree(numeroBase, extension, matches(i).Value)
            
            ' Classifier selon la parité du numéro de base
            If numeroBase Mod 2 = 0 Then
                numsP.Add numeroObj
            Else
                numsI.Add numeroObj
            End If
        End If
        Err.Clear
    Next i
    
    On Error GoTo 0
End Sub

' =====================================================
' FUNCTION : Créer un objet numéro amélioré
' =====================================================
Function CreerObjetNumeroAmelioree(numeroBase As Long, extension As String, texteOriginal As String) As Object
    Dim obj As Object
    Set obj = CreateObject("Scripting.Dictionary")
    
    obj.Add "numeroBase", numeroBase
    obj.Add "extension", NormaliserExtensionAmelioree(extension)
    obj.Add "texteOriginal", Trim(texteOriginal)
    obj.Add "cleUnique", numeroBase & "|" & NormaliserExtensionAmelioree(extension)
    obj.Add "ordreExtension", ObtenirOrdreExtension(extension)
    
    Set CreerObjetNumeroAmelioree = obj
End Function

' =====================================================
' FUNCTION : Normaliser les extensions - VERSION AMÉLIORÉE
' =====================================================
Function NormaliserExtensionAmelioree(ext As String) As String
    Dim extClean As String
    extClean = UCase(Trim(ext))
    
    Select Case extClean
        Case "BIS"
            NormaliserExtensionAmelioree = "BIS"
        Case "TER"
            NormaliserExtensionAmelioree = "TER"
        Case "QUATER"
            NormaliserExtensionAmelioree = "QUATER"
        Case ""
            NormaliserExtensionAmelioree = ""
        Case Else
            ' Pour a, b, c, etc.
            If Len(extClean) = 1 And extClean >= "A" And extClean <= "Z" Then
                NormaliserExtensionAmelioree = extClean
            Else
                NormaliserExtensionAmelioree = extClean
            End If
    End Select
End Function

' =====================================================
' FUNCTION : Obtenir l'ordre d'une extension pour le tri
' =====================================================
Function ObtenirOrdreExtension(extension As String) As Integer
    Dim ext As String
    ext = UCase(Trim(extension))
    
    Select Case ext
        Case ""
            ObtenirOrdreExtension = 0
        Case "A"
            ObtenirOrdreExtension = 1
        Case "B"
            ObtenirOrdreExtension = 2
        Case "C"
            ObtenirOrdreExtension = 3
        Case "D"
            ObtenirOrdreExtension = 4
        Case "BIS"
            ObtenirOrdreExtension = 5
        Case "TER"
            ObtenirOrdreExtension = 6
        Case "QUATER"
            ObtenirOrdreExtension = 7
        Case Else
            ObtenirOrdreExtension = 10 + Asc(Left(ext, 1)) - Asc("A")
    End Select
End Function

' =====================================================
' FUNCTION : Générer le texte avec bornes ultra-simplifiées
' =====================================================
Function GenererTexteBornesUltraSimplifiees(collPairs As Collection, collImpairs As Collection, _
                                           autresP As Object, autresI As Object, texteOriginal As String, voieComplete As String) As String
    
    Dim res As String
    res = ""
    
    ' Détecter et conserver le début du texte original (symboles)
    Dim debutTexte As String
    debutTexte = ExtraireDebutSymbole(texteOriginal)
    
    ' Détecter si c'est une case multi-voies
    Dim estMultiVoies As Boolean
    estMultiVoies = (InStr(voieComplete, ChrW(&H25CB)) > 0) Or (InStr(voieComplete, " / ") > 0)
    
    ' Traiter les numéros pairs
    If collPairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesUltraSimplifiees(collPairs, autresP)
        If resPairs <> "" Then 
            If estMultiVoies Then
                res = "[" & resPairs & "]"
            Else
                res = resPairs
            End If
        End If
    End If
    
    ' Traiter les numéros impairs
    If collImpairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesUltraSimplifiees(collImpairs, autresI)
        If resImpairs <> "" Then
            If estMultiVoies Then
                resImpairs = "[" & resImpairs & "]"
            End If
            
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    ' Conserver les observations si elles étaient présentes
    Dim observations As String
    observations = ExtraireObservations(texteOriginal)
    
    ' Construire le résultat final
    If res <> "" Then
        If observations <> "" Then
            GenererTexteBornesUltraSimplifiees = debutTexte & res & vbCrLf & observations
        Else
            GenererTexteBornesUltraSimplifiees = debutTexte & res
        End If
    Else
        GenererTexteBornesUltraSimplifiees = texteOriginal
    End If
End Function

' =====================================================
' FUNCTION : Générer bornes ultra-simplifiées - LOGIQUE PRINCIPALE
' =====================================================
Function GenererBornesUltraSimplifiees(coll As Collection, exclus As Object) As String
    If coll.Count = 0 Then
        GenererBornesUltraSimplifiees = ""
        Exit Function
    End If
    
    ' Étape 1 : Regrouper par numéro de base et trier
    Dim groupesParBase As Object
    Set groupesParBase = CreerGroupesParNumeroBase(coll)
    
    ' Étape 2 : Convertir en tableau trié des numéros de base
    Dim numerosBase() As Long
    numerosBase = ExtraireEtTrierNumerosBase(groupesParBase)
    
    ' Étape 3 : LOGIQUE ULTRA-SIMPLIFIÉE - Créer des bornes continues maximales
    Dim plages As Collection
    Set plages = CreerPlagesContinuesMaximales(numerosBase, groupesParBase, exclus)
    
    ' Étape 4 : Construire le résultat
    Dim res As String
    res = ""
    Dim i As Integer
    For i = 1 To plages.Count
        If i > 1 Then res = res & ", "
        res = res & plages(i)
    Next i
    
    GenererBornesUltraSimplifiees = res
End Function

' =====================================================
' FUNCTION : Créer des groupes par numéro de base
' =====================================================
Function CreerGroupesParNumeroBase(coll As Collection) As Object
    Dim groupes As Object
    Set groupes = CreateObject("Scripting.Dictionary")
    
    Dim numeroObj As Object
    For Each numeroObj In coll
        Dim numeroBase As String
        numeroBase = CStr(numeroObj("numeroBase"))
        
        If Not groupes.Exists(numeroBase) Then
            groupes.Add numeroBase, New Collection
        End If
        
        groupes(numeroBase).Add numeroObj
    Next
    
    Set CreerGroupesParNumeroBase = groupes
End Function

' =====================================================
' FUNCTION : Extraire et trier les numéros de base
' =====================================================
Function ExtraireEtTrierNumerosBase(groupes As Object) As Long()
    Dim arr() As Long
    ReDim arr(groupes.Count - 1)
    
    Dim i As Integer
    i = 0
    Dim cle As Variant
    For Each cle In groupes.Keys
        arr(i) = CLng(cle)
        i = i + 1
    Next
    
    ' Tri simple
    Call TrierTableauLong(arr)
    
    ExtraireEtTrierNumerosBase = arr
End Function

' =====================================================
' FUNCTION : Créer des plages continues maximales - LOGIQUE CLEF
' =====================================================
Function CreerPlagesContinuesMaximales(numerosBase() As Long, groupes As Object, exclus As Object) As Collection
    Dim plages As New Collection
    
    If UBound(numerosBase) < 0 Then
        Set CreerPlagesContinuesMaximales = plages
        Exit Function
    End If
    
    Dim debut As Long, fin As Long
    debut = numerosBase(0)
    fin = numerosBase(0)
    
    Dim i As Integer
    For i = 1 To UBound(numerosBase)
        Dim actuel As Long
        actuel = numerosBase(i)
        
        ' LOGIQUE ULTRA-SIMPLIFIÉE : Vérifier si on peut continuer la borne
        If PeutEtendreborne(fin, actuel, exclus) Then
            fin = actuel
        Else
            ' Terminer la plage actuelle
            Dim plageTexte As String
            plageTexte = FormaterPlage(debut, fin, groupes)
            plages.Add plageTexte
            
            debut = actuel
            fin = actuel
        End If
    Next i
    
    ' Ajouter la dernière plage
    plageTexte = FormaterPlage(debut, fin, groupes)
    plages.Add plageTexte
    
    Set CreerPlagesContinuesMaximales = plages
End Function

' =====================================================
' FUNCTION : Vérifier si on peut étendre une borne
' =====================================================
Function PeutEtendreborne(fin As Long, actuel As Long, exclus As Object) As Boolean
    ' Même parité requise
    If actuel Mod 2 <> fin Mod 2 Then
        PeutEtendreborne = False
        Exit Function
    End If
    
    ' Vérifier s'il y a des exclusions entre fin et actuel
    Dim numeroTest As Long
    For numeroTest = fin + 2 To actuel - 2 Step 2 ' Même parité
        If exclus.Exists(numeroTest) Then
            PeutEtendreborne = False
            Exit Function
        End If
    Next numeroTest
    
    PeutEtendreborne = True
End Function

' =====================================================
' FUNCTION : Formater une plage avec extensions intelligentes
' =====================================================
Function FormaterPlage(debut As Long, fin As Long, groupes As Object) As String
    If debut = fin Then
        ' Une seule valeur - prendre la plus haute extension disponible
        FormaterPlage = ObtenirMeilleureRepresentation(debut, groupes)
    Else
        ' Plage - début sans extension, fin avec la plus haute extension
        Dim debutTexte As String
        Dim finTexte As String
        
        debutTexte = CStr(debut) ' Toujours sans extension pour le début
        finTexte = ObtenirMeilleureRepresentation(fin, groupes) ' Plus haute extension pour la fin
        
        FormaterPlage = debutTexte & " à " & finTexte
    End If
End Function

' =====================================================
' FUNCTION : Obtenir la meilleure représentation d'un numéro
' =====================================================
Function ObtenirMeilleureRepresentation(numeroBase As Long, groupes As Object) As String
    Dim numeroBaseStr As String
    numeroBaseStr = CStr(numeroBase)
    
    If Not groupes.Exists(numeroBaseStr) Then
        ObtenirMeilleureRepresentation = numeroBaseStr
        Exit Function
    End If
    
    Dim groupe As Collection
    Set groupe = groupes(numeroBaseStr)
    
    ' Trouver l'extension la plus élevée dans ce groupe
    Dim meilleureExtension As String
    Dim meilleurOrdre As Integer
    meilleureExtension = ""
    meilleurOrdre = -1
    
    Dim numeroObj As Object
    For Each numeroObj In groupe
        Dim ordreActuel As Integer
        ordreActuel = numeroObj("ordreExtension")
        
        If ordreActuel > meilleurOrdre Then
            meilleurOrdre = ordreActuel
            meilleureExtension = numeroObj("extension")
        End If
    Next
    
    ' Construire la représentation
    If meilleureExtension = "" Then
        ObtenirMeilleureRepresentation = numeroBaseStr
    Else
        ObtenirMeilleureRepresentation = numeroBaseStr & meilleureExtension
    End If
End Function

' =====================================================
' SUB : Trier un tableau de Long
' =====================================================
Sub TrierTableauLong(arr() As Long)
    Dim i As Long, j As Long, temp As Long
    For i = LBound(arr) To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
End Sub

' =====================================================
' FONCTIONS UTILITAIRES NÉCESSAIRES (déjà définies dans les autres modules)
' =====================================================

Function EstUnSymbole(valeur As String) As Boolean
    On Error Resume Next
    EstUnSymbole = False
    
    If Len(Trim(valeur)) = 0 Then Exit Function
    
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.Pattern = "\d"
    reg.Global = True
    
    If Not reg.Test(valeur) Then
        EstUnSymbole = True
    End If
    
    On Error GoTo 0
End Function

Function ExtraireDebutSymbole(texte As String) As String
    Dim i As Integer
    For i = 1 To Len(texte)
        If IsNumeric(Mid(texte, i, 1)) Then
            ExtraireDebutSymbole = Left(texte, i - 1)
            Exit Function
        End If
    Next i
    ExtraireDebutSymbole = ""
End Function

Function ExtraireObservations(texte As String) As String
    Dim lignes As Variant
    
    If InStr(texte, vbCrLf) > 0 Then
        lignes = Split(texte, vbCrLf)
        If UBound(lignes) > 0 Then
            ExtraireObservations = Trim(lignes(1))
        Else
            ExtraireObservations = ""
        End If
    Else
        ExtraireObservations = ""
    End If
End Function

Function ObtenirLibelleVoiePDI(ws As Worksheet, ligneNum As Long, colonne As Long) As String
    Dim ligneVoie As Long
    Dim valVoie As String
    
    ligneVoie = ligneNum + 1
    
    If ligneVoie > ws.Rows.Count Then
        ObtenirLibelleVoiePDI = ""
        Exit Function
    End If
    
    valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne).Value))
    
    If valVoie <> "" Then
        If Left(valVoie, 1) = ChrW(&H25CB) Then
            valVoie = Trim(Mid(valVoie, 3))
        End If
        ObtenirLibelleVoiePDI = valVoie
        Exit Function
    End If
    
    If ws.Cells(ligneVoie, colonne).MergeCells Then
        valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne).MergeArea.Cells(1, 1).Value))
        If Left(valVoie, 1) = ChrW(&H25CB) Then
            valVoie = Trim(Mid(valVoie, 3))
        End If
        ObtenirLibelleVoiePDI = valVoie
        Exit Function
    End If
    
    Dim offset As Long
    For offset = 1 To 5
        If colonne - offset > 0 Then
            valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne - offset).Value))
            If valVoie <> "" Then
                If Left(valVoie, 1) = ChrW(&H25CB) Then
                    valVoie = Trim(Mid(valVoie, 3))
                End If
                ObtenirLibelleVoiePDI = valVoie
                Exit Function
            End If
        End If
        
        If colonne + offset <= ws.Columns.Count Then
            valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne + offset).Value))
            If valVoie <> "" Then
                If Left(valVoie, 1) = ChrW(&H25CB) Then
                    valVoie = Trim(Mid(valVoie, 3))
                End If
                ObtenirLibelleVoiePDI = valVoie
                Exit Function
            End If
        End If
    Next offset
    
    ObtenirLibelleVoiePDI = ""
End Function

Sub AppliquerFormatageDifferencieBornes(rng As Range, contenu As String)
    On Error Resume Next
    With rng
        .Font.Bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    On Error GoTo 0
End Sub

' =====================================================
' MACRO DE TEST : Tester avec l'exemple donné
' =====================================================
Sub TesterExempleUtilisateur()
    Dim msg As String
    msg = "TEST AVEC L'EXEMPLE UTILISATEUR" & vbCrLf & vbCrLf
    
    ' Simuler l'exemple : 3,5,7,9,11,21A,21B,19B,19A,17
    Dim exemple As String
    exemple = "3,5,7,9,11,21A,21B,19B,19A,17"
    
    msg = msg & "Entrée : " & exemple & vbCrLf
    msg = msg & "Résultat attendu : 3 à 11, 17 à 21B" & vbCrLf & vbCrLf
    
    ' Extraire les numéros
    Dim collPairs As New Collection
    Dim collImpairs As New Collection
    Call ExtraireNumerosAvecExtensionsAmelioree(exemple, collPairs, collImpairs)
    
    msg = msg & "Numéros impairs extraits : " & collImpairs.Count & vbCrLf
    
    ' Tester la génération de bornes
    Dim exclus As Object
    Set exclus = CreateObject("Scripting.Dictionary") ' Pas d'exclusions pour le test
    
    Dim resultat As String
    resultat = GenererBornesUltraSimplifiees(collImpairs, exclus)
    
    msg = msg & "Résultat obtenu : " & resultat & vbCrLf & vbCrLf
    
    If resultat = "3 à 11, 17 à 21B" Then
        msg = msg & "✅ SUCCÈS ! Le résultat correspond à l'attendu."
    Else
        msg = msg & "⚠️ Le résultat diffère de l'attendu."
    End If
    
    MsgBox msg, vbInformation, "Test Exemple Utilisateur"
End Sub
