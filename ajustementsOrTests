' =====================================================
' CODE COMPLET - SIMPLIFICATION AVANCÉE DES BORNES PDI AVEC EXTENSIONS
' =====================================================

' =====================================================
' FONCTIONS UTILITAIRES DE BASE
' =====================================================

' Fonction pour vérifier si une valeur contient seulement des symboles
Function EstUnSymbole(valeur As String) As Boolean
    On Error Resume Next
    EstUnSymbole = False
    
    If Len(Trim(valeur)) = 0 Then Exit Function
    
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.Pattern = "\d"
    reg.Global = True
    
    If Not reg.Test(valeur) Then
        EstUnSymbole = True
    End If
    
    On Error GoTo 0
End Function

' Fonction pour extraire le symbole en début de chaîne
Function ExtraireSymboleDebut(texte As String) As String
    Dim premier As String
    
    If Len(texte) = 0 Then
        ExtraireSymboleDebut = ""
        Exit Function
    End If
    
    premier = Left(texte, 1)
    
    If premier = ChrW(&H25B2) Or premier = ChrW(&H25A0) Or premier = ChrW(&H25CB) Then
        If Len(texte) > 1 And Mid(texte, 2, 1) = " " Then
            ExtraireSymboleDebut = Left(texte, 2)
        Else
            ExtraireSymboleDebut = premier
        End If
    Else
        ExtraireSymboleDebut = ""
    End If
End Function

' Fonction pour enlever le symbole en début de chaîne
Function EnleverSymboleDebut(texte As String) As String
    Dim symbole As String
    symbole = ExtraireSymboleDebut(texte)
    
    If symbole <> "" Then
        EnleverSymboleDebut = Trim(Mid(texte, Len(symbole) + 1))
    Else
        EnleverSymboleDebut = texte
    End If
End Function

' Fonction pour extraire les observations d'un texte PDI
Function ExtraireObservations(texte As String) As String
    Dim lignes As Variant
    
    If InStr(texte, vbCrLf) > 0 Then
        lignes = Split(texte, vbCrLf)
        If UBound(lignes) > 0 Then
            ExtraireObservations = Trim(lignes(1))
        Else
            ExtraireObservations = ""
        End If
    Else
        ExtraireObservations = ""
    End If
End Function

' Fonction pour obtenir le libellé de voie pour une cellule PDI
Function ObtenirLibelleVoiePDI(ws As Worksheet, ligneNum As Long, colonne As Long) As String
    Dim ligneVoie As Long
    Dim valVoie As String
    
    ligneVoie = ligneNum + 1
    
    If ligneVoie > ws.Rows.Count Then
        ObtenirLibelleVoiePDI = ""
        Exit Function
    End If
    
    valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne).Value))
    
    If valVoie <> "" Then
        If Left(valVoie, 1) = ChrW(&H25CB) Then
            valVoie = Trim(Mid(valVoie, 3))
        End If
        ObtenirLibelleVoiePDI = valVoie
        Exit Function
    End If
    
    If ws.Cells(ligneVoie, colonne).MergeCells Then
        valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne).MergeArea.Cells(1, 1).Value))
        If Left(valVoie, 1) = ChrW(&H25CB) Then
            valVoie = Trim(Mid(valVoie, 3))
        End If
        ObtenirLibelleVoiePDI = valVoie
        Exit Function
    End If
    
    Dim offset As Long
    For offset = 1 To 5
        If colonne - offset > 0 Then
            valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne - offset).Value))
            If valVoie <> "" Then
                If Left(valVoie, 1) = ChrW(&H25CB) Then
                    valVoie = Trim(Mid(valVoie, 3))
                End If
                ObtenirLibelleVoiePDI = valVoie
                Exit Function
            End If
        End If
        
        If colonne + offset <= ws.Columns.Count Then
            valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne + offset).Value))
            If valVoie <> "" Then
                If Left(valVoie, 1) = ChrW(&H25CB) Then
                    valVoie = Trim(Mid(valVoie, 3))
                End If
                ObtenirLibelleVoiePDI = valVoie
                Exit Function
            End If
        End If
    Next offset
    
    ObtenirLibelleVoiePDI = ""
End Function

' Fonction pour appliquer le formatage différencié
Sub AppliquerFormatageDifferencieBornes(rng As Range, contenu As String)
    On Error Resume Next
    With rng
        .Font.Bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    On Error GoTo 0
End Sub

' =====================================================
' FONCTION PRINCIPALE DE SIMPLIFICATION
' =====================================================
Sub SimplificationBornesNumPDI()
    Dim ws As Worksheet
    Dim wsFacade As Worksheet
    Dim lastRow As Long
    Dim lastCol As Long
    Dim dataParCellule As Object
    Dim i As Long, j As Long
    Dim nbModifiees As Long
    
    Set ws = ActiveSheet
    Set wsFacade = ws
    
    lastRow = wsFacade.Cells(wsFacade.Rows.Count, 1).End(xlUp).Row
    lastCol = 26
    
    Set dataParCellule = CreateObject("Scripting.Dictionary")
    
    Application.ScreenUpdating = False
    
    ' PASSAGE 1 : INDEXER TOUS LES NUMÉROS PAR CELLULE ET VOIE
    For i = 1 To lastRow Step 2
        For j = 1 To lastCol
            Dim celluleNum As Range
            Set celluleNum = wsFacade.Cells(i, j)
            
            Dim valeurNum As String
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                Dim voie As String
                voie = ObtenirLibelleVoiePDI(wsFacade, i, j)
                
                If voie <> "" Then
                    Dim adresse As String
                    adresse = celluleNum.Address
                    
                    If Not dataParCellule.Exists(voie) Then
                        dataParCellule.Add voie, CreateObject("Scripting.Dictionary")
                    End If
                    
                    If Not dataParCellule(voie).Exists(adresse) Then
                        Dim pairImp As Object
                        Set pairImp = CreateObject("Scripting.Dictionary")
                        pairImp.Add "pairs", New Collection
                        pairImp.Add "impairs", New Collection
                        dataParCellule(voie).Add adresse, pairImp
                    End If
                    
                    Dim collPairs As Collection
                    Dim collImpairs As Collection
                    Set collPairs = New Collection
                    Set collImpairs = New Collection
                    
                    Call ExtraireNumerosAvecExtensions(valeurNum, collPairs, collImpairs)
                    
                    Dim numeroObj As Object
                    For Each numeroObj In collPairs
                        dataParCellule(voie)(adresse)("pairs").Add numeroObj
                    Next
                    For Each numeroObj In collImpairs
                        dataParCellule(voie)(adresse)("impairs").Add numeroObj
                    Next
                End If
            End If
        Next j
    Next i
    
    ' PASSAGE 2 : TRAITEMENT ET GÉNÉRATION DES BORNES
    nbModifiees = 0
    
    For i = 1 To lastRow Step 2
        For j = 1 To lastCol
            Set celluleNum = wsFacade.Cells(i, j)
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                voie = ObtenirLibelleVoiePDI(wsFacade, i, j)
                adresse = celluleNum.Address
                
                If voie <> "" And dataParCellule.Exists(voie) And dataParCellule(voie).Exists(adresse) Then
                    Set collPairs = dataParCellule(voie)(adresse)("pairs")
                    Set collImpairs = dataParCellule(voie)(adresse)("impairs")
                    
                    Dim autresP As Object
                    Dim autresI As Object
                    Set autresP = CreateObject("Scripting.Dictionary")
                    Set autresI = CreateObject("Scripting.Dictionary")
                    
                    Dim otherAdr As Variant
                    For Each otherAdr In dataParCellule(voie).Keys
                        If otherAdr <> adresse Then
                            For Each numeroObj In dataParCellule(voie)(otherAdr)("pairs")
                                autresP(numeroObj("numeroBase")) = True
                            Next
                            For Each numeroObj In dataParCellule(voie)(otherAdr)("impairs")
                                autresI(numeroObj("numeroBase")) = True
                            Next
                        End If
                    Next
                    
                    Dim nouveauTexte As String
                    nouveauTexte = GenererTexteBornesAvecExtensions(collPairs, collImpairs, autresP, autresI, valeurNum)
                    
                    If nouveauTexte <> "" And nouveauTexte <> celluleNum.Value Then
                        Dim formatOriginal As Variant
                        Dim couleurFond As Long
                        Dim couleurTexte As Long
                        Dim estGras As Boolean
                        
                        formatOriginal = celluleNum.NumberFormat
                        couleurFond = celluleNum.Interior.Color
                        couleurTexte = celluleNum.Font.Color
                        estGras = celluleNum.Font.Bold
                        
                        celluleNum.Value = nouveauTexte
                        
                        celluleNum.NumberFormat = formatOriginal
                        celluleNum.Interior.Color = couleurFond
                        celluleNum.Font.Color = couleurTexte
                        celluleNum.Font.Bold = estGras
                        
                        Call AppliquerFormatageDifferencieBornes(celluleNum, nouveauTexte)
                        
                        nbModifiees = nbModifiees + 1
                    End If
                End If
            End If
        Next j
    Next i
    
    Application.ScreenUpdating = True
    
    MsgBox "Simplification des bornes terminée (avec gestion des extensions)." & vbCrLf & _
           "Nombre de cellules modifiées : " & nbModifiees, _
           vbInformation, "Bornes PDI"
End Sub

' =====================================================
' EXTRACTION DES NUMÉROS AVEC EXTENSIONS
' =====================================================
Sub ExtraireNumerosAvecExtensions(valeur As String, ByRef numsP As Collection, ByRef numsI As Collection)
    On Error Resume Next
    
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.Pattern = "\b(\d+)\s*([a-zA-Z]*|bis|ter|quater)?\b"
    reg.Global = True
    reg.IgnoreCase = True
    
    Dim matches As Object
    Set matches = reg.Execute(valeur)
    
    Dim i As Long
    Dim numeroBase As Long
    Dim extension As String
    Dim numeroObj As Object
    
    For i = 0 To matches.Count - 1
        numeroBase = CLng(matches(i).SubMatches(0))
        extension = Trim(matches(i).SubMatches(1))
        
        If Err.Number = 0 And numeroBase > 0 Then
            Set numeroObj = CreerObjetNumero(numeroBase, extension, matches(i).Value)
            
            If numeroBase Mod 2 = 0 Then
                numsP.Add numeroObj
            Else
                numsI.Add numeroObj
            End If
        End If
        Err.Clear
    Next i
    
    On Error GoTo 0
End Sub

' =====================================================
' CRÉATION ET GESTION DES OBJETS NUMÉROS
' =====================================================
Function CreerObjetNumero(numeroBase As Long, extension As String, texteOriginal As String) As Object
    Dim obj As Object
    Set obj = CreateObject("Scripting.Dictionary")
    
    obj.Add "numeroBase", numeroBase
    obj.Add "extension", NormaliserExtension(extension)
    obj.Add "texteOriginal", Trim(texteOriginal)
    obj.Add "cleUnique", numeroBase & "|" & NormaliserExtension(extension)
    
    Set CreerObjetNumero = obj
End Function

Function NormaliserExtension(ext As String) As String
    Dim extClean As String
    extClean = UCase(Trim(ext))
    
    Select Case extClean
        Case "BIS"
            NormaliserExtension = "BIS"
        Case "TER"
            NormaliserExtension = "TER"
        Case "QUATER", "QUARTER"
            NormaliserExtension = "QUATER"
        Case ""
            NormaliserExtension = ""
        Case Else
            If Len(extClean) = 1 And extClean >= "A" And extClean <= "Z" Then
                NormaliserExtension = extClean
            Else
                NormaliserExtension = extClean
            End If
    End Select
End Function

' =====================================================
' GÉNÉRATION DES BORNES AVEC EXTENSIONS
' =====================================================
Function GenererTexteBornesAvecExtensions(collPairs As Collection, collImpairs As Collection, _
                                        autresP As Object, autresI As Object, texteOriginal As String) As String
    
    Dim res As String
    res = ""
    
    Dim debutTexte As String
    debutTexte = ExtraireDebutSymbole(texteOriginal)
    
    Dim estMultiVoies As Boolean
    estMultiVoies = DetecterCaseMultiVoies(texteOriginal)
    
    If collPairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesAvecExtensions(collPairs, autresP)
        If resPairs <> "" Then res = resPairs
    End If
    
    If collImpairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesAvecExtensions(collImpairs, autresI)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    If estMultiVoies And res <> "" Then
        res = "[" & res & "]"
    End If
    
    Dim observations As String
    observations = ExtraireObservations(texteOriginal)
    
    If res <> "" Then
        If observations <> "" Then
            GenererTexteBornesAvecExtensions = debutTexte & res & vbCrLf & observations
        Else
            GenererTexteBornesAvecExtensions = debutTexte & res
        End If
    Else
        GenererTexteBornesAvecExtensions = texteOriginal
    End If
End Function

Function GenererBornesAvecExtensions(coll As Collection, exclus As Object) As String
    Dim groupes As Object
    Set groupes = CreateObject("Scripting.Dictionary")
    
    Dim numeroObj As Object
    Dim numeroBase As String
    
    For Each numeroObj In coll
        numeroBase = CStr(numeroObj("numeroBase"))
        
        If Not groupes.Exists(numeroBase) Then
            groupes.Add numeroBase, New Collection
        End If
        
        groupes(numeroBase).Add numeroObj
    Next
    
    Dim arr() As Long
    ReDim arr(groupes.Count - 1)
    Dim i As Long
    i = 0
    
    For Each numeroBase In groupes.Keys
        arr(i) = CLng(numeroBase)
        i = i + 1
    Next
    
    Call TrierTableau(arr)
    
    Dim segments As Collection
    Set segments = IdentifierSegmentsContinusAvecExtensions(arr, exclus, groupes)
    
    Dim res As String
    res = ""
    
    For i = 1 To segments.Count
        If i > 1 Then res = res & ", "
        res = res & segments(i)
    Next i
    
    GenererBornesAvecExtensions = res
End Function

Function IdentifierSegmentsContinusAvecExtensions(arr() As Long, exclus As Object, groupes As Object) As Collection
    Dim segments As New Collection
    Dim i As Long
    Dim debut As Long, fin As Long
    
    debut = arr(0)
    fin = arr(0)
    
    For i = 1 To UBound(arr)
        Dim actuel As Long
        actuel = arr(i)
        
        If PeutEtendreSegment(fin, actuel, exclus) Then
            fin = actuel
        Else
            Dim segmentTexte As String
            segmentTexte = CreerAffichageSegment(debut, fin, groupes)
            segments.Add segmentTexte
            
            debut = actuel
            fin = actuel
        End If
    Next i
    
    segmentTexte = CreerAffichageSegment(debut, fin, groupes)
    segments.Add segmentTexte
    
    Set IdentifierSegmentsContinusAvecExtensions = segments
End Function

Function PeutEtendreSegment(fin As Long, actuel As Long, exclus As Object) As Boolean
    Dim num As Long
    For num = fin + 1 To actuel - 1
        If exclus.Exists(num) Then
            PeutEtendreSegment = False
            Exit Function
        End If
    Next num
    
    PeutEtendreSegment = True
End Function

Function CreerAffichageSegment(debut As Long, fin As Long, groupes As Object) As String
    If debut = fin Then
        CreerAffichageSegment = DeterminerAffichageOptimal(groupes(CStr(debut)))
    Else
        Dim affichageDebut As String
        Dim affichageFin As String
        
        affichageDebut = DeterminerAffichageDebutBorne(groupes(CStr(debut)))
        affichageFin = DeterminerAffichageFinBorne(groupes(CStr(fin)))
        
        CreerAffichageSegment = affichageDebut & " à " & affichageFin
    End If
End Function

Function DeterminerAffichageOptimal(groupe As Collection) As String
    If groupe.Count = 1 Then
        DeterminerAffichageOptimal = groupe(1)("texteOriginal")
    Else
        Dim aUneSansExtension As Boolean
        Dim numeroBase As String
        Dim extensionMax As String
        
        aUneSansExtension = False
        numeroBase = ""
        extensionMax = ""
        
        Dim numeroObj As Object
        For Each numeroObj In groupe
            If numeroBase = "" Then numeroBase = CStr(numeroObj("numeroBase"))
            
            If numeroObj("extension") = "" Then
                aUneSansExtension = True
            Else
                If extensionMax = "" Or numeroObj("extension") > extensionMax Then
                    extensionMax = numeroObj("extension")
                End If
            End If
        Next
        
        If aUneSansExtension Then
            DeterminerAffichageOptimal = numeroBase
        Else
            If extensionMax <> "" Then
                DeterminerAffichageOptimal = numeroBase & extensionMax
            Else
                DeterminerAffichageOptimal = numeroBase
            End If
        End If
    End If
End Function

Function DeterminerAffichageDebutBorne(groupe As Collection) As String
    Dim numeroBase As String
    Dim extensionMin As String
    Dim aUneSansExtension As Boolean
    
    numeroBase = CStr(groupe(1)("numeroBase"))
    extensionMin = ""
    aUneSansExtension = False
    
    Dim numeroObj As Object
    For Each numeroObj In groupe
        If numeroObj("extension") = "" Then
            aUneSansExtension = True
        Else
            If extensionMin = "" Or numeroObj("extension") < extensionMin Then
                extensionMin = numeroObj("extension")
            End If
        End If
    Next
    
    If aUneSansExtension Then
        DeterminerAffichageDebutBorne = numeroBase
    ElseIf extensionMin <> "" Then
        DeterminerAffichageDebutBorne = numeroBase & extensionMin
    Else
        DeterminerAffichageDebutBorne = numeroBase
    End If
End Function

Function DeterminerAffichageFinBorne(groupe As Collection) As String
    Dim numeroBase As String
    Dim extensionMax As String
    
    numeroBase = CStr(groupe(1)("numeroBase"))
    extensionMax = ""
    
    Dim numeroObj As Object
    For Each numeroObj In groupe
        If numeroObj("extension") <> "" Then
            If extensionMax = "" Or numeroObj("extension") > extensionMax Then
                extensionMax = numeroObj("extension")
            End If
        End If
    Next
    
    If extensionMax <> "" Then
        DeterminerAffichageFinBorne = numeroBase & extensionMax
    Else
        DeterminerAffichageFinBorne = numeroBase
    End If
End Function

' =====================================================
' DÉTECTION DES MULTI-VOIES
' =====================================================
Function DetecterCaseMultiVoies(texteOriginal As String) As Boolean
    If InStr(texteOriginal, " / ") > 0 Then
        DetecterCaseMultiVoies = True
        Exit Function
    End If
    
    Dim celluleActive As Range
    On Error Resume Next
    Set celluleActive = Selection
    If Not celluleActive Is Nothing Then
        If celluleActive.Row Mod 2 = 1 Then
            Dim celluleVoie As Range
            Set celluleVoie = ActiveSheet.Cells(celluleActive.Row + 1, celluleActive.Column)
            Dim texteVoie As String
            texteVoie = CStr(celluleVoie.Value)
            
            If InStr(texteVoie, " / ") > 0 Or Left(texteVoie, 1) = ChrW(&H25CB) Then
                DetecterCaseMultiVoies = True
                Exit Function
            End If
        End If
    End If
    On Error GoTo 0
    
    If ContientGroupesNumeriquesSepares(texteOriginal) Then
        DetecterCaseMultiVoies = True
        Exit Function
    End If
    
    DetecterCaseMultiVoies = False
End Function

Function ContientGroupesNumeriquesSepares(texte As String) As Boolean
    Dim regex As Object
    Set regex = CreateObject("VBScript.RegExp")
    
    regex.Pattern = "\d+(?:[-]\d+)*\s+\d+(?:[-]\d+)*"
    regex.Global = True
    
    ContientGroupesNumeriquesSepares = regex.Test(texte)
End Function

Function ExtraireDebutSymbole(texte As String) As String
    Dim i As Integer
    For i = 1 To Len(texte)
        If IsNumeric(Mid(texte, i, 1)) Then
            ExtraireDebutSymbole = Left(texte, i - 1)
            Exit Function
        End If
    Next i
    ExtraireDebutSymbole = ""
End Function

' =====================================================
' UTILITAIRES
' =====================================================
Sub TrierTableau(arr() As Long)
    Dim i As Long, j As Long, temp As Long
    For i = LBound(arr) To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
End Sub

' =====================================================
' MACROS DE TEST ET DÉMONSTRATION
' =====================================================
Sub DemonstrationSimplificationAvancee()
    Dim tests As Variant
    Dim i As Integer
    Dim msg As String
    
    tests = Array( _
        "3,5,7,9,11,21A,21B,19B,19A,17", _
        "1,3,5A,5B,7,9", _
        "2A,2B,4,6A,8B,10", _
        "15TER,17BIS,19A" _
    )
    
    msg = "DÉMONSTRATION - SIMPLIFICATION AVANCÉE DES BORNES" & vbCrLf & vbCrLf
    
    For i = 0 To UBound(tests)
        msg = msg & "Test " & (i + 1) & " :" & vbCrLf
        msg = msg & "Entrée : " & tests(i) & vbCrLf
        
        Dim collP As New Collection
        Dim collI As New Collection
        Dim exclusVides As Object
        Set exclusVides = CreateObject("Scripting.Dictionary")
        
        Call ExtraireNumerosAvecExtensions(tests(i), collP, collI)
        
        Dim resultat As String
        resultat = ""
        
        If collI.Count > 0 Then
            Dim resImpairs As String
            resImpairs = GenererBornesAvecExtensions(collI, exclusVides)
            If resImpairs <> "" Then resultat = resImpairs
        End If
        
        If collP.Count > 0 Then
            Dim resPairs As String
            resPairs = GenererBornesAvecExtensions(collP, exclusVides)
            If resPairs <> "" Then
                If resultat <> "" Then
                    resultat = resultat & " / " & resPairs
                Else
                    resultat = resPairs
                End If
            End If
        End If
        
        msg = msg & "Résultat : " & resultat & vbCrLf & vbCrLf
    Next i
    
    msg = msg & "NOUVELLES FONCTIONNALITÉS :" & vbCrLf
    msg = msg & "✓ Bornes continues avec extensions (ex: 3 à 21B)" & vbCrLf
    msg = msg & "✓ Gestion intelligente début/fin de borne" & vbCrLf
    msg = msg & "✓ Détection améliorée des multi-voies" & vbCrLf
    msg = msg & "✓ Crochets automatiques pour multi-voies"
    
    MsgBox msg, vbInformation, "Démonstration Avancée"
End Sub

Sub DiagnostiquerCelluleAvancee()
    On Error Resume Next
    
    Dim cellule As Range
    Set cellule = Selection.Cells(1, 1)
    
    Dim valeur As String
    valeur = CStr(cellule.Value)
    
    If valeur = "" Or EstUnSymbole(valeur) Then
        MsgBox "Veuillez sélectionner une cellule contenant des numéros PDI.", vbExclamation
        Exit Sub
    End If
    
    Dim msg As String
    msg = "DIAGNOSTIC AVANCÉ - " & cellule.Address & vbCrLf & vbCrLf
    msg = msg & "Contenu original : " & valeur & vbCrLf & vbCrLf
    
    Dim estMultiVoies As Boolean
    estMultiVoies = DetecterCaseMultiVoies(valeur)
    msg = msg & "Détection multi-voies : " & IIf(estMultiVoies, "✓ OUI", "✗ NON") & vbCrLf & vbCrLf
    
    Dim collP As New Collection
    Dim collI As New Collection
    Call ExtraireNumerosAvecExtensions(valeur, collP, collI)
    
    msg = msg & "Numéros extraits :" & vbCrLf
    msg = msg & "• Pairs : " & collP.Count & " éléments" & vbCrLf
    msg = msg & "• Impairs : " & collI.Count & " éléments" & vbCrLf & vbCrLf
    
    Dim exclusVides As Object
    Set exclusVides = CreateObject("Scripting.Dictionary")
    
    Dim resultatFinal As String
    resultatFinal = GenererTexteBornesAvecExtensions(collP, collI, exclusVides, exclusVides, valeur)
    
    msg = msg & "RÉSULTAT FINAL SIMULÉ :" & vbCrLf
    msg = msg & resultatFinal & vbCrLf & vbCrLf
    
    msg = msg & "NOTE : Ce diagnostic simule le traitement sans exclusions." & vbCrLf
    msg = msg & "Le résultat réel peut varier selon les numéros présents ailleurs."
    
    MsgBox msg, vbInformation, "Diagnostic Avancé"
    
    On Error GoTo 0
End Sub

Sub SimplificationBornesAvancee()
    Dim msg As String
    msg = "SIMPLIFICATION AVANCÉE DES BORNES PDI" & vbCrLf & vbCrLf
    msg = msg & "Cette version inclut :" & vbCrLf
    msg = msg & "✓ Gestion intelligente des extensions (A, B, BIS, TER)" & vbCrLf
    msg = msg & "✓ Bornes continues avec extensions (ex: 3 à 21B)" & vbCrLf
    msg = msg & "✓ Détection automatique des multi-voies" & vbCrLf
    msg = msg & "✓ Application des crochets pour multi-voies" & vbCrLf
    msg = msg & "✓ Exclusions intelligentes basées sur le casier" & vbCrLf & vbCrLf
    msg = msg & "Exemple de transformation :" & vbCrLf
    msg = msg & "3,5,7,9,11,21A,21B,19B,19A,17 → 3 à 11, 17 à 21B" & vbCrLf & vbCrLf
    msg = msg & "Continuer avec le traitement ?"
    
    If MsgBox(msg, vbQuestion + vbYesNo, "Simplification Avancée") = vbYes Then
        Call SimplificationBornesNumPDI
    End If
End Sub

Sub GuideUtilisationBornesAvancees()
    Dim msg As String
    msg = "GUIDE D'UTILISATION - BORNES AVANCÉES" & vbCrLf & vbCrLf
    
    msg = msg & "FONCTIONS DISPONIBLES :" & vbCrLf & vbCrLf
    
    msg = msg & "1. SimplificationBornesNumPDI()" & vbCrLf
    msg = msg & "   → Fonction principale (avec toutes les améliorations)" & vbCrLf & vbCrLf
    
    msg = msg & "2. DemonstrationSimplificationAvancee()" & vbCrLf
    msg = msg & "   → Voir des exemples de transformation" & vbCrLf & vbCrLf
    
    msg = msg & "3. DiagnostiquerCelluleAvancee()" & vbCrLf
    msg = msg & "   → Analyser une cellule sélectionnée" & vbCrLf & vbCrLf
    
    msg = msg & "4. SimplificationBornesAvancee()" & vbCrLf
    msg = msg & "   → Interface utilisateur simplifiée" & vbCrLf & vbCrLf
    
    msg = msg & "EXEMPLES DE TRANSFORMATIONS :" & vbCrLf
    msg = msg & "• 3,5,7,9,11,21A,21B,19B,19A,17 → 3 à 11, 17 à 21B" & vbCrLf
    msg = msg & "• 1A,1B,3,5,7BIS → 1A à 7BIS" & vbCrLf
    msg = msg & "• [Multi-voies] → [bornes avec crochets]" & vbCrLf & vbCrLf
    
    msg = msg & "UTILISATION :" & vbCrLf
    msg = msg & "1. Ouvrir la façade PDI" & vbCrLf
    msg = msg & "2. Exécuter SimplificationBornesNumPDI()" & vbCrLf
    msg = msg & "3. Confirmer le traitement" & vbCrLf
    msg = msg & "4. Vérifier les résultats"
    
    MsgBox msg, vbInformation, "Guide d'Utilisation"
End Sub
