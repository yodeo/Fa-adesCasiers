' =====================================================
' SUB : Simplification des bornes de numéros PDI - VERSION AVEC EXTENSIONS
' =====================================================
Sub SimplificationBornesNumPDI()
    Dim ws As Worksheet
    Dim wsFacade As Worksheet
    Dim lastRow As Long
    Dim lastCol As Long
    Dim dataParCellule As Object
    Dim i As Long, j As Long
    Dim nbModifiees As Long
    
    ' Vérifier qu'on est sur la bonne feuille
    Set ws = ActiveSheet
    If ws.Name <> "Facade_PDI" Then
        MsgBox "Veuillez activer la feuille 'Facade_PDI' avant d'exécuter cette macro.", vbExclamation
        Exit Sub
    End If
    
    Set wsFacade = ws
    
    ' Trouver les limites de la feuille
    lastRow = wsFacade.Cells(wsFacade.Rows.Count, 1).End(xlUp).Row
    lastCol = 26 ' Colonnes A à Z
    
    ' Dictionnaire pour indexer les données par cellule et voie
    Set dataParCellule = CreateObject("Scripting.Dictionary")
    
    Application.ScreenUpdating = False
    
    ' === PASSAGE 1 : INDEXER TOUS LES NUMÉROS PAR CELLULE ET VOIE ===
    For i = 1 To lastRow Step 2 ' Traiter seulement les lignes impaires (numéros PDI)
        For j = 1 To lastCol
            Dim celluleNum As Range
            Set celluleNum = wsFacade.Cells(i, j)
            
            ' Vérifier si la cellule contient des numéros PDI
            Dim valeurNum As String
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                ' Obtenir le libellé de voie correspondant (ligne du dessous)
                Dim voie As String
                voie = ObtenirLibelleVoiePDI(wsFacade, i, j)
                
                If voie <> "" Then
                    Dim adresse As String
                    adresse = celluleNum.Address
                    
                    ' Créer la structure de données si nécessaire
                    If Not dataParCellule.Exists(voie) Then
                        dataParCellule.Add voie, CreateObject("Scripting.Dictionary")
                    End If
                    
                    If Not dataParCellule(voie).Exists(adresse) Then
                        Dim pairImp As Object
                        Set pairImp = CreateObject("Scripting.Dictionary")
                        pairImp.Add "pairs", New Collection
                        pairImp.Add "impairs", New Collection
                        dataParCellule(voie).Add adresse, pairImp
                    End If
                    
                    ' Extraire les numéros pairs et impairs AVEC EXTENSIONS
                    Dim collPairs As Collection
                    Dim collImpairs As Collection
                    Set collPairs = New Collection
                    Set collImpairs = New Collection
                    
                    Call ExtraireNumerosAvecExtensions(valeurNum, collPairs, collImpairs)
                    
                    ' Ajouter aux collections
                    Dim numeroObj As Object
                    For Each numeroObj In collPairs
                        dataParCellule(voie)(adresse)("pairs").Add numeroObj
                    Next
                    For Each numeroObj In collImpairs
                        dataParCellule(voie)(adresse)("impairs").Add numeroObj
                    Next
                End If
            End If
        Next j
    Next i
    
    ' === PASSAGE 2 : TRAITEMENT ET GÉNÉRATION DES BORNES ===
    nbModifiees = 0
    
    For i = 1 To lastRow Step 2
        For j = 1 To lastCol
            Set celluleNum = wsFacade.Cells(i, j)
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                voie = ObtenirLibelleVoiePDI(wsFacade, i, j)
                adresse = celluleNum.Address
                
                If voie <> "" And dataParCellule.Exists(voie) And dataParCellule(voie).Exists(adresse) Then
                    Set collPairs = dataParCellule(voie)(adresse)("pairs")
                    Set collImpairs = dataParCellule(voie)(adresse)("impairs")
                    
                    ' Récupérer les numéros utilisés dans d'autres cellules de la même voie
                    Dim autresP As Object
                    Dim autresI As Object
                    Set autresP = CreateObject("Scripting.Dictionary")
                    Set autresI = CreateObject("Scripting.Dictionary")
                    
                    Dim otherAdr As Variant
                    For Each otherAdr In dataParCellule(voie).Keys
                        If otherAdr <> adresse Then
                            For Each numeroObj In dataParCellule(voie)(otherAdr)("pairs")
                                autresP(numeroObj("numeroBase")) = True
                            Next
                            For Each numeroObj In dataParCellule(voie)(otherAdr)("impairs")
                                autresI(numeroObj("numeroBase")) = True
                            Next
                        End If
                    Next
                    
                    ' Générer le nouveau texte avec bornes
                    Dim nouveauTexte As String
                    nouveauTexte = GenererTexteBornesAvecExtensions(collPairs, collImpairs, autresP, autresI, valeurNum)
                    
                    If nouveauTexte <> "" And nouveauTexte <> celluleNum.Value Then
                        ' Conserver le formatage existant
                        Dim formatOriginal As Variant
                        Dim couleurFond As Long
                        Dim couleurTexte As Long
                        Dim estGras As Boolean
                        
                        formatOriginal = celluleNum.NumberFormat
                        couleurFond = celluleNum.Interior.Color
                        couleurTexte = celluleNum.Font.Color
                        estGras = celluleNum.Font.Bold
                        
                        ' Mettre à jour la valeur
                        celluleNum.Value = nouveauTexte
                        
                        ' Restaurer le formatage
                        celluleNum.NumberFormat = formatOriginal
                        celluleNum.Interior.Color = couleurFond
                        celluleNum.Font.Color = couleurTexte
                        celluleNum.Font.Bold = estGras
                        
                        ' Réappliquer le formatage différencié si nécessaire
                        Call AppliquerFormatageDifferencieBornes(celluleNum, nouveauTexte)
                        
                        nbModifiees = nbModifiees + 1
                    End If
                End If
            End If
        Next j
    Next i
    
    Application.ScreenUpdating = True
    
    ' Message de confirmation
    MsgBox "Simplification des bornes terminée (avec gestion des extensions)." & vbCrLf & _
           "Nombre de cellules modifiées : " & nbModifiees, _
           vbInformation, "Bornes PDI"
End Sub

' =====================================================
' SUB : Extraire les numéros avec extensions - NOUVELLE VERSION
' =====================================================
Sub ExtraireNumerosAvecExtensions(valeur As String, ByRef numsP As Collection, ByRef numsI As Collection)
    On Error Resume Next
    
    ' Expression régulière pour capturer numéros avec extensions optionnelles
    ' Capture : [nombre][espace optionnel][extension optionnelle]
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.pattern = "\b(\d+)\s*([a-zA-Z]*|bis|ter|quater)?\b"
    reg.Global = True
    reg.IgnoreCase = True
    
    Dim matches As Object
    Set matches = reg.Execute(valeur)
    
    Dim i As Long
    Dim numeroBase As Long
    Dim extension As String
    Dim numeroObj As Object
    
    For i = 0 To matches.Count - 1
        numeroBase = CLng(matches(i).SubMatches(0))
        extension = Trim(matches(i).SubMatches(1))
        
        If Err.Number = 0 And numeroBase > 0 Then
            ' Créer un objet représentant le numéro avec extension
            Set numeroObj = CreerObjetNumero(numeroBase, extension, matches(i).Value)
            
            ' Classifier selon la parité du numéro de base
            If numeroBase Mod 2 = 0 Then
                numsP.Add numeroObj
            Else
                numsI.Add numeroObj
            End If
        End If
        Err.Clear
    Next i
    
    On Error GoTo 0
End Sub

' =====================================================
' FUNCTION : Créer un objet représentant un numéro avec extension
' =====================================================
Function CreerObjetNumero(numeroBase As Long, extension As String, texteOriginal As String) As Object
    Dim obj As Object
    Set obj = CreateObject("Scripting.Dictionary")
    
    obj.Add "numeroBase", numeroBase
    obj.Add "extension", NormaliserExtension(extension)
    obj.Add "texteOriginal", Trim(texteOriginal)
    obj.Add "cleUnique", numeroBase & "|" & NormaliserExtension(extension)
    
    Set CreerObjetNumero = obj
End Function

' =====================================================
' FUNCTION : Normaliser les extensions
' =====================================================
Function NormaliserExtension(ext As String) As String
    Dim extClean As String
    extClean = UCase(Trim(ext))
    
    Select Case extClean
        Case "BIS"
            NormaliserExtension = "BIS"
        Case "TER"
            NormaliserExtension = "TER"
        Case "QUATER"
            NormaliserExtension = "QUATER"
        Case ""
            NormaliserExtension = ""
        Case Else
            ' Pour a, b, c, etc.
            If Len(extClean) = 1 And extClean >= "A" And extClean <= "Z" Then
                NormaliserExtension = extClean
            Else
                NormaliserExtension = extClean
            End If
    End Select
End Function

' =====================================================
' FUNCTION : Générer le texte avec bornes AVEC EXTENSIONS
' =====================================================
Function GenererTexteBornesAvecExtensions(collPairs As Collection, collImpairs As Collection, _
                                        autresP As Object, autresI As Object, texteOriginal As String) As String
    
    Dim res As String
    res = ""
    
    ' Détecter et conserver le début du texte original (symboles)
    Dim debutTexte As String
    debutTexte = ExtraireDebutSymbole(texteOriginal)
    
    ' Traiter les numéros pairs
    If collPairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesAvecExtensions(collPairs, autresP)
        If resPairs <> "" Then res = resPairs
    End If
    
    ' Traiter les numéros impairs
    If collImpairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesAvecExtensions(collImpairs, autresI)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    ' Conserver les observations si elles étaient présentes
    Dim observations As String
    observations = ExtraireObservations(texteOriginal)
    
    ' Construire le résultat final
    If res <> "" Then
        If observations <> "" Then
            GenererTexteBornesAvecExtensions = debutTexte & res & vbCrLf & observations
        Else
            GenererTexteBornesAvecExtensions = debutTexte & res
        End If
    Else
        GenererTexteBornesAvecExtensions = texteOriginal
    End If
End Function

' =====================================================
' FUNCTION : Générer bornes avec extensions - VERSION AVEC CONTINUITÉ INTELLIGENTE
' =====================================================
Function GenererBornesAvecExtensions(coll As Collection, exclus As Object) As String
    ' Étape 1 : Regrouper par numéro de base
    Dim groupes As Object
    Set groupes = CreateObject("Scripting.Dictionary")
    
    Dim numeroObj As Object
    Dim numeroBase As String
    
    For Each numeroObj In coll
        numeroBase = CStr(numeroObj("numeroBase"))
        
        If Not groupes.Exists(numeroBase) Then
            groupes.Add numeroBase, New Collection
        End If
        
        groupes(numeroBase).Add numeroObj
    Next
    
    ' Étape 2 : Déterminer l'affichage pour chaque groupe
    Dim affichageParBase As Object
    Set affichageParBase = CreateObject("Scripting.Dictionary")
    
    Dim cle As Variant
    Dim groupe As Collection
    
    For Each cle In groupes.Keys
        Set groupe = groupes(cle)
        affichageParBase.Add cle, DeterminerAffichageGroupe(groupe)
    Next
    
    ' Étape 3 : Convertir en tableau et trier par numéro de base
    Dim arr() As Long
    ReDim arr(groupes.Count - 1)
    Dim i As Long
    i = 0
    
    For Each cle In groupes.Keys
        arr(i) = CLng(cle)
        i = i + 1
    Next
    
    ' Tri des numéros de base
    Call TrierTableau(arr)
    
    ' Étape 4 : NOUVELLE LOGIQUE - Vérifier la possibilité d'une borne continue globale
    If UBound(arr) > 0 Then ' Au moins 2 éléments
        Dim minNum As Long, maxNum As Long
        minNum = arr(0)
        maxNum = arr(UBound(arr))
        
        ' Vérifier si on peut créer une borne continue du min au max
        If PeutCreerBorneContinue(arr, minNum, maxNum, exclus) Then
            ' Créer une seule borne continue
            If minNum = maxNum Then
                GenererBornesAvecExtensions = affichageParBase(CStr(minNum))
            Else
                GenererBornesAvecExtensions = affichageParBase(CStr(minNum)) & " à " & affichageParBase(CStr(maxNum))
            End If
            Exit Function
        End If
    End If
    
    ' Étape 5 : Si borne continue impossible, utiliser la logique classique avec ruptures
    Dim plages As New Collection
    Dim debut As Long, fin As Long
    debut = arr(0)
    fin = arr(0)
    
    For i = 1 To UBound(arr)
        Dim actuel As Long
        actuel = arr(i)
        
        ' Vérifier s'il y a des exclusions entre fin et actuel
        Dim ok As Boolean
        ok = True
        
        Dim k As Long
        For k = fin + 1 To actuel - 1
            If exclus.Exists(k) Then
                ok = False
                Exit For
            End If
        Next k
        
        If ok And (actuel = fin + 1) Then
            ' Continuité : étendre la plage
            fin = actuel
        Else
            ' Rupture : terminer la plage actuelle
            If debut = fin Then
                plages.Add affichageParBase(CStr(debut))
            Else
                plages.Add affichageParBase(CStr(debut)) & " à " & affichageParBase(CStr(fin))
            End If
            debut = actuel
            fin = actuel
        End If
    Next i
    
    ' Ajouter la dernière plage
    If debut = fin Then
        plages.Add affichageParBase(CStr(debut))
    Else
        plages.Add affichageParBase(CStr(debut)) & " à " & affichageParBase(CStr(fin))
    End If
    
    ' Étape 6 : Construire le résultat
    Dim res As String
    res = ""
    For i = 1 To plages.Count
        If i > 1 Then res = res & ", "
        res = res & plages(i)
    Next i
    
    GenererBornesAvecExtensions = res
End Function

' =====================================================
' FUNCTION : Vérifier si on peut créer une borne continue
' =====================================================
Function PeutCreerBorneContinue(numerosPresents() As Long, minNum As Long, maxNum As Long, exclus As Object) As Boolean
    ' Créer un dictionnaire des numéros présents dans la case actuelle
    Dim presentsDict As Object
    Set presentsDict = CreateObject("Scripting.Dictionary")
    
    Dim i As Long
    For i = 0 To UBound(numerosPresents)
        presentsDict(numerosPresents(i)) = True
    Next i
    
    ' Vérifier tous les numéros entre min et max (même parité)
    Dim num As Long
    Dim parite As Integer
    parite = minNum Mod 2 ' 0 pour pair, 1 pour impair
    
    For num = minNum To maxNum
        ' Ne vérifier que les numéros de même parité
        If num Mod 2 = parite Then
            ' Si ce numéro n'est pas dans la case actuelle
            If Not presentsDict.Exists(num) Then
                ' Vérifier s'il existe dans d'autres cases (exclusions)
                If exclus.Exists(num) Then
                    ' Ce numéro manquant existe ailleurs → impossible de créer une borne continue
                    PeutCreerBorneContinue = False
                    Exit Function
                End If
            End If
        End If
    Next num
    
    ' Si on arrive ici, aucun numéro manquant n'existe ailleurs
    PeutCreerBorneContinue = True
End Function

' =====================================================
' FUNCTION : Déterminer l'affichage optimal pour un groupe
' =====================================================
Function DeterminerAffichageGroupe(groupe As Collection) As String
    ' Si le groupe ne contient qu'un élément, utiliser son texte original
    If groupe.Count = 1 Then
        DeterminerAffichageGroupe = groupe(1)("texteOriginal")
        Exit Function
    End If
    
    ' Si le groupe contient plusieurs éléments, analyser
    Dim aUneSansExtension As Boolean
    Dim numeroBase As String
    aUneSansExtension = False
    numeroBase = ""
    
    Dim numeroObj As Object
    For Each numeroObj In groupe
        If numeroBase = "" Then numeroBase = CStr(numeroObj("numeroBase"))
        
        If numeroObj("extension") = "" Then
            aUneSansExtension = True
            Exit For
        End If
    Next
    
    ' Si on a le numéro de base sans extension parmi les éléments,
    ' utiliser le numéro de base seul
    If aUneSansExtension Then
        DeterminerAffichageGroupe = numeroBase
    Else
        ' Sinon, utiliser la première extension trouvée (arbitraire)
        DeterminerAffichageGroupe = groupe(1)("texteOriginal")
    End If
End Function

' =====================================================
' FUNCTION : Extraire le début symbolique du texte
' =====================================================
Function ExtraireDebutSymbole(texte As String) As String
    Dim i As Integer
    For i = 1 To Len(texte)
        If IsNumeric(Mid(texte, i, 1)) Then
            ExtraireDebutSymbole = Left(texte, i - 1)
            Exit Function
        End If
    Next i
    ExtraireDebutSymbole = ""
End Function

' =====================================================
' SUB : Trier un tableau d'entiers longs
' =====================================================
Sub TrierTableau(arr() As Long)
    Dim i As Long, j As Long, temp As Long
    For i = LBound(arr) To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
End Sub

' =====================================================
' MACRO DE TEST : Tester la continuité intelligente
' =====================================================
Sub TesterContinuiteIntelligente()
    Dim msg As String
    msg = "TESTS DE LA CONTINUITÉ INTELLIGENTE" & vbCrLf & vbCrLf
    
    ' Simuler des tests avec différents cas
    msg = msg & "Cas 1 : Numéros [1,3,9,11,15] sans conflit" & vbCrLf
    msg = msg & "  → Numéros manquants (5,7,13) non présents ailleurs" & vbCrLf
    msg = msg & "  → Résultat attendu : '1 à 15'" & vbCrLf & vbCrLf
    
    msg = msg & "Cas 2 : Numéros [1,3,9,11,15] avec conflit" & vbCrLf
    msg = msg & "  → Numéro manquant 7 présent dans une autre case" & vbCrLf
    msg = msg & "  → Résultat attendu : '1, 3', '9, 11', '15' (bornes séparées)" & vbCrLf & vbCrLf
    
    msg = msg & "Cas 3 : Numéros [2,6,10,14] sans conflit" & vbCrLf
    msg = msg & "  → Numéros manquants pairs (4,8,12) non présents ailleurs" & vbCrLf
    msg = msg & "  → Résultat attendu : '2 à 14' (pairs seulement)" & vbCrLf & vbCrLf
    
    msg = msg & "LOGIQUE APPLIQUÉE :" & vbCrLf
    msg = msg & "1. Identifier min et max des numéros présents" & vbCrLf
    msg = msg & "2. Vérifier tous les numéros manquants de même parité" & vbCrLf
    msg = msg & "3. Si aucun numéro manquant n'existe ailleurs → borne continue" & vbCrLf
    msg = msg & "4. Sinon → bornes avec ruptures (logique classique)" & vbCrLf & vbCrLf
    
    msg = msg & "La macro applique maintenant cette logique automatiquement !"
    
    MsgBox msg, vbInformation, "Test Continuité Intelligente"
End Sub

' =====================================================
' MACRO DE DÉMONSTRATION : Analyser une case sélectionnée
' =====================================================
Sub AnalyserContinuiteCaseSelectionnee()
    On Error Resume Next
    
    Dim cellule As Range
    Set cellule = Selection.Cells(1, 1)
    
    Dim valeur As String
    valeur = CStr(cellule.Value)
    
    If valeur = "" Or EstUnSymbole(valeur) Then
        MsgBox "Veuillez sélectionner une cellule contenant des numéros PDI.", vbExclamation
        Exit Sub
    End If
    
    ' Extraire les numéros
    Dim collP As New Collection
    Dim collI As New Collection
    Call ExtraireNumerosAvecExtensions(valeur, collP, collI)
    
    Dim msg As String
    msg = "ANALYSE DE CONTINUITÉ - " & cellule.Address & vbCrLf & vbCrLf
    msg = msg & "Contenu : " & valeur & vbCrLf & vbCrLf
    
    ' Analyser les impairs
    If collI.Count > 0 Then
        msg = msg & "NUMÉROS IMPAIRS :" & vbCrLf
        msg = msg & AnalyserCollectionContinuite(collI) & vbCrLf & vbCrLf
    End If
    
    ' Analyser les pairs
    If collP.Count > 0 Then
        msg = msg & "NUMÉROS PAIRS :" & vbCrLf
        msg = msg & AnalyserCollectionContinuite(collP) & vbCrLf & vbCrLf
    End If
    
    msg = msg & "REMARQUE : Cette analyse ne tient pas compte des exclusions" & vbCrLf
    msg = msg & "dans d'autres cases. Utilisez la macro complète pour un" & vbCrLf
    msg = msg & "traitement avec gestion des conflits."
    
    MsgBox msg, vbInformation, "Analyse Continuité"
    
    On Error GoTo 0
End Sub

' =====================================================
' FUNCTION : Analyser une collection pour la continuité
' =====================================================
Function AnalyserCollectionContinuite(coll As Collection) As String
    If coll.Count = 0 Then
        AnalyserCollectionContinuite = "Aucun numéro"
        Exit Function
    End If
    
    ' Extraire les numéros de base
    Dim arr() As Long
    ReDim arr(coll.Count - 1)
    Dim i As Long
    
    For i = 1 To coll.Count
        arr(i - 1) = coll(i)("numeroBase")
    Next i
    
    ' Trier
    Call TrierTableau(arr)
    
    Dim msg As String
    Dim minNum As Long, maxNum As Long
    minNum = arr(0)
    maxNum = arr(UBound(arr))
    
    msg = "Numéros présents : "
    For i = 0 To UBound(arr)
        If i > 0 Then msg = msg & ", "
        msg = msg & arr(i)
    Next i
    msg = msg & vbCrLf
    
    msg = msg & "Plage : " & minNum & " à " & maxNum & vbCrLf
    
    ' Identifier les numéros manquants de même parité
    Dim manquants As String
    manquants = ""
    Dim parite As Integer
    parite = minNum Mod 2
    
    Dim presentDict As Object
    Set presentDict = CreateObject("Scripting.Dictionary")
    For i = 0 To UBound(arr)
        presentDict(arr(i)) = True
    Next i
    
    Dim num As Long
    For num = minNum To maxNum
        If num Mod 2 = parite And Not presentDict.Exists(num) Then
            If manquants <> "" Then manquants = manquants & ", "
            manquants = manquants & num
        End If
    Next num
    
    If manquants = "" Then
        msg = msg & "Aucun numéro manquant → Borne continue possible : " & minNum & " à " & maxNum
    Else
        msg = msg & "Numéros manquants : " & manquants & vbCrLf
        msg = msg & "→ Borne continue SI ces numéros ne sont pas ailleurs"
    End If
    
    AnalyserCollectionContinuite = msg
End Function
