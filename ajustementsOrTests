' =====================================================
' SUB : Simplification des bornes de numéros PDI - VERSION AVEC EXTENSIONS
' =====================================================
Sub SimplificationBornesNumPDI()
    Dim ws As Worksheet
    Dim wsFacade As Worksheet
    Dim lastRow As Long
    Dim lastCol As Long
    Dim dataParCellule As Object
    Dim i As Long, j As Long
    Dim nbModifiees As Long
    
    ' Vérifier qu'on est sur la bonne feuille
    Set ws = ActiveSheet
    If ws.Name <> "Facade_PDI" Then
        MsgBox "Veuillez activer la feuille 'Facade_PDI' avant d'exécuter cette macro.", vbExclamation
        Exit Sub
    End If
    
    Set wsFacade = ws
    
    ' Trouver les limites de la feuille
    lastRow = wsFacade.Cells(wsFacade.Rows.Count, 1).End(xlUp).Row
    lastCol = 26 ' Colonnes A à Z
    
    ' Dictionnaire pour indexer les données par cellule et voie
    Set dataParCellule = CreateObject("Scripting.Dictionary")
    
    Application.ScreenUpdating = False
    
    ' === PASSAGE 1 : INDEXER TOUS LES NUMÉROS PAR CELLULE ET VOIE ===
    For i = 1 To lastRow Step 2 ' Traiter seulement les lignes impaires (numéros PDI)
        For j = 1 To lastCol
            Dim celluleNum As Range
            Set celluleNum = wsFacade.Cells(i, j)
            
            ' Vérifier si la cellule contient des numéros PDI
            Dim valeurNum As String
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                ' Obtenir le libellé de voie correspondant (ligne du dessous)
                Dim voie As String
                voie = ObtenirLibelleVoiePDI(wsFacade, i, j)
                
                If voie <> "" Then
                    Dim adresse As String
                    adresse = celluleNum.Address
                    
                    ' Créer la structure de données si nécessaire
                    If Not dataParCellule.Exists(voie) Then
                        dataParCellule.Add voie, CreateObject("Scripting.Dictionary")
                    End If
                    
                    If Not dataParCellule(voie).Exists(adresse) Then
                        Dim pairImp As Object
                        Set pairImp = CreateObject("Scripting.Dictionary")
                        pairImp.Add "pairs", New Collection
                        pairImp.Add "impairs", New Collection
                        dataParCellule(voie).Add adresse, pairImp
                    End If
                    
                    ' Extraire les numéros pairs et impairs AVEC EXTENSIONS
                    Dim collPairs As Collection
                    Dim collImpairs As Collection
                    Set collPairs = New Collection
                    Set collImpairs = New Collection
                    
                    Call ExtraireNumerosAvecExtensions(valeurNum, collPairs, collImpairs)
                    
                    ' Ajouter aux collections
                    Dim numeroObj As Object
                    For Each numeroObj In collPairs
                        dataParCellule(voie)(adresse)("pairs").Add numeroObj
                    Next
                    For Each numeroObj In collImpairs
                        dataParCellule(voie)(adresse)("impairs").Add numeroObj
                    Next
                End If
            End If
        Next j
    Next i
    
    ' === PASSAGE 2 : TRAITEMENT ET GÉNÉRATION DES BORNES ===
    nbModifiees = 0
    
    For i = 1 To lastRow Step 2
        For j = 1 To lastCol
            Set celluleNum = wsFacade.Cells(i, j)
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                voie = ObtenirLibelleVoiePDI(wsFacade, i, j)
                adresse = celluleNum.Address
                
                If voie <> "" And dataParCellule.Exists(voie) And dataParCellule(voie).Exists(adresse) Then
                    Set collPairs = dataParCellule(voie)(adresse)("pairs")
                    Set collImpairs = dataParCellule(voie)(adresse)("impairs")
                    
                    ' Récupérer les numéros utilisés dans d'autres cellules de la même voie
                    Dim autresP As Object
                    Dim autresI As Object
                    Set autresP = CreateObject("Scripting.Dictionary")
                    Set autresI = CreateObject("Scripting.Dictionary")
                    
                    Dim otherAdr As Variant
                    For Each otherAdr In dataParCellule(voie).Keys
                        If otherAdr <> adresse Then
                            For Each numeroObj In dataParCellule(voie)(otherAdr)("pairs")
                                autresP(numeroObj("numeroBase")) = True
                            Next
                            For Each numeroObj In dataParCellule(voie)(otherAdr)("impairs")
                                autresI(numeroObj("numeroBase")) = True
                            Next
                        End If
                    Next
                    
                    ' Générer le nouveau texte avec bornes
                    Dim nouveauTexte As String
                    nouveauTexte = GenererTexteBornesAvecExtensions(collPairs, collImpairs, autresP, autresI, valeurNum)
                    
                    If nouveauTexte <> "" And nouveauTexte <> celluleNum.Value Then
                        ' Conserver le formatage existant
                        Dim formatOriginal As Variant
                        Dim couleurFond As Long
                        Dim couleurTexte As Long
                        Dim estGras As Boolean
                        
                        formatOriginal = celluleNum.NumberFormat
                        couleurFond = celluleNum.Interior.Color
                        couleurTexte = celluleNum.Font.Color
                        estGras = celluleNum.Font.Bold
                        
                        ' Mettre à jour la valeur
                        celluleNum.Value = nouveauTexte
                        
                        ' Restaurer le formatage
                        celluleNum.NumberFormat = formatOriginal
                        celluleNum.Interior.Color = couleurFond
                        celluleNum.Font.Color = couleurTexte
                        celluleNum.Font.Bold = estGras
                        
                        ' Réappliquer le formatage différencié si nécessaire
                        Call AppliquerFormatageDifferencieBornes(celluleNum, nouveauTexte)
                        
                        nbModifiees = nbModifiees + 1
                    End If
                End If
            End If
        Next j
    Next i
    
    Application.ScreenUpdating = True
    
    ' Message de confirmation
    MsgBox "Simplification des bornes terminée (avec gestion des extensions)." & vbCrLf & _
           "Nombre de cellules modifiées : " & nbModifiees, _
           vbInformation, "Bornes PDI"
End Sub

' =====================================================
' SUB : Extraire les numéros avec extensions - NOUVELLE VERSION
' =====================================================
Sub ExtraireNumerosAvecExtensions(valeur As String, ByRef numsP As Collection, ByRef numsI As Collection)
    On Error Resume Next
    
    ' Expression régulière pour capturer numéros avec extensions optionnelles
    ' Capture : [nombre][espace optionnel][extension optionnelle]
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.pattern = "\b(\d+)\s*([a-zA-Z]*|bis|ter|quater)?\b"
    reg.Global = True
    reg.IgnoreCase = True
    
    Dim matches As Object
    Set matches = reg.Execute(valeur)
    
    Dim i As Long
    Dim numeroBase As Long
    Dim extension As String
    Dim numeroObj As Object
    
    For i = 0 To matches.Count - 1
        numeroBase = CLng(matches(i).SubMatches(0))
        extension = Trim(matches(i).SubMatches(1))
        
        If Err.Number = 0 And numeroBase > 0 Then
            ' Créer un objet représentant le numéro avec extension
            Set numeroObj = CreerObjetNumero(numeroBase, extension, matches(i).Value)
            
            ' Classifier selon la parité du numéro de base
            If numeroBase Mod 2 = 0 Then
                numsP.Add numeroObj
            Else
                numsI.Add numeroObj
            End If
        End If
        Err.Clear
    Next i
    
    On Error GoTo 0
End Sub

' =====================================================
' FUNCTION : Créer un objet représentant un numéro avec extension
' =====================================================
Function CreerObjetNumero(numeroBase As Long, extension As String, texteOriginal As String) As Object
    Dim obj As Object
    Set obj = CreateObject("Scripting.Dictionary")
    
    obj.Add "numeroBase", numeroBase
    obj.Add "extension", NormaliserExtension(extension)
    obj.Add "texteOriginal", Trim(texteOriginal)
    obj.Add "cleUnique", numeroBase & "|" & NormaliserExtension(extension)
    
    Set CreerObjetNumero = obj
End Function

' =====================================================
' FUNCTION : Normaliser les extensions - VERSION AMÉLIORÉE
' =====================================================
Function NormaliserExtension(ext As String) As String
    Dim extClean As String
    extClean = UCase(Trim(ext))
    
    ' Normalisation des extensions courantes
    Select Case extClean
        Case "BIS"
            NormaliserExtension = "BIS"
        Case "TER"
            NormaliserExtension = "TER"
        Case "QUATER", "QUARTER"
            NormaliserExtension = "QUATER"
        Case ""
            NormaliserExtension = ""
        Case Else
            ' Pour les lettres simples (A, B, C, etc.)
            If Len(extClean) = 1 And extClean >= "A" And extClean <= "Z" Then
                NormaliserExtension = extClean
            Else
                ' Autres extensions (garder telles quelles mais en majuscules)
                NormaliserExtension = extClean
            End If
    End Select
End Function

' =====================================================
' MACRO PRINCIPALE : Version finale avec toutes les améliorations
' =====================================================
Sub SimplificationBornesAvancee()
    ' Version finale de la macro avec toutes les améliorations
    Dim msg As String
    msg = "SIMPLIFICATION AVANCÉE DES BORNES PDI" & vbCrLf & vbCrLf
    msg = msg & "Cette version inclut :" & vbCrLf
    msg = msg & "✓ Gestion intelligente des extensions (A, B, BIS, TER)" & vbCrLf
    msg = msg & "✓ Bornes continues avec extensions (ex: 3 à 21B)" & vbCrLf
    msg = msg & "✓ Détection automatique des multi-voies" & vbCrLf
    msg = msg & "✓ Application des crochets pour multi-voies" & vbCrLf
    msg = msg & "✓ Exclusions intelligentes basées sur le casier" & vbCrLf & vbCrLf
    msg = msg & "Exemple de transformation :" & vbCrLf
    msg = msg & "3,5,7,9,11,21A,21B,19B,19A,17 → 3 à 11, 17 à 21B" & vbCrLf & vbCrLf
    msg = msg & "Continuer avec le traitement ?"
    
    If MsgBox(msg, vbQuestion + vbYesNo, "Simplification Avancée") = vbYes Then
        Call SimplificationBornesNumPDI
    End If
End Sub

' =====================================================
' MACRO : Bouton simplifié pour les utilisateurs
' =====================================================
Sub BoutonSimplificationAvancee()
    ' Point d'entrée simple pour les utilisateurs
    Call SimplificationBornesAvancee
End Sub

' =====================================================
' FUNCTION : Générer le texte avec bornes AVEC EXTENSIONS - VERSION AMÉLIORÉE
' =====================================================
Function GenererTexteBornesAvecExtensions(collPairs As Collection, collImpairs As Collection, _
                                        autresP As Object, autresI As Object, texteOriginal As String) As String
    
    Dim res As String
    res = ""
    
    ' Détecter et conserver le début du texte original (symboles)
    Dim debutTexte As String
    debutTexte = ExtraireDebutSymbole(texteOriginal)
    
    ' Détecter si c'est une case multi-voies
    Dim estMultiVoies As Boolean
    estMultiVoies = DetecterCaseMultiVoies(texteOriginal)
    
    ' Traiter les numéros pairs
    If collPairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesAvecExtensions(collPairs, autresP)
        If resPairs <> "" Then res = resPairs
    End If
    
    ' Traiter les numéros impairs
    If collImpairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesAvecExtensions(collImpairs, autresI)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    ' Appliquer les crochets pour les cases multi-voies
    If estMultiVoies And res <> "" Then
        res = "[" & res & "]"
    End If
    
    ' Conserver les observations si elles étaient présentes
    Dim observations As String
    observations = ExtraireObservations(texteOriginal)
    
    ' Construire le résultat final
    If res <> "" Then
        If observations <> "" Then
            GenererTexteBornesAvecExtensions = debutTexte & res & vbCrLf & observations
        Else
            GenererTexteBornesAvecExtensions = debutTexte & res
        End If
    Else
        GenererTexteBornesAvecExtensions = texteOriginal
    End If
End Function

' =====================================================
' FUNCTION : Détecter si une case contient des multi-voies
' =====================================================
Function DetecterCaseMultiVoies(texteOriginal As String) As Boolean
    ' Méthode 1 : Détecter les séparateurs de voies dans le texte des numéros
    If InStr(texteOriginal, " / ") > 0 Then
        DetecterCaseMultiVoies = True
        Exit Function
    End If
    
    ' Méthode 2 : Analyser la cellule de voie correspondante (si possible)
    Dim celluleActive As Range
    On Error Resume Next
    Set celluleActive = Selection
    If Not celluleActive Is Nothing Then
        ' Si on est sur une ligne de numéros (impaire), vérifier la ligne de voie en dessous
        If celluleActive.Row Mod 2 = 1 Then
            Dim celluleVoie As Range
            Set celluleVoie = ActiveSheet.Cells(celluleActive.Row + 1, celluleActive.Column)
            Dim texteVoie As String
            texteVoie = CStr(celluleVoie.Value)
            
            ' Vérifier les indicateurs de multi-voies dans la voie
            If InStr(texteVoie, " / ") > 0 Or Left(texteVoie, 1) = ChrW(&H25CB) Then
                DetecterCaseMultiVoies = True
                Exit Function
            End If
        End If
    End If
    On Error GoTo 0
    
    ' Méthode 3 : Détecter les patterns de numéros multi-voies (ex: groupes séparés)
    ' Si le texte contient des groupes de numéros séparés par des espaces significatifs
    If ContientGroupesNumeriquesSepares(texteOriginal) Then
        DetecterCaseMultiVoies = True
        Exit Function
    End If
    
    DetecterCaseMultiVoies = False
End Function

' =====================================================
' FUNCTION : Vérifier si le texte contient des groupes de numéros séparés
' =====================================================
Function ContientGroupesNumeriquesSepares(texte As String) As Boolean
    ' Cette fonction détecte des patterns comme "1-3-5 7-9-11" qui indiquent des multi-voies
    Dim regex As Object
    Set regex = CreateObject("VBScript.RegExp")
    
    ' Pattern pour détecter des groupes séparés par des espaces (pas des tirets de continuité)
    regex.Pattern = "\d+(?:[-]\d+)*\s+\d+(?:[-]\d+)*"
    regex.Global = True
    
    ContientGroupesNumeriquesSepares = regex.Test(texte)
End Function

' =====================================================
' FUNCTION : Générer bornes avec extensions - VERSION AVANCÉE AVEC CONTINUITÉ INTELLIGENTE
' =====================================================
Function GenererBornesAvecExtensions(coll As Collection, exclus As Object) As String
    ' Étape 1 : Regrouper par numéro de base
    Dim groupes As Object
    Set groupes = CreateObject("Scripting.Dictionary")
    
    Dim numeroObj As Object
    Dim numeroBase As String
    
    For Each numeroObj In coll
        numeroBase = CStr(numeroObj("numeroBase"))
        
        If Not groupes.Exists(numeroBase) Then
            groupes.Add numeroBase, New Collection
        End If
        
        groupes(numeroBase).Add numeroObj
    Next
    
    ' Étape 2 : Convertir en tableau et trier par numéro de base
    Dim arr() As Long
    ReDim arr(groupes.Count - 1)
    Dim i As Long
    i = 0
    
    For Each numeroBase In groupes.Keys
        arr(i) = CLng(numeroBase)
        i = i + 1
    Next
    
    ' Tri des numéros de base
    Call TrierTableau(arr)
    
    ' Étape 3 : LOGIQUE AVANCÉE - Identifier les segments continus
    Dim segments As Collection
    Set segments = IdentifierSegmentsContinusAvecExtensions(arr, exclus, groupes)
    
    ' Étape 4 : Construire le résultat
    Dim res As String
    res = ""
    
    For i = 1 To segments.Count
        If i > 1 Then res = res & ", "
        res = res & segments(i)
    Next i
    
    GenererBornesAvecExtensions = res
End Function

' =====================================================
' FUNCTION : Identifier les segments continus avec gestion des extensions
' =====================================================
Function IdentifierSegmentsContinusAvecExtensions(arr() As Long, exclus As Object, groupes As Object) As Collection
    Dim segments As New Collection
    Dim i As Long
    Dim debut As Long, fin As Long
    
    debut = arr(0)
    fin = arr(0)
    
    For i = 1 To UBound(arr)
        Dim actuel As Long
        actuel = arr(i)
        
        ' Vérifier si on peut étendre le segment actuel
        If PeutEtendreSegment(fin, actuel, exclus) Then
            fin = actuel
        Else
            ' Finaliser le segment actuel
            Dim segmentTexte As String
            segmentTexte = CreerAffichageSegment(debut, fin, groupes)
            segments.Add segmentTexte
            
            ' Commencer un nouveau segment
            debut = actuel
            fin = actuel
        End If
    Next i
    
    ' Ajouter le dernier segment
    segmentTexte = CreerAffichageSegment(debut, fin, groupes)
    segments.Add segmentTexte
    
    Set IdentifierSegmentsContinusAvecExtensions = segments
End Function

' =====================================================
' FUNCTION : Vérifier si on peut étendre un segment
' =====================================================
Function PeutEtendreSegment(fin As Long, actuel As Long, exclus As Object) As Boolean
    ' Vérifier tous les numéros manquants entre fin et actuel
    Dim num As Long
    For num = fin + 1 To actuel - 1
        If exclus.Exists(num) Then
            PeutEtendreSegment = False
            Exit Function
        End If
    Next num
    
    PeutEtendreSegment = True
End Function

' =====================================================
' FUNCTION : Créer l'affichage pour un segment avec gestion intelligente des extensions
' =====================================================
Function CreerAffichageSegment(debut As Long, fin As Long, groupes As Object) As String
    If debut = fin Then
        ' Segment d'un seul numéro
        CreerAffichageSegment = DeterminerAffichageOptimal(groupes(CStr(debut)))
    Else
        ' Segment de plusieurs numéros - borne continue
        Dim affichageDebut As String
        Dim affichageFin As String
        
        affichageDebut = DeterminerAffichageDebutBorne(groupes(CStr(debut)))
        affichageFin = DeterminerAffichageFinBorne(groupes(CStr(fin)))
        
        CreerAffichageSegment = affichageDebut & " à " & affichageFin
    End If
End Function

' =====================================================
' FUNCTION : Déterminer l'affichage optimal pour un groupe unique
' =====================================================
Function DeterminerAffichageOptimal(groupe As Collection) As String
    If groupe.Count = 1 Then
        ' Une seule représentation - utiliser le texte original
        DeterminerAffichageOptimal = groupe(1)("texteOriginal")
    Else
        ' Plusieurs représentations - logique sophistiquée
        Dim aUneSansExtension As Boolean
        Dim numeroBase As String
        Dim extensionMax As String
        
        aUneSansExtension = False
        numeroBase = ""
        extensionMax = ""
        
        Dim numeroObj As Object
        For Each numeroObj In groupe
            If numeroBase = "" Then numeroBase = CStr(numeroObj("numeroBase"))
            
            If numeroObj("extension") = "" Then
                aUneSansExtension = True
            Else
                ' Garder l'extension "la plus élevée" alphabétiquement
                If extensionMax = "" Or numeroObj("extension") > extensionMax Then
                    extensionMax = numeroObj("extension")
                End If
            End If
        Next
        
        ' Si on a le numéro sans extension, l'utiliser
        If aUneSansExtension Then
            DeterminerAffichageOptimal = numeroBase
        Else
            ' Sinon, utiliser le numéro avec l'extension maximale
            If extensionMax <> "" Then
                DeterminerAffichageOptimal = numeroBase & extensionMax
            Else
                DeterminerAffichageOptimal = numeroBase
            End If
        End If
    End If
End Function

' =====================================================
' FUNCTION : Déterminer l'affichage pour le début d'une borne
' =====================================================
Function DeterminerAffichageDebutBorne(groupe As Collection) As String
    ' Pour le début, utiliser la représentation "minimale"
    Dim numeroBase As String
    Dim extensionMin As String
    Dim aUneSansExtension As Boolean
    
    numeroBase = CStr(groupe(1)("numeroBase"))
    extensionMin = ""
    aUneSansExtension = False
    
    Dim numeroObj As Object
    For Each numeroObj In groupe
        If numeroObj("extension") = "" Then
            aUneSansExtension = True
        Else
            If extensionMin = "" Or numeroObj("extension") < extensionMin Then
                extensionMin = numeroObj("extension")
            End If
        End If
    Next
    
    ' Priorité : sans extension > extension minimale
    If aUneSansExtension Then
        DeterminerAffichageDebutBorne = numeroBase
    ElseIf extensionMin <> "" Then
        DeterminerAffichageDebutBorne = numeroBase & extensionMin
    Else
        DeterminerAffichageDebutBorne = numeroBase
    End If
End Function

' =====================================================
' FUNCTION : Déterminer l'affichage pour la fin d'une borne
' =====================================================
Function DeterminerAffichageFinBorne(groupe As Collection) As String
    ' Pour la fin, utiliser la représentation "maximale"
    Dim numeroBase As String
    Dim extensionMax As String
    
    numeroBase = CStr(groupe(1)("numeroBase"))
    extensionMax = ""
    
    Dim numeroObj As Object
    For Each numeroObj In groupe
        If numeroObj("extension") <> "" Then
            If extensionMax = "" Or numeroObj("extension") > extensionMax Then
                extensionMax = numeroObj("extension")
            End If
        End If
    Next
    
    ' Si on a des extensions, utiliser la maximale, sinon le numéro de base
    If extensionMax <> "" Then
        DeterminerAffichageFinBorne = numeroBase & extensionMax
    Else
        DeterminerAffichageFinBorne = numeroBase
    End If
End Function





' =====================================================
' FUNCTION : Extraire le début symbolique du texte
' =====================================================
Function ExtraireDebutSymbole(texte As String) As String
    Dim i As Integer
    For i = 1 To Len(texte)
        If IsNumeric(Mid(texte, i, 1)) Then
            ExtraireDebutSymbole = Left(texte, i - 1)
            Exit Function
        End If
    Next i
    ExtraireDebutSymbole = ""
End Function

' =====================================================
' SUB : Trier un tableau d'entiers longs
' =====================================================
Sub TrierTableau(arr() As Long)
    Dim i As Long, j As Long, temp As Long
    For i = LBound(arr) To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
End Sub

' =====================================================
' MACRO DE TEST : Démonstration de la simplification avancée
' =====================================================
Sub DemonstrationSimplificationAvancee()
    Dim tests As Variant
    Dim resultats As Variant
    Dim i As Integer
    Dim msg As String
    
    ' Cas de test avec les améliorations
    tests = Array( _
        "3,5,7,9,11,21A,21B,19B,19A,17", _
        "1,3,5A,5B,7,9", _
        "2A,2B,4,6A,8B,10", _
        "15TER,17BIS,19A" _
    )
    
    msg = "DÉMONSTRATION - SIMPLIFICATION AVANCÉE DES BORNES" & vbCrLf & vbCrLf
    
    For i = 0 To UBound(tests)
        msg = msg & "Test " & (i + 1) & " :" & vbCrLf
        msg = msg & "Entrée : " & tests(i) & vbCrLf
        
        ' Simuler le traitement (sans exclusions pour la démo)
        Dim collP As New Collection
        Dim collI As New Collection
        Dim exclusVides As Object
        Set exclusVides = CreateObject("Scripting.Dictionary")
        
        Call ExtraireNumerosAvecExtensions(tests(i), collP, collI)
        
        Dim resultat As String
        resultat = ""
        
        If collI.Count > 0 Then
            Dim resImpairs As String
            resImpairs = GenererBornesAvecExtensions(collI, exclusVides)
            If resImpairs <> "" Then resultat = resImpairs
        End If
        
        If collP.Count > 0 Then
            Dim resPairs As String
            resPairs = GenererBornesAvecExtensions(collP, exclusVides)
            If resPairs <> "" Then
                If resultat <> "" Then
                    resultat = resultat & " / " & resPairs
                Else
                    resultat = resPairs
                End If
            End If
        End If
        
        msg = msg & "Résultat : " & resultat & vbCrLf & vbCrLf
    Next i
    
    msg = msg & "NOUVELLES FONCTIONNALITÉS :" & vbCrLf
    msg = msg & "✓ Bornes continues avec extensions (ex: 3 à 21B)" & vbCrLf
    msg = msg & "✓ Gestion intelligente début/fin de borne" & vbCrLf
    msg = msg & "✓ Détection améliorée des multi-voies" & vbCrLf
    msg = msg & "✓ Crochets automatiques pour multi-voies"
    
    MsgBox msg, vbInformation, "Démonstration Avancée"
End Sub

' =====================================================
' MACRO DE DIAGNOSTIC : Analyser une cellule avec la nouvelle logique
' =====================================================
Sub DiagnostiquerCelluleAvancee()
    On Error Resume Next
    
    Dim cellule As Range
    Set cellule = Selection.Cells(1, 1)
    
    Dim valeur As String
    valeur = CStr(cellule.Value)
    
    If valeur = "" Or EstUnSymbole(valeur) Then
        MsgBox "Veuillez sélectionner une cellule contenant des numéros PDI.", vbExclamation
        Exit Sub
    End If
    
    Dim msg As String
    msg = "DIAGNOSTIC AVANCÉ - " & cellule.Address & vbCrLf & vbCrLf
    msg = msg & "Contenu original : " & valeur & vbCrLf & vbCrLf
    
    ' Analyser la détection multi-voies
    Dim estMultiVoies As Boolean
    estMultiVoies = DetecterCaseMultiVoies(valeur)
    msg = msg & "Détection multi-voies : " & IIf(estMultiVoies, "✓ OUI", "✗ NON") & vbCrLf & vbCrLf
    
    ' Extraire et analyser les numéros
    Dim collP As New Collection
    Dim collI As New Collection
    Call ExtraireNumerosAvecExtensions(valeur, collP, collI)
    
    msg = msg & "Numéros extraits :" & vbCrLf
    msg = msg & "• Pairs : " & collP.Count & " éléments" & vbCrLf
    msg = msg & "• Impairs : " & collI.Count & " éléments" & vbCrLf & vbCrLf
    
    ' Analyser les groupes par numéro de base
    If collI.Count > 0 Then
        msg = msg & "ANALYSE IMPAIRS :" & vbCrLf
        msg = msg & AnalyserGroupesExtensions(collI) & vbCrLf & vbCrLf
    End If
    
    If collP.Count > 0 Then
        msg = msg & "ANALYSE PAIRS :" & vbCrLf
        msg = msg & AnalyserGroupesExtensions(collP) & vbCrLf & vbCrLf
    End If
    
    ' Simuler le résultat final
    Dim exclusVides As Object
    Set exclusVides = CreateObject("Scripting.Dictionary")
    
    Dim resultatFinal As String
    resultatFinal = GenererTexteBornesAvecExtensions(collP, collI, exclusVides, exclusVides, valeur)
    
    msg = msg & "RÉSULTAT FINAL SIMULÉ :" & vbCrLf
    msg = msg & resultatFinal & vbCrLf & vbCrLf
    
    msg = msg & "NOTE : Ce diagnostic simule le traitement sans exclusions." & vbCrLf
    msg = msg & "Le résultat réel peut varier selon les numéros présents ailleurs."
    
    MsgBox msg, vbInformation, "Diagnostic Avancé"
    
    On Error GoTo 0
End Sub

' =====================================================
' FUNCTION : Analyser les groupes d'extensions pour le diagnostic
' =====================================================
Function AnalyserGroupesExtensions(coll As Collection) As String
    ' Regrouper par numéro de base
    Dim groupes As Object
    Set groupes = CreateObject("Scripting.Dictionary")
    
    Dim numeroObj As Object
    For Each numeroObj In coll
        Dim numeroBase As String
        numeroBase = CStr(numeroObj("numeroBase"))
        
        If Not groupes.Exists(numeroBase) Then
            groupes.Add numeroBase, New Collection
        End If
        
        groupes(numeroBase).Add numeroObj
    Next
    
    ' Analyser chaque groupe
    Dim resultat As String
    resultat = ""
    
    Dim cle As Variant
    For Each cle In groupes.Keys
        Dim groupe As Collection
        Set groupe = groupes(cle)
        
        resultat = resultat & "Numéro " & cle & " : "
        
        Dim j As Integer
        For j = 1 To groupe.Count
            If j > 1 Then resultat = resultat & ", "
            resultat = resultat & groupe(j)("texteOriginal")
        Next j
        
        ' Analyser l'affichage optimal
        Dim affichageOptimal As String
        affichageOptimal = DeterminerAffichageOptimal(groupe)
        resultat = resultat & " → Affichage: " & affichageOptimal & vbCrLf
    Next cle
    
    AnalyserGroupesExtensions = resultat
End Function

' =====================================================
' MACRO : Test de comparaison avant/après
' =====================================================
Sub ComparerAvantApres()
    Dim exemples As Variant
    exemples = Array( _
        "3,5,7,9,11,21A,21B,19B,19A,17", _
        "1A,1B,3,5,7BIS", _
        "2,4,6TER,8A,8B,10" _
    )
    
    Dim msg As String
    msg = "COMPARAISON AVANT/APRÈS" & vbCrLf & vbCrLf
    
    Dim i As Integer
    For i = 0 To UBound(exemples)
        msg = msg & "Exemple " & (i + 1) & " :" & vbCrLf
        msg = msg & "Entrée : " & exemples(i) & vbCrLf
        msg = msg & "Ancienne logique : traitement basique des extensions" & vbCrLf
        msg = msg & "Nouvelle logique : bornes continues intelligentes" & vbCrLf & vbCrLf
    Next i
    
    msg = msg & "AMÉLIORATIONS CLÉS :" & vbCrLf
    msg = msg & "1. 3,5,7,9,11,17,19A,21B → 3 à 11, 17 à 21B" & vbCrLf
    msg = msg & "2. Gestion début/fin de borne avec extensions" & vbCrLf
    msg = msg & "3. Détection automatique des multi-voies" & vbCrLf
    msg = msg & "4. Application des crochets appropriés"
    
    MsgBox msg, vbInformation, "Comparaison"
End Sub

' =====================================================
' MACRO DE DÉMONSTRATION : Analyser une case sélectionnée
' =====================================================
Sub AnalyserContinuiteCaseSelectionnee()
    On Error Resume Next
    
    Dim cellule As Range
    Set cellule = Selection.Cells(1, 1)
    
    Dim valeur As String
    valeur = CStr(cellule.Value)
    
    If valeur = "" Or EstUnSymbole(valeur) Then
        MsgBox "Veuillez sélectionner une cellule contenant des numéros PDI.", vbExclamation
        Exit Sub
    End If
    
    ' Extraire les numéros
    Dim collP As New Collection
    Dim collI As New Collection
    Call ExtraireNumerosAvecExtensions(valeur, collP, collI)
    
    Dim msg As String
    msg = "ANALYSE DE CONTINUITÉ - " & cellule.Address & vbCrLf & vbCrLf
    msg = msg & "Contenu : " & valeur & vbCrLf & vbCrLf
    
    ' Analyser les impairs
    If collI.Count > 0 Then
        msg = msg & "NUMÉROS IMPAIRS :" & vbCrLf
        msg = msg & AnalyserCollectionContinuite(collI) & vbCrLf & vbCrLf
    End If
    
    ' Analyser les pairs
    If collP.Count > 0 Then
        msg = msg & "NUMÉROS PAIRS :" & vbCrLf
        msg = msg & AnalyserCollectionContinuite(collP) & vbCrLf & vbCrLf
    End If
    
    msg = msg & "REMARQUE : Cette analyse ne tient pas compte des exclusions" & vbCrLf
    msg = msg & "dans d'autres cases. Utilisez la macro complète pour un" & vbCrLf
    msg = msg & "traitement avec gestion des conflits."
    
    MsgBox msg, vbInformation, "Analyse Continuité"
    
    On Error GoTo 0
End Sub

' =====================================================
' FUNCTION : Analyser une collection pour la continuité
' =====================================================
Function AnalyserCollectionContinuite(coll As Collection) As String
    If coll.Count = 0 Then
        AnalyserCollectionContinuite = "Aucun numéro"
        Exit Function
    End If
    
    ' Extraire les numéros de base
    Dim arr() As Long
    ReDim arr(coll.Count - 1)
    Dim i As Long
    
    For i = 1 To coll.Count
        arr(i - 1) = coll(i)("numeroBase")
    Next i
    
    ' Trier
    Call TrierTableau(arr)
    
    Dim msg As String
    Dim minNum As Long, maxNum As Long
    minNum = arr(0)
    maxNum = arr(UBound(arr))
    
    msg = "Numéros présents : "
    For i = 0 To UBound(arr)
        If i > 0 Then msg = msg & ", "
        msg = msg & arr(i)
    Next i
    msg = msg & vbCrLf
    
    msg = msg & "Plage : " & minNum & " à " & maxNum & vbCrLf
    
    ' Identifier les numéros manquants de même parité
    Dim manquants As String
    manquants = ""
    Dim parite As Integer
    parite = minNum Mod 2
    
    Dim presentDict As Object
    Set presentDict = CreateObject("Scripting.Dictionary")
    For i = 0 To UBound(arr)
        presentDict(arr(i)) = True
    Next i
    
    Dim num As Long
    For num = minNum To maxNum
        If num Mod 2 = parite And Not presentDict.Exists(num) Then
            If manquants <> "" Then manquants = manquants & ", "
            manquants = manquants & num
        End If
    Next num
    
    If manquants = "" Then
        msg = msg & "Aucun numéro manquant → Borne continue possible : " & minNum & " à " & maxNum
    Else
        msg = msg & "Numéros manquants : " & manquants & vbCrLf
        msg = msg & "→ Borne continue SI ces numéros ne sont pas ailleurs"
    End If
    
    AnalyserCollectionContinuite = msg
End Function
