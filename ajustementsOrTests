' =====================================================
' SUB : Simplification des bornes de numéros PDI - VERSION AVEC EXTENSIONS
' =====================================================
Sub SimplificationBornesNumPDI()
    Dim ws As Worksheet
    Dim wsFacade As Worksheet
    Dim lastRow As Long
    Dim lastCol As Long
    Dim dataParCellule As Object
    Dim i As Long, j As Long
    Dim nbModifiees As Long
    
    ' Vérifier qu'on est sur la bonne feuille
    Set ws = ActiveSheet
    If ws.Name <> "Facade_PDI" Then
        MsgBox "Veuillez activer la feuille 'Facade_PDI' avant d'exécuter cette macro.", vbExclamation
        Exit Sub
    End If
    
    Set wsFacade = ws
    
    ' Trouver les limites de la feuille
    lastRow = wsFacade.Cells(wsFacade.Rows.Count, 1).End(xlUp).Row
    lastCol = 26 ' Colonnes A à Z
    
    ' Dictionnaire pour indexer les données par cellule et voie
    Set dataParCellule = CreateObject("Scripting.Dictionary")
    
    Application.ScreenUpdating = False
    
    ' === PASSAGE 1 : INDEXER TOUS LES NUMÉROS PAR CELLULE ET VOIE ===
    For i = 1 To lastRow Step 2 ' Traiter seulement les lignes impaires (numéros PDI)
        For j = 1 To lastCol
            Dim celluleNum As Range
            Set celluleNum = wsFacade.Cells(i, j)
            
            ' Vérifier si la cellule contient des numéros PDI
            Dim valeurNum As String
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                ' Obtenir le libellé de voie correspondant (ligne du dessous)
                Dim voie As String
                voie = ObtenirLibelleVoiePDI(wsFacade, i, j)
                
                If voie <> "" Then
                    Dim adresse As String
                    adresse = celluleNum.Address
                    
                    ' Créer la structure de données si nécessaire
                    If Not dataParCellule.Exists(voie) Then
                        dataParCellule.Add voie, CreateObject("Scripting.Dictionary")
                    End If
                    
                    If Not dataParCellule(voie).Exists(adresse) Then
                        Dim pairImp As Object
                        Set pairImp = CreateObject("Scripting.Dictionary")
                        pairImp.Add "pairs", New Collection
                        pairImp.Add "impairs", New Collection
                        dataParCellule(voie).Add adresse, pairImp
                    End If
                    
                    ' Extraire les numéros pairs et impairs AVEC EXTENSIONS
                    Dim collPairs As Collection
                    Dim collImpairs As Collection
                    Set collPairs = New Collection
                    Set collImpairs = New Collection
                    
                    Call ExtraireNumerosAvecExtensions(valeurNum, collPairs, collImpairs)
                    
                    ' Ajouter aux collections
                    Dim numeroObj As Object
                    For Each numeroObj In collPairs
                        dataParCellule(voie)(adresse)("pairs").Add numeroObj
                    Next
                    For Each numeroObj In collImpairs
                        dataParCellule(voie)(adresse)("impairs").Add numeroObj
                    Next
                End If
            End If
        Next j
    Next i
    
    ' === PASSAGE 2 : TRAITEMENT ET GÉNÉRATION DES BORNES ===
    nbModifiees = 0
    
    For i = 1 To lastRow Step 2
        For j = 1 To lastCol
            Set celluleNum = wsFacade.Cells(i, j)
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                voie = ObtenirLibelleVoiePDI(wsFacade, i, j)
                adresse = celluleNum.Address
                
                If voie <> "" And dataParCellule.Exists(voie) And dataParCellule(voie).Exists(adresse) Then
                    Set collPairs = dataParCellule(voie)(adresse)("pairs")
                    Set collImpairs = dataParCellule(voie)(adresse)("impairs")
                    
                    ' Récupérer les numéros utilisés dans d'autres cellules de la même voie
                    Dim autresP As Object
                    Dim autresI As Object
                    Set autresP = CreateObject("Scripting.Dictionary")
                    Set autresI = CreateObject("Scripting.Dictionary")
                    
                    Dim otherAdr As Variant
                    For Each otherAdr In dataParCellule(voie).Keys
                        If otherAdr <> adresse Then
                            For Each numeroObj In dataParCellule(voie)(otherAdr)("pairs")
                                autresP(numeroObj("numeroBase")) = True
                            Next
                            For Each numeroObj In dataParCellule(voie)(otherAdr)("impairs")
                                autresI(numeroObj("numeroBase")) = True
                            Next
                        End If
                    Next
                    
                    ' Générer le nouveau texte avec bornes
                    Dim nouveauTexte As String
                    nouveauTexte = GenererTexteBornesAvecExtensions(collPairs, collImpairs, autresP, autresI, valeurNum)
                    
                    If nouveauTexte <> "" And nouveauTexte <> celluleNum.Value Then
                        ' Conserver le formatage existant
                        Dim formatOriginal As Variant
                        Dim couleurFond As Long
                        Dim couleurTexte As Long
                        Dim estGras As Boolean
                        
                        formatOriginal = celluleNum.NumberFormat
                        couleurFond = celluleNum.Interior.Color
                        couleurTexte = celluleNum.Font.Color
                        estGras = celluleNum.Font.Bold
                        
                        ' Mettre à jour la valeur
                        celluleNum.Value = nouveauTexte
                        
                        ' Restaurer le formatage
                        celluleNum.NumberFormat = formatOriginal
                        celluleNum.Interior.Color = couleurFond
                        celluleNum.Font.Color = couleurTexte
                        celluleNum.Font.Bold = estGras
                        
                        ' Réappliquer le formatage différencié si nécessaire
                        Call AppliquerFormatageDifferencieBornes(celluleNum, nouveauTexte)
                        
                        nbModifiees = nbModifiees + 1
                    End If
                End If
            End If
        Next j
    Next i
    
    Application.ScreenUpdating = True
    
    ' Message de confirmation
    MsgBox "Simplification des bornes terminée (avec gestion des extensions)." & vbCrLf & _
           "Nombre de cellules modifiées : " & nbModifiees, _
           vbInformation, "Bornes PDI"
End Sub

' =====================================================
' SUB : Extraire les numéros avec extensions - NOUVELLE VERSION
' =====================================================
Sub ExtraireNumerosAvecExtensions(valeur As String, ByRef numsP As Collection, ByRef numsI As Collection)
    On Error Resume Next
    
    ' Expression régulière pour capturer numéros avec extensions optionnelles
    ' Capture : [nombre][espace optionnel][extension optionnelle]
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.pattern = "\b(\d+)\s*([a-zA-Z]*|bis|ter|quater)?\b"
    reg.Global = True
    reg.IgnoreCase = True
    
    Dim matches As Object
    Set matches = reg.Execute(valeur)
    
    Dim i As Long
    Dim numeroBase As Long
    Dim extension As String
    Dim numeroObj As Object
    
    For i = 0 To matches.Count - 1
        numeroBase = CLng(matches(i).SubMatches(0))
        extension = Trim(matches(i).SubMatches(1))
        
        If Err.Number = 0 And numeroBase > 0 Then
            ' Créer un objet représentant le numéro avec extension
            Set numeroObj = CreerObjetNumero(numeroBase, extension, matches(i).Value)
            
            ' Classifier selon la parité du numéro de base
            If numeroBase Mod 2 = 0 Then
                numsP.Add numeroObj
            Else
                numsI.Add numeroObj
            End If
        End If
        Err.Clear
    Next i
    
    On Error GoTo 0
End Sub

' =====================================================
' FUNCTION : Créer un objet représentant un numéro avec extension
' =====================================================
Function CreerObjetNumero(numeroBase As Long, extension As String, texteOriginal As String) As Object
    Dim obj As Object
    Set obj = CreateObject("Scripting.Dictionary")
    
    obj.Add "numeroBase", numeroBase
    obj.Add "extension", NormaliserExtension(extension)
    obj.Add "texteOriginal", Trim(texteOriginal)
    obj.Add "cleUnique", numeroBase & "|" & NormaliserExtension(extension)
    
    Set CreerObjetNumero = obj
End Function

' =====================================================
' FUNCTION : Normaliser les extensions
' =====================================================
Function NormaliserExtension(ext As String) As String
    Dim extClean As String
    extClean = UCase(Trim(ext))
    
    Select Case extClean
        Case "BIS"
            NormaliserExtension = "BIS"
        Case "TER"
            NormaliserExtension = "TER"
        Case "QUATER"
            NormaliserExtension = "QUATER"
        Case ""
            NormaliserExtension = ""
        Case Else
            ' Pour a, b, c, etc.
            If Len(extClean) = 1 And extClean >= "A" And extClean <= "Z" Then
                NormaliserExtension = extClean
            Else
                NormaliserExtension = extClean
            End If
    End Select
End Function

' =====================================================
' FUNCTION : Générer le texte avec bornes AVEC EXTENSIONS
' =====================================================
Function GenererTexteBornesAvecExtensions(collPairs As Collection, collImpairs As Collection, _
                                        autresP As Object, autresI As Object, texteOriginal As String) As String
    
    Dim res As String
    res = ""
    
    ' Détecter et conserver le début du texte original (symboles)
    Dim debutTexte As String
    debutTexte = ExtraireDebutSymbole(texteOriginal)
    
    ' Traiter les numéros pairs
    If collPairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesAvecExtensions(collPairs, autresP)
        If resPairs <> "" Then res = resPairs
    End If
    
    ' Traiter les numéros impairs
    If collImpairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesAvecExtensions(collImpairs, autresI)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    ' Conserver les observations si elles étaient présentes
    Dim observations As String
    observations = ExtraireObservations(texteOriginal)
    
    ' Construire le résultat final
    If res <> "" Then
        If observations <> "" Then
            GenererTexteBornesAvecExtensions = debutTexte & res & vbCrLf & observations
        Else
            GenererTexteBornesAvecExtensions = debutTexte & res
        End If
    Else
        GenererTexteBornesAvecExtensions = texteOriginal
    End If
End Function

' =====================================================
' FUNCTION : Générer bornes avec extensions
' =====================================================
Function GenererBornesAvecExtensions(coll As Collection, exclus As Object) As String
    ' Étape 1 : Regrouper par numéro de base
    Dim groupes As Object
    Set groupes = CreateObject("Scripting.Dictionary")
    
    Dim numeroObj As Object
    Dim numeroBase As String
    
    For Each numeroObj In coll
        numeroBase = CStr(numeroObj("numeroBase"))
        
        If Not groupes.Exists(numeroBase) Then
            groupes.Add numeroBase, New Collection
        End If
        
        groupes(numeroBase).Add numeroObj
    Next
    
    ' Étape 2 : Déterminer l'affichage pour chaque groupe
    Dim affichageParBase As Object
    Set affichageParBase = CreateObject("Scripting.Dictionary")
    
    Dim cle As Variant
    Dim groupe As Collection
    
    For Each cle In groupes.Keys
        Set groupe = groupes(cle)
        affichageParBase.Add cle, DeterminerAffichageGroupe(groupe)
    Next
    
    ' Étape 3 : Convertir en tableau et trier par numéro de base
    Dim arr() As Long
    ReDim arr(groupes.Count - 1)
    Dim i As Long
    i = 0
    
    For Each cle In groupes.Keys
        arr(i) = CLng(cle)
        i = i + 1
    Next
    
    ' Tri des numéros de base
    Call TrierTableau(arr)
    
    ' Étape 4 : Créer les plages en tenant compte des exclusions
    Dim plages As New Collection
    Dim debut As Long, fin As Long
    debut = arr(0)
    fin = arr(0)
    
    For i = 1 To UBound(arr)
        Dim actuel As Long
        actuel = arr(i)
        
        ' Vérifier s'il y a des exclusions entre fin et actuel
        Dim ok As Boolean
        ok = True
        
        Dim k As Long
        For k = fin + 1 To actuel - 1
            If exclus.Exists(k) Then
                ok = False
                Exit For
            End If
        Next k
        
        If ok And (actuel = fin + 1) Then
            ' Continuité : étendre la plage
            fin = actuel
        Else
            ' Rupture : terminer la plage actuelle
            If debut = fin Then
                plages.Add affichageParBase(CStr(debut))
            Else
                plages.Add affichageParBase(CStr(debut)) & " à " & affichageParBase(CStr(fin))
            End If
            debut = actuel
            fin = actuel
        End If
    Next i
    
    ' Ajouter la dernière plage
    If debut = fin Then
        plages.Add affichageParBase(CStr(debut))
    Else
        plages.Add affichageParBase(CStr(debut)) & " à " & affichageParBase(CStr(fin))
    End If
    
    ' Étape 5 : Construire le résultat
    Dim res As String
    res = ""
    For i = 1 To plages.Count
        If i > 1 Then res = res & ", "
        res = res & plages(i)
    Next i
    
    GenererBornesAvecExtensions = res
End Function

' =====================================================
' FUNCTION : Déterminer l'affichage optimal pour un groupe
' =====================================================
Function DeterminerAffichageGroupe(groupe As Collection) As String
    ' Si le groupe ne contient qu'un élément, utiliser son texte original
    If groupe.Count = 1 Then
        DeterminerAffichageGroupe = groupe(1)("texteOriginal")
        Exit Function
    End If
    
    ' Si le groupe contient plusieurs éléments, analyser
    Dim aUneSansExtension As Boolean
    Dim numeroBase As String
    aUneSansExtension = False
    numeroBase = ""
    
    Dim numeroObj As Object
    For Each numeroObj In groupe
        If numeroBase = "" Then numeroBase = CStr(numeroObj("numeroBase"))
        
        If numeroObj("extension") = "" Then
            aUneSansExtension = True
            Exit For
        End If
    Next
    
    ' Si on a le numéro de base sans extension parmi les éléments,
    ' utiliser le numéro de base seul
    If aUneSansExtension Then
        DeterminerAffichageGroupe = numeroBase
    Else
        ' Sinon, utiliser la première extension trouvée (arbitraire)
        DeterminerAffichageGroupe = groupe(1)("texteOriginal")
    End If
End Function

' =====================================================
' FUNCTION : Extraire le début symbolique du texte
' =====================================================
Function ExtraireDebutSymbole(texte As String) As String
    Dim i As Integer
    For i = 1 To Len(texte)
        If IsNumeric(Mid(texte, i, 1)) Then
            ExtraireDebutSymbole = Left(texte, i - 1)
            Exit Function
        End If
    Next i
    ExtraireDebutSymbole = ""
End Function

' =====================================================
' SUB : Trier un tableau d'entiers longs
' =====================================================
Sub TrierTableau(arr() As Long)
    Dim i As Long, j As Long, temp As Long
    For i = LBound(arr) To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
End Sub

' =====================================================
' MACRO DE TEST : Tester avec des numéros complexes
' =====================================================
Sub TesterNumerosAvecExtensions()
    ' Test avec différents formats
    Dim tests As Variant
    tests = Array("1,3,5,5a,5b,13,15", "7bis", "2,4,6a,6b,6,8", "1ter,3bis,5a,7")
    
    Dim i As Integer
    Dim msg As String
    msg = "TESTS DES NUMÉROS AVEC EXTENSIONS" & vbCrLf & vbCrLf
    
    For i = 0 To UBound(tests)
        Dim collP As New Collection
        Dim collI As New Collection
        
        Call ExtraireNumerosAvecExtensions(tests(i), collP, collI)
        
        msg = msg & "Test " & (i + 1) & " : " & tests(i) & vbCrLf
        msg = msg & "Pairs : " & collP.Count & " éléments" & vbCrLf
        msg = msg & "Impairs : " & collI.Count & " éléments" & vbCrLf & vbCrLf
    Next i
    
    MsgBox msg, vbInformation, "Tests Extensions"
End Sub
