' =====================================================
' FONCTIONS UTILITAIRES NÉCESSAIRES
' =====================================================

' Fonction pour vérifier si une valeur contient seulement des symboles
Function EstUnSymbole(valeur As String) As Boolean
    On Error Resume Next
    EstUnSymbole = False
    
    ' Si la valeur est vide, ce n'est pas un symbole
    If Len(Trim(valeur)) = 0 Then Exit Function
    
    ' Test simple : si la valeur ne contient aucun chiffre, c'est probablement un symbole
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.pattern = "\d"
    reg.Global = True
    
    ' Si pas de chiffres trouvés, c'est un symbole
    If Not reg.Test(valeur) Then
        EstUnSymbole = True
    End If
    
    On Error GoTo 0
End Function

' Fonction pour extraire le symbole en début de chaîne
Function ExtraireSymboleDebut(texte As String) As String
    Dim premier As String
    
    If Len(texte) = 0 Then
        ExtraireSymboleDebut = ""
        Exit Function
    End If
    
    premier = Left(texte, 1)
    
    ' Vérifier si c'est un symbole Unicode
    If premier = ChrW(&H25B2) Or premier = ChrW(&H25A0) Or premier = ChrW(&H25CB) Then
        ' Inclure l'espace qui suit si présent
        If Len(texte) > 1 And Mid(texte, 2, 1) = " " Then
            ExtraireSymboleDebut = Left(texte, 2)
        Else
            ExtraireSymboleDebut = premier
        End If
    Else
        ExtraireSymboleDebut = ""
    End If
End Function

' Fonction pour enlever le symbole en début de chaîne
Function EnleverSymboleDebut(texte As String) As String
    Dim symbole As String
    symbole = ExtraireSymboleDebut(texte)
    
    If symbole <> "" Then
        EnleverSymboleDebut = Trim(Mid(texte, Len(symbole) + 1))
    Else
        EnleverSymboleDebut = texte
    End If
End Function

' Fonction pour extraire les observations d'un texte PDI
Function ExtraireObservations(texte As String) As String
    Dim lignes As Variant
    
    ' Si il y a un saut de ligne, la deuxième partie sont les observations
    If InStr(texte, vbCrLf) > 0 Then
        lignes = Split(texte, vbCrLf)
        If UBound(lignes) > 0 Then
            ExtraireObservations = Trim(lignes(1))
        Else
            ExtraireObservations = ""
        End If
    Else
        ExtraireObservations = ""
    End If
End Function

' Fonction pour obtenir le libellé de voie pour une cellule PDI
Function ObtenirLibelleVoiePDI(ws As Worksheet, ligneNum As Long, colonne As Long) As String
    Dim ligneVoie As Long
    Dim valVoie As String
    
    ligneVoie = ligneNum + 1 ' La ligne de voie est juste en dessous
    
    ' Vérifier que la ligne de voie existe
    If ligneVoie > ws.Rows.Count Then
        ObtenirLibelleVoiePDI = ""
        Exit Function
    End If
    
    ' Récupérer la valeur de la cellule de voie
    valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne).Value))
    
    ' Si la cellule de voie n'est pas vide, la retourner
    If valVoie <> "" Then
        ' Nettoyer le libellé (enlever le cercle blanc si présent)
        If Left(valVoie, 1) = ChrW(&H25CB) Then ' Cercle blanc
            valVoie = Trim(Mid(valVoie, 3)) ' Enlever le cercle et l'espace
        End If
        ObtenirLibelleVoiePDI = valVoie
        Exit Function
    End If
    
    ' Si la cellule est fusionnée, récupérer la valeur de la première cellule
    If ws.Cells(ligneVoie, colonne).MergeCells Then
        valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne).MergeArea.Cells(1, 1).Value))
        If Left(valVoie, 1) = ChrW(&H25CB) Then
            valVoie = Trim(Mid(valVoie, 3))
        End If
        ObtenirLibelleVoiePDI = valVoie
        Exit Function
    End If
    
    ' Sinon, chercher dans les cellules adjacentes
    Dim offset As Long
    For offset = 1 To 5
        ' Chercher à gauche
        If colonne - offset > 0 Then
            valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne - offset).Value))
            If valVoie <> "" Then
                If Left(valVoie, 1) = ChrW(&H25CB) Then
                    valVoie = Trim(Mid(valVoie, 3))
                End If
                ObtenirLibelleVoiePDI = valVoie
                Exit Function
            End If
        End If
        
        ' Chercher à droite
        If colonne + offset <= ws.Columns.Count Then
            valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne + offset).Value))
            If valVoie <> "" Then
                If Left(valVoie, 1) = ChrW(&H25CB) Then
                    valVoie = Trim(Mid(valVoie, 3))
                End If
                ObtenirLibelleVoiePDI = valVoie
                Exit Function
            End If
        End If
    Next offset
    
    ObtenirLibelleVoiePDI = ""
End Function

' Fonction pour extraire les numéros pairs et impairs
Sub ExtraireNumerosPDI(valeur As String, ByRef numsP As Collection, ByRef numsI As Collection)
    On Error Resume Next
    
    ' Utiliser seulement l'expression régulière pour extraire les numéros
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.pattern = "\d+"
    reg.Global = True
    
    Dim matches As Object
    Set matches = reg.Execute(valeur)
    
    Dim i As Long
    Dim n As Long
    
    For i = 0 To matches.Count - 1
        n = CLng(matches(i).Value)
        If Err.Number = 0 And n > 0 Then
            If n Mod 2 = 0 Then
                numsP.Add n
            Else
                numsI.Add n
            End If
        End If
        Err.Clear
    Next i
    
    On Error GoTo 0
End Sub

' Fonction pour appliquer le formatage différencié (version simplifiée)
Sub AppliquerFormatageDifferencieBornes(rng As Range, contenu As String)
    ' Réappliquer le formatage de base
    On Error Resume Next
    With rng
        .Font.Bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    On Error GoTo 0
End Sub

' =====================================================
' SUB : Simplification des bornes avec regroupement par voies (VERSION MULTIVOIES AVEC EXCLUSIONS)
' =====================================================
Sub SimplificationBornesNumPDIMultivoies()
    Dim ws As Worksheet
    Dim wsFacade As Worksheet
    Dim lastRow As Long
    Dim lastCol As Long
    Dim nbModifiees As Long
    Dim dataParCellule As Object
    
    ' Vérifier qu'on est sur la bonne feuille
    Set ws = ActiveSheet
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Veuillez activer une feuille façade avant d'exécuter cette macro.", vbExclamation
        Exit Sub
    End If
    
    Set wsFacade = ws
    
    ' Trouver les limites de la feuille
    lastRow = wsFacade.Cells(wsFacade.Rows.Count, 1).End(xlUp).Row
    lastCol = 26 ' Colonnes A à Z
    
    ' ÉTAPE 1 : INDEXER TOUS LES NUMÉROS PAR VOIE DANS TOUTE LA FAÇADE
    Set dataParCellule = CreateObject("Scripting.Dictionary")
    Call IndexerTousLesNumerosFacade(wsFacade, lastRow, lastCol, dataParCellule)
    
    Application.ScreenUpdating = False
    nbModifiees = 0
    
    ' ÉTAPE 2 : TRAITER CHAQUE CELLULE AVEC VÉRIFICATION DES EXCLUSIONS
    Dim i As Long, j As Long
    For i = 1 To lastRow Step 2 ' Lignes impaires (numéros PDI)
        For j = 1 To lastCol
            Dim celluleNum As Range
            Set celluleNum = wsFacade.Cells(i, j)
            
            ' Vérifier si la cellule contient des numéros
            Dim valeurNum As String
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                ' Obtenir les libellés de voies correspondants
                Dim voies As String
                voies = ObtenirLibelleVoiePDI(wsFacade, i, j)
                
                If voies <> "" Then
                    ' Traiter la case multivoie avec exclusions
                    Dim nouveauTexte As String
                    nouveauTexte = TraiterCaseMultivoiesAvecExclusions(valeurNum, voies, dataParCellule, celluleNum.Address)
                    
                    If nouveauTexte <> "" And nouveauTexte <> celluleNum.Value Then
                        ' Conserver le formatage existant
                        Dim formatOriginal As Variant
                        Dim couleurFond As Long
                        Dim couleurTexte As Long
                        Dim estGras As Boolean
                        
                        formatOriginal = celluleNum.NumberFormat
                        couleurFond = celluleNum.Interior.Color
                        couleurTexte = celluleNum.Font.Color
                        estGras = celluleNum.Font.Bold
                        
                        ' Mettre à jour la valeur
                        celluleNum.Value = nouveauTexte
                        
                        ' Restaurer le formatage
                        celluleNum.NumberFormat = formatOriginal
                        celluleNum.Interior.Color = couleurFond
                        celluleNum.Font.Color = couleurTexte
                        celluleNum.Font.Bold = estGras
                        
                        ' Réappliquer le formatage différencié
                        Call AppliquerFormatageDifferencieBornes(celluleNum, nouveauTexte)
                        
                        nbModifiees = nbModifiees + 1
                    End If
                End If
            End If
        Next j
    Next i
    
    Application.ScreenUpdating = True
    
    ' Message de confirmation
    MsgBox "Simplification des bornes multivoies terminée." & vbCrLf & _
           "Nombre de cellules modifiées : " & nbModifiees & vbCrLf & _
           "Exclusions appliquées selon l'usage dans la façade.", _
           vbInformation, "Bornes Multivoies avec Exclusions"
End Sub

' =====================================================
' SUB : Indexer tous les numéros de la façade par voie
' =====================================================
Sub IndexerTousLesNumerosFacade(ws As Worksheet, lastRow As Long, lastCol As Long, dataParCellule As Object)
    Dim i As Long, j As Long
    
    For i = 1 To lastRow Step 2 ' Lignes impaires (numéros PDI)
        For j = 1 To lastCol
            Dim celluleNum As Range
            Set celluleNum = ws.Cells(i, j)
            
            Dim valeurNum As String
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                Dim voie As String
                voie = ObtenirLibelleVoiePDI(ws, i, j)
                
                If voie <> "" Then
                    Dim adresse As String
                    adresse = celluleNum.Address
                    
                    ' Créer la structure de données si nécessaire
                    If Not dataParCellule.Exists(voie) Then
                        dataParCellule.Add voie, CreateObject("Scripting.Dictionary")
                    End If
                    
                    If Not dataParCellule(voie).Exists(adresse) Then
                        Dim pairImp As Object
                        Set pairImp = CreateObject("Scripting.Dictionary")
                        pairImp.Add "pairs", New Collection
                        pairImp.Add "impairs", New Collection
                        dataParCellule(voie).Add adresse, pairImp
                    End If
                    
                    ' Extraire les numéros pairs et impairs
                    Dim collPairs As Collection
                    Dim collImpairs As Collection
                    Set collPairs = New Collection
                    Set collImpairs = New Collection
                    
                    Call ExtraireNumerosPDI(valeurNum, collPairs, collImpairs)
                    
                    ' Ajouter aux collections (avec suppression des doublons)
                    Dim dictPairsUniques As Object
                    Dim dictImpairsUniques As Object
                    Set dictPairsUniques = CreateObject("Scripting.Dictionary")
                    Set dictImpairsUniques = CreateObject("Scripting.Dictionary")
                    
                    Dim num As Variant
                    For Each num In collPairs
                        If Not dictPairsUniques.Exists(num) Then
                            dictPairsUniques.Add num, True
                            dataParCellule(voie)(adresse)("pairs").Add num
                        End If
                    Next
                    For Each num In collImpairs
                        If Not dictImpairsUniques.Exists(num) Then
                            dictImpairsUniques.Add num, True
                            dataParCellule(voie)(adresse)("impairs").Add num
                        End If
                    Next
                End If
            End If
        Next j
    Next i
End Sub

' =====================================================
' FUNCTION : Traiter une case multivoies avec exclusions
' =====================================================
Function TraiterCaseMultivoiesAvecExclusions(numerosTexte As String, voiesTexte As String, dataParCellule As Object, adresseCellule As String) As String
    ' Extraire le symbole de début et les observations
    Dim symbole As String
    Dim observations As String
    symbole = ExtraireSymboleDebut(numerosTexte)
    observations = ExtraireObservations(numerosTexte)
    
    ' Nettoyer le texte des numéros
    Dim numerosSeuls As String
    numerosSeuls = EnleverSymboleDebut(numerosTexte)
    If InStr(numerosSeuls, vbCrLf) > 0 Then
        numerosSeuls = Split(numerosSeuls, vbCrLf)(0)
    End If
    
    ' Séparer les voies
    Dim voiesArray As Variant
    If InStr(voiesTexte, " / ") > 0 Then
        voiesArray = Split(voiesTexte, " / ")
    Else
        ReDim voiesArray(0)
        voiesArray(0) = voiesTexte
    End If
    
    ' Si une seule voie, traitement avec exclusions
    If UBound(voiesArray) = 0 Then
        Dim voieUnique As String
        voieUnique = Trim(voiesArray(0))
        Dim res As String
        res = TraiterVoieAvecExclusions(numerosSeuls, voieUnique, dataParCellule, adresseCellule)
        If observations <> "" Then
            res = res & vbCrLf & observations
        End If
        TraiterCaseMultivoiesAvecExclusions = symbole & res
        Exit Function
    End If
    
    ' Cas multivoies : traiter chaque voie avec ses exclusions
    Dim resultatsVoies As Collection
    Set resultatsVoies = New Collection
    
    Dim indexVoie As Integer
    For indexVoie = 0 To UBound(voiesArray)
        Dim voieActuelle As String
        voieActuelle = Trim(voiesArray(indexVoie))
        
        ' Extraire les numéros correspondant à cette voie
        Dim numerosVoie As Collection
        Set numerosVoie = ExtraireNumerosParVoie(numerosSeuls, indexVoie, UBound(voiesArray) + 1)
        
        ' Construire la chaîne des numéros pour cette voie
        Dim chaineVoie As String
        chaineVoie = ""
        Dim k As Integer
        For k = 1 To numerosVoie.Count
            If k > 1 Then chaineVoie = chaineVoie & "-"
            chaineVoie = chaineVoie & numerosVoie(k)
        Next k
        
        ' Générer les bornes pour cette voie avec exclusions
        Dim bornesVoie As String
        bornesVoie = TraiterVoieAvecExclusions(chaineVoie, voieActuelle, dataParCellule, adresseCellule)
        
        If bornesVoie <> "" Then
            resultatsVoies.Add "[" & bornesVoie & "]"
        End If
    Next indexVoie
    
    ' Construire le résultat final
    Dim resultatFinal As String
    resultatFinal = ""
    
    Dim i As Integer
    For i = 1 To resultatsVoies.Count
        If i > 1 Then resultatFinal = resultatFinal & " "
        resultatFinal = resultatFinal & resultatsVoies(i)
    Next i
    
    ' Ajouter les observations si présentes
    If observations <> "" Then
        resultatFinal = resultatFinal & vbCrLf & observations
    End If
    
    TraiterCaseMultivoiesAvecExclusions = symbole & resultatFinal
End Function

' =====================================================
' FUNCTION : Traiter une voie avec exclusions
' =====================================================
Function TraiterVoieAvecExclusions(numerosTexte As String, nomVoie As String, dataParCellule As Object, adresseCellule As String) As String
    Dim collPairs As New Collection
    Dim collImpairs As New Collection
    
    ' Extraire les numéros pairs et impairs
    Call ExtraireNumerosPDI(numerosTexte, collPairs, collImpairs)
    
    ' Récupérer les numéros utilisés dans d'autres cellules de la même voie
    Dim autresP As Object
    Dim autresI As Object
    Set autresP = CreateObject("Scripting.Dictionary")
    Set autresI = CreateObject("Scripting.Dictionary")
    
    If dataParCellule.Exists(nomVoie) Then
        Dim otherAdr As Variant
        For Each otherAdr In dataParCellule(nomVoie).Keys
            If otherAdr <> adresseCellule Then
                Dim num As Variant
                For Each num In dataParCellule(nomVoie)(otherAdr)("pairs")
                    autresP(num) = True
                Next
                For Each num In dataParCellule(nomVoie)(otherAdr)("impairs")
                    autresI(num) = True
                Next
            End If
        Next
    End If
    
    ' Générer les bornes avec exclusions
    Dim res As String
    res = ""
    
    If collPairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesAvecExclusions(collPairs, autresP, True)
        If resPairs <> "" Then res = resPairs
    End If
    
    If collImpairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesAvecExclusions(collImpairs, autresI, False)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    TraiterVoieAvecExclusions = res
End Function

' =====================================================
' FUNCTION : Générer des bornes avec exclusions (LOGIQUE CRUCIALE RESTAURÉE)
' =====================================================
Function GenererBornesAvecExclusions(coll As Collection, exclus As Object, estPair As Boolean) As String
    ' Éliminer les doublons
    Dim dictUniques As Object
    Set dictUniques = CreateObject("Scripting.Dictionary")
    
    Dim i As Long
    For i = 1 To coll.Count
        Dim numero As Long
        numero = coll(i)
        If Not dictUniques.Exists(numero) Then
            dictUniques.Add numero, True
        End If
    Next i
    
    ' Convertir en tableau et trier
    Dim arr() As Long
    ReDim arr(dictUniques.Count - 1)
    i = 0
    Dim k As Variant
    For Each k In dictUniques.Keys
        arr(i) = CLng(k)
        i = i + 1
    Next
    
    ' Tri simple
    Dim j As Long, temp As Long
    For i = 0 To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
    
    ' Créer les plages en vérifiant les exclusions
    Dim plages As New Collection
    Dim debut As Long, fin As Long
    debut = arr(0)
    fin = arr(0)
    
    For i = 1 To UBound(arr)
        Dim actuel As Long
        actuel = arr(i)
        
        ' Vérifier s'il y a des exclusions entre fin et actuel
        Dim ok As Boolean
        ok = True
        
        ' LOGIQUE CRUCIALE : vérifier les numéros intermédiaires de même parité
        Dim numeroTest As Long
        For numeroTest = fin + 2 To actuel - 2 Step 2 ' +2/-2 pour rester dans la même parité
            If exclus.Exists(numeroTest) Then
                ok = False
                Exit For
            End If
        Next numeroTest
        
        If ok And actuel = fin + 2 Then
            ' Numéros consécutifs de même parité ET pas d'exclusions
            fin = actuel
        ElseIf ok And actuel > fin + 2 Then
            ' Gap mais pas d'exclusions intermédiaires -> on peut faire une borne continue
            fin = actuel
        Else
            ' Terminer la plage actuelle
            If debut = fin Then
                plages.Add CStr(debut)
            Else
                plages.Add debut & " à " & fin
            End If
            debut = actuel
            fin = actuel
        End If
    Next i
    
    ' Ajouter la dernière plage
    If debut = fin Then
        plages.Add CStr(debut)
    Else
        plages.Add debut & " à " & fin
    End If
    
    ' Construire le résultat
    Dim res As String
    res = ""
    For i = 1 To plages.Count
        If i > 1 Then res = res & ", "
        res = res & plages(i)
    Next i
    
    GenererBornesAvecExclusions = res
End Function

' =====================================================
' FUNCTION : Traiter une case multivoies
' =====================================================
Function TraiterCaseMultivoies(numerosTexte As String, voiesTexte As String) As String
    ' Extraire le symbole de début et les observations
    Dim symbole As String
    Dim observations As String
    symbole = ExtraireSymboleDebut(numerosTexte)
    observations = ExtraireObservations(numerosTexte)
    
    ' Nettoyer le texte des numéros (enlever symbole et observations)
    Dim numerosSeuls As String
    numerosSeuls = EnleverSymboleDebut(numerosTexte)
    If InStr(numerosSeuls, vbCrLf) > 0 Then
        numerosSeuls = Split(numerosSeuls, vbCrLf)(0)
    End If
    
    ' Séparer les voies
    Dim voiesArray As Variant
    If InStr(voiesTexte, " / ") > 0 Then
        voiesArray = Split(voiesTexte, " / ")
    Else
        ReDim voiesArray(0)
        voiesArray(0) = voiesTexte
    End If
    
    ' Si une seule voie, traitement normal
    If UBound(voiesArray) = 0 Then
        Dim res As String
        res = TraiterVoieSimple(numerosSeuls)
        If observations <> "" Then
            res = res & vbCrLf & observations
        End If
        TraiterCaseMultivoies = symbole & res
        Exit Function
    End If
    
    ' Cas multivoies : extraire les numéros par voie
    Dim resultatsVoies As Collection
    Set resultatsVoies = New Collection
    
    Dim indexVoie As Integer
    For indexVoie = 0 To UBound(voiesArray)
        Dim voieActuelle As String
        voieActuelle = Trim(voiesArray(indexVoie))
        
        ' Extraire les numéros correspondant à cette voie
        Dim numerosVoie As Collection
        Set numerosVoie = ExtraireNumerosParVoie(numerosSeuls, indexVoie, UBound(voiesArray) + 1)
        
        ' Générer les bornes pour cette voie
        Dim bornesVoie As String
        bornesVoie = GenererBornesVoieUnique(numerosVoie)
        
        If bornesVoie <> "" Then
            resultatsVoies.Add "[" & bornesVoie & "]"
        End If
    Next indexVoie
    
    ' Construire le résultat final
    Dim resultatFinal As String
    resultatFinal = ""
    
    Dim i As Integer
    For i = 1 To resultatsVoies.Count
        If i > 1 Then resultatFinal = resultatFinal & " "
        resultatFinal = resultatFinal & resultatsVoies(i)
    Next i
    
    ' Ajouter les observations si présentes
    If observations <> "" Then
        resultatFinal = resultatFinal & vbCrLf & observations
    End If
    
    TraiterCaseMultivoies = symbole & resultatFinal
End Function

' =====================================================
' FUNCTION : Traiter une voie simple (sans crochets)
' =====================================================
Function TraiterVoieSimple(numerosTexte As String) As String
    Dim collPairs As New Collection
    Dim collImpairs As New Collection
    
    ' Extraire les numéros pairs et impairs
    Call ExtraireNumerosPDI(numerosTexte, collPairs, collImpairs)
    
    ' Générer les bornes
    Dim res As String
    res = ""
    
    If collPairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesSimples(collPairs)
        If resPairs <> "" Then res = resPairs
    End If
    
    If collImpairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesSimples(collImpairs)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    TraiterVoieSimple = res
End Function

' =====================================================
' FUNCTION : Extraire les numéros correspondant à une voie spécifique (SANS DOUBLONS)
' =====================================================
Function ExtraireNumerosParVoie(numerosTexte As String, indexVoie As Integer, totalVoies As Integer) As Collection
    Set ExtraireNumerosParVoie = New Collection
    
    ' Dictionnaire pour éviter les doublons
    Dim dictUniques As Object
    Set dictUniques = CreateObject("Scripting.Dictionary")
    
    ' Nouvelle approche : analyser la structure du texte pour identifier les groupes par voie
    ' Si le texte contient des séparateurs de voies (" / "), les utiliser
    If InStr(numerosTexte, " / ") > 0 Then
        ' Le texte est déjà séparé par voies
        Dim partiesVoies As Variant
        partiesVoies = Split(numerosTexte, " / ")
        
        ' Vérifier que l'index de voie correspond
        If indexVoie <= UBound(partiesVoies) Then
            Dim partieVoie As String
            partieVoie = Trim(partiesVoies(indexVoie))
            
            ' Extraire les numéros de cette partie
            Dim reg As Object
            Set reg = CreateObject("VBScript.RegExp")
            reg.Pattern = "\d+"
            reg.Global = True
            
            Dim matches As Object
            Set matches = reg.Execute(partieVoie)
            
            Dim i As Long
            For i = 0 To matches.Count - 1
                Dim numero As Long
                numero = CLng(matches(i).Value)
                If numero > 0 And Not dictUniques.Exists(numero) Then
                    dictUniques.Add numero, True
                    ExtraireNumerosParVoie.Add numero
                End If
            Next i
        End If
    Else
        ' Pas de séparation explicite : répartir équitablement
        Dim tousNumeros As Collection
        Set tousNumeros = New Collection
        
        ' Extraire tous les numéros dans l'ordre (sans doublons)
        Dim dictTousUniques As Object
        Set dictTousUniques = CreateObject("Scripting.Dictionary")
        
        'Dim reg As Object
        Set reg = CreateObject("VBScript.RegExp")
        reg.Pattern = "\d+"
        reg.Global = True
        
        'Dim matches As Object
        Set matches = reg.Execute(numerosTexte)
        
        'Dim i As Long
        For i = 0 To matches.Count - 1
            'Dim numero As Long
            numero = CLng(matches(i).Value)
            If numero > 0 And Not dictTousUniques.Exists(numero) Then
                dictTousUniques.Add numero, True
                tousNumeros.Add numero
            End If
        Next i
        
        ' Répartir les numéros uniques entre les voies
        For i = indexVoie + 1 To tousNumeros.Count Step totalVoies
            ExtraireNumerosParVoie.Add tousNumeros(i)
        Next i
    End If
End Function

' =====================================================
' FUNCTION : Générer les bornes pour une voie unique
' =====================================================
Function GenererBornesVoieUnique(numerosVoie As Collection) As String
    If numerosVoie.Count = 0 Then
        GenererBornesVoieUnique = ""
        Exit Function
    End If
    
    ' Séparer pairs et impairs
    Dim pairs As New Collection
    Dim impairs As New Collection
    
    Dim i As Long
    For i = 1 To numerosVoie.Count
        Dim numero As Long
        numero = numerosVoie(i)
        If numero Mod 2 = 0 Then
            pairs.Add numero
        Else
            impairs.Add numero
        End If
    Next i
    
    ' Générer les bornes pour chaque parité
    Dim res As String
    res = ""
    
    If pairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesSimples(pairs)
        If resPairs <> "" Then res = resPairs
    End If
    
    If impairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesSimples(impairs)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    GenererBornesVoieUnique = res
End Function

' =====================================================
' FUNCTION : Générer des bornes simples pour une collection de numéros (AVEC PARITÉ ET SANS DOUBLONS)
' =====================================================
Function GenererBornesSimples(coll As Collection) As String
    If coll.Count = 0 Then
        GenererBornesSimples = ""
        Exit Function
    End If
    
    ' ÉTAPE 1 : Éliminer les doublons avec un dictionnaire
    Dim dictUniques As Object
    Set dictUniques = CreateObject("Scripting.Dictionary")
    
    Dim i As Long
    For i = 1 To coll.Count
        Dim numero As Long
        numero = coll(i)
        If Not dictUniques.Exists(numero) Then
            dictUniques.Add numero, True
        End If
    Next i
    
    ' ÉTAPE 2 : Convertir en tableau et trier
    Dim arr() As Long
    ReDim arr(dictUniques.Count - 1)
    
    i = 0
    Dim cle As Variant
    For Each cle In dictUniques.Keys
        arr(i) = CLng(cle)
        i = i + 1
    Next cle
    
    ' ÉTAPE 3 : Tri simple
    Dim j As Long, temp As Long
    For i = 0 To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
    
    ' ÉTAPE 4 : Créer les plages en respectant la parité
    Dim plages As New Collection
    Dim debut As Long, fin As Long
    debut = arr(0)
    fin = arr(0)
    
    For i = 1 To UBound(arr)
        ' Vérifier la parité ET la consécutivité
        If arr(i) = fin + 2 And (arr(i) Mod 2 = debut Mod 2) Then
            ' Même parité et numéros consécutifs dans cette parité
            fin = arr(i)
        Else
            ' Terminer la plage actuelle
            If debut = fin Then
                plages.Add CStr(debut)
            Else
                plages.Add debut & " à " & fin
            End If
            debut = arr(i)
            fin = arr(i)
        End If
    Next i
    
    ' Ajouter la dernière plage
    If debut = fin Then
        plages.Add CStr(debut)
    Else
        plages.Add debut & " à " & fin
    End If
    
    ' ÉTAPE 5 : Construire le résultat
    Dim res As String
    res = ""
    For i = 1 To plages.Count
        If i > 1 Then res = res & ", "
        res = res & plages(i)
    Next i
    
    GenererBornesSimples = res
End Function

' =====================================================
' MACRO : Version améliorée pour les boutons
' =====================================================
Sub SimplifierBornesFromButtonMultivoies()
    ' Macro appelée par le bouton "Simplifier Bornes" avec support multivoies
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur la bonne feuille
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit être utilisée sur une feuille façade", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant exécution
    If MsgBox("Voulez-vous simplifier les bornes de numéros avec regroupement par voies ?" & vbCrLf & _
              "Cette action va regrouper les numéros consécutifs en plages avec crochets pour les multivoies." & vbCrLf & _
              "Exemple : [10 à 80 / 23 à 53] [12 à 98 / 45 à 99]", _
              vbQuestion + vbYesNo, "Simplifier Bornes Multivoies") = vbYes Then
        
        ' Exécuter la macro de simplification multivoies
        Call SimplificationBornesNumPDIMultivoies
    End If
End Sub

' =====================================================
' MACRO DE TEST : Analyser une cellule multivoies (AVEC EXCLUSIONS)
' =====================================================
Sub TesterCelluleMultivoiesAvecExclusions()
    On Error Resume Next
    
    Dim cellule As Range
    Set cellule = Selection.Cells(1, 1)
    
    Dim valeurNum As String
    Dim valeurVoie As String
    
    valeurNum = CStr(cellule.Value)
    
    ' Obtenir la voie correspondante
    If cellule.Row Mod 2 = 1 Then ' Ligne de numéros
        valeurVoie = CStr(ActiveSheet.Cells(cellule.Row + 1, cellule.Column).Value)
    Else ' Ligne de voies
        valeurVoie = valeurNum
        valeurNum = CStr(ActiveSheet.Cells(cellule.Row - 1, cellule.Column).Value)
    End If
    
    ' Indexer toute la façade pour les exclusions
    Dim dataParCellule As Object
    Set dataParCellule = CreateObject("Scripting.Dictionary")
    Call IndexerTousLesNumerosFacade(ActiveSheet, ActiveSheet.UsedRange.Rows.Count, 26, dataParCellule)
    
    Dim msg As String
    msg = "TEST CELLULE MULTIVOIES (AVEC EXCLUSIONS)" & vbCrLf & vbCrLf
    msg = msg & "Adresse : " & cellule.Address & vbCrLf
    msg = msg & "Numéros : " & valeurNum & vbCrLf
    msg = msg & "Voies : " & valeurVoie & vbCrLf & vbCrLf
    
    ' Test de traitement avec exclusions
    Dim resultat As String
    resultat = TraiterCaseMultivoiesAvecExclusions(valeurNum, valeurVoie, dataParCellule, cellule.Address)
    
    msg = msg & "RÉSULTAT APRÈS TRAITEMENT :" & vbCrLf
    msg = msg & resultat & vbCrLf & vbCrLf
    
    ' Comparer avec l'original
    If resultat <> valeurNum Then
        msg = msg & "✅ La cellule sera modifiée" & vbCrLf
        msg = msg & "📋 Doublons supprimés + exclusions appliquées"
    Else
        msg = msg & "ℹ️ Aucune modification nécessaire"
    End If
    
    ' Ajouter un exemple pratique avec exclusions
    msg = msg & vbCrLf & vbCrLf & "💡 LOGIQUE D'EXCLUSIONS :" & vbCrLf
    msg = msg & "• Si vous avez : 2,8,10,12 dans cette case" & vbCrLf
    msg = msg & "• Et que 4,6 ne sont PAS utilisés ailleurs" & vbCrLf
    msg = msg & "• Alors résultat : '2 à 12' (borne continue)" & vbCrLf
    msg = msg & "• Sinon : '2,8 à 12' (borne avec gap)"
    
    MsgBox msg, vbInformation, "Test Multivoies - Avec Exclusions"
    
    On Error GoTo 0
End Sub
