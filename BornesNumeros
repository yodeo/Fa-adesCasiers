' =====================================================
' FONCTIONS UTILITAIRES NÉCESSAIRES
' =====================================================

' Fonction pour vérifier si une valeur contient seulement des symboles
Function EstUnSymbole(valeur As String) As Boolean
    On Error Resume Next
    EstUnSymbole = False
    
    ' Si la valeur est vide, ce n'est pas un symbole
    If Len(Trim(valeur)) = 0 Then Exit Function
    
    ' Test simple : si la valeur ne contient aucun chiffre, c'est probablement un symbole
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.pattern = "\d"
    reg.Global = True
    
    ' Si pas de chiffres trouvés, c'est un symbole
    If Not reg.Test(valeur) Then
        EstUnSymbole = True
    End If
    
    On Error GoTo 0
End Function

' Fonction pour extraire le symbole en début de chaîne
Function ExtraireSymboleDebut(texte As String) As String
    Dim premier As String
    
    If Len(texte) = 0 Then
        ExtraireSymboleDebut = ""
        Exit Function
    End If
    
    premier = Left(texte, 1)
    
    ' Vérifier si c'est un symbole Unicode
    If premier = ChrW(&H25B2) Or premier = ChrW(&H25A0) Or premier = ChrW(&H25CB) Then
        ' Inclure l'espace qui suit si présent
        If Len(texte) > 1 And Mid(texte, 2, 1) = " " Then
            ExtraireSymboleDebut = Left(texte, 2)
        Else
            ExtraireSymboleDebut = premier
        End If
    Else
        ExtraireSymboleDebut = ""
    End If
End Function

' Fonction pour enlever le symbole en début de chaîne
Function EnleverSymboleDebut(texte As String) As String
    Dim symbole As String
    symbole = ExtraireSymboleDebut(texte)
    
    If symbole <> "" Then
        EnleverSymboleDebut = Trim(Mid(texte, Len(symbole) + 1))
    Else
        EnleverSymboleDebut = texte
    End If
End Function

' Fonction pour extraire les observations d'un texte PDI
Function ExtraireObservations(texte As String) As String
    Dim lignes As Variant
    
    ' Si il y a un saut de ligne, la deuxième partie sont les observations
    If InStr(texte, vbCrLf) > 0 Then
        lignes = Split(texte, vbCrLf)
        If UBound(lignes) > 0 Then
            ExtraireObservations = Trim(lignes(1))
        Else
            ExtraireObservations = ""
        End If
    Else
        ExtraireObservations = ""
    End If
End Function

' Fonction pour obtenir le libellé de voie pour une cellule PDI
Function ObtenirLibelleVoiePDI(ws As Worksheet, ligneNum As Long, colonne As Long) As String
    Dim ligneVoie As Long
    Dim valVoie As String
    
    ligneVoie = ligneNum + 1 ' La ligne de voie est juste en dessous
    
    ' Vérifier que la ligne de voie existe
    If ligneVoie > ws.Rows.Count Then
        ObtenirLibelleVoiePDI = ""
        Exit Function
    End If
    
    ' Récupérer la valeur de la cellule de voie
    valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne).Value))
    
    ' Si la cellule de voie n'est pas vide, la retourner
    If valVoie <> "" Then
        ' Nettoyer le libellé (enlever le cercle blanc si présent)
        If Left(valVoie, 1) = ChrW(&H25CB) Then ' Cercle blanc
            valVoie = Trim(Mid(valVoie, 3)) ' Enlever le cercle et l'espace
        End If
        ObtenirLibelleVoiePDI = valVoie
        Exit Function
    End If
    
    ' Si la cellule est fusionnée, récupérer la valeur de la première cellule
    If ws.Cells(ligneVoie, colonne).MergeCells Then
        valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne).MergeArea.Cells(1, 1).Value))
        If Left(valVoie, 1) = ChrW(&H25CB) Then
            valVoie = Trim(Mid(valVoie, 3))
        End If
        ObtenirLibelleVoiePDI = valVoie
        Exit Function
    End If
    
    ' Sinon, chercher dans les cellules adjacentes
    Dim offset As Long
    For offset = 1 To 5
        ' Chercher à gauche
        If colonne - offset > 0 Then
            valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne - offset).Value))
            If valVoie <> "" Then
                If Left(valVoie, 1) = ChrW(&H25CB) Then
                    valVoie = Trim(Mid(valVoie, 3))
                End If
                ObtenirLibelleVoiePDI = valVoie
                Exit Function
            End If
        End If
        
        ' Chercher à droite
        If colonne + offset <= ws.Columns.Count Then
            valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne + offset).Value))
            If valVoie <> "" Then
                If Left(valVoie, 1) = ChrW(&H25CB) Then
                    valVoie = Trim(Mid(valVoie, 3))
                End If
                ObtenirLibelleVoiePDI = valVoie
                Exit Function
            End If
        End If
    Next offset
    
    ObtenirLibelleVoiePDI = ""
End Function

' Fonction pour extraire les numéros pairs et impairs
Sub ExtraireNumerosPDI(valeur As String, ByRef numsP As Collection, ByRef numsI As Collection)
    On Error Resume Next
    
    ' Utiliser seulement l'expression régulière pour extraire les numéros
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.pattern = "\d+"
    reg.Global = True
    
    Dim matches As Object
    Set matches = reg.Execute(valeur)
    
    Dim i As Long
    Dim n As Long
    
    For i = 0 To matches.Count - 1
        n = CLng(matches(i).Value)
        If Err.Number = 0 And n > 0 Then
            If n Mod 2 = 0 Then
                numsP.Add n
            Else
                numsI.Add n
            End If
        End If
        Err.Clear
    Next i
    
    On Error GoTo 0
End Sub

' Fonction pour appliquer le formatage différencié (version simplifiée)
Sub AppliquerFormatageDifferencieBornes(rng As Range, contenu As String)
    ' Réappliquer le formatage de base
    On Error Resume Next
    With rng
        .Font.Bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    On Error GoTo 0
End Sub

' =====================================================
' SUB : Simplification des bornes avec regroupement par voies (VERSION MULTIVOIES)
' =====================================================
Sub SimplificationBornesNumPDIMultivoies()
    Dim ws As Worksheet
    Dim wsFacade As Worksheet
    Dim lastRow As Long
    Dim lastCol As Long
    Dim nbModifiees As Long
    
    ' Vérifier qu'on est sur la bonne feuille
    Set ws = ActiveSheet
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Veuillez activer une feuille façade avant d'exécuter cette macro.", vbExclamation
        Exit Sub
    End If
    
    Set wsFacade = ws
    
    ' Trouver les limites de la feuille
    lastRow = wsFacade.Cells(wsFacade.Rows.Count, 1).End(xlUp).Row
    lastCol = 26 ' Colonnes A à Z
    
    Application.ScreenUpdating = False
    
    nbModifiees = 0
    
    ' Traiter chaque cellule de numéros PDI
    Dim i As Long, j As Long
    For i = 1 To lastRow Step 2 ' Lignes impaires (numéros PDI)
        For j = 1 To lastCol
            Dim celluleNum As Range
            Set celluleNum = wsFacade.Cells(i, j)
            
            ' Vérifier si la cellule contient des numéros
            Dim valeurNum As String
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                ' Obtenir les libellés de voies correspondants
                Dim voies As String
                voies = ObtenirLibelleVoiePDI(wsFacade, i, j)
                
                If voies <> "" Then
                    ' Traiter la case multivoie
                    Dim nouveauTexte As String
                    nouveauTexte = TraiterCaseMultivoies(valeurNum, voies)
                    
                    If nouveauTexte <> "" And nouveauTexte <> celluleNum.Value Then
                        ' Conserver le formatage existant
                        Dim formatOriginal As Variant
                        Dim couleurFond As Long
                        Dim couleurTexte As Long
                        Dim estGras As Boolean
                        
                        formatOriginal = celluleNum.NumberFormat
                        couleurFond = celluleNum.Interior.Color
                        couleurTexte = celluleNum.Font.Color
                        estGras = celluleNum.Font.Bold
                        
                        ' Mettre à jour la valeur
                        celluleNum.Value = nouveauTexte
                        
                        ' Restaurer le formatage
                        celluleNum.NumberFormat = formatOriginal
                        celluleNum.Interior.Color = couleurFond
                        celluleNum.Font.Color = couleurTexte
                        celluleNum.Font.Bold = estGras
                        
                        ' Réappliquer le formatage différencié
                        Call AppliquerFormatageDifferencieBornes(celluleNum, nouveauTexte)
                        
                        nbModifiees = nbModifiees + 1
                    End If
                End If
            End If
        Next j
    Next i
    
    Application.ScreenUpdating = True
    
    ' Message de confirmation
    MsgBox "Simplification des bornes multivoies terminée." & vbCrLf & _
           "Nombre de cellules modifiées : " & nbModifiees, _
           vbInformation, "Bornes Multivoies"
End Sub

' =====================================================
' FUNCTION : Traiter une case multivoies
' =====================================================
Function TraiterCaseMultivoies(numerosTexte As String, voiesTexte As String) As String
    ' Extraire le symbole de début et les observations
    Dim symbole As String
    Dim observations As String
    symbole = ExtraireSymboleDebut(numerosTexte)
    observations = ExtraireObservations(numerosTexte)
    
    ' Nettoyer le texte des numéros (enlever symbole et observations)
    Dim numerosSeuls As String
    numerosSeuls = EnleverSymboleDebut(numerosTexte)
    If InStr(numerosSeuls, vbCrLf) > 0 Then
        numerosSeuls = Split(numerosSeuls, vbCrLf)(0)
    End If
    
    ' Séparer les voies
    Dim voiesArray As Variant
    If InStr(voiesTexte, " / ") > 0 Then
        voiesArray = Split(voiesTexte, " / ")
    Else
        ReDim voiesArray(0)
        voiesArray(0) = voiesTexte
    End If
    
    ' Si une seule voie, traitement normal
    If UBound(voiesArray) = 0 Then
        Dim res As String
        res = TraiterVoieSimple(numerosSeuls)
        If observations <> "" Then
            res = res & vbCrLf & observations
        End If
        TraiterCaseMultivoies = symbole & res
        Exit Function
    End If
    
    ' Cas multivoies : extraire les numéros par voie
    Dim resultatsVoies As Collection
    Set resultatsVoies = New Collection
    
    Dim indexVoie As Integer
    For indexVoie = 0 To UBound(voiesArray)
        Dim voieActuelle As String
        voieActuelle = Trim(voiesArray(indexVoie))
        
        ' Extraire les numéros correspondant à cette voie
        Dim numerosVoie As Collection
        Set numerosVoie = ExtraireNumerosParVoie(numerosSeuls, indexVoie, UBound(voiesArray) + 1)
        
        ' Générer les bornes pour cette voie
        Dim bornesVoie As String
        bornesVoie = GenererBornesVoieUnique(numerosVoie)
        
        If bornesVoie <> "" Then
            resultatsVoies.Add "[" & bornesVoie & "]"
        End If
    Next indexVoie
    
    ' Construire le résultat final
    Dim resultatFinal As String
    resultatFinal = ""
    
    Dim i As Integer
    For i = 1 To resultatsVoies.Count
        If i > 1 Then resultatFinal = resultatFinal & " "
        resultatFinal = resultatFinal & resultatsVoies(i)
    Next i
    
    ' Ajouter les observations si présentes
    If observations <> "" Then
        resultatFinal = resultatFinal & vbCrLf & observations
    End If
    
    TraiterCaseMultivoies = symbole & resultatFinal
End Function

' =====================================================
' FUNCTION : Traiter une voie simple (sans crochets)
' =====================================================
Function TraiterVoieSimple(numerosTexte As String) As String
    Dim collPairs As New Collection
    Dim collImpairs As New Collection
    
    ' Extraire les numéros pairs et impairs
    Call ExtraireNumerosPDI(numerosTexte, collPairs, collImpairs)
    
    ' Générer les bornes
    Dim res As String
    res = ""
    
    If collPairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesSimples(collPairs)
        If resPairs <> "" Then res = resPairs
    End If
    
    If collImpairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesSimples(collImpairs)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    TraiterVoieSimple = res
End Function

' =====================================================
' FUNCTION : Extraire les numéros correspondant à une voie spécifique
' =====================================================
Function ExtraireNumerosParVoie(numerosTexte As String, indexVoie As Integer, totalVoies As Integer) As Collection
    Set ExtraireNumerosParVoie = New Collection
    
    ' Séparer les groupes de numéros par voie
    ' Logique : diviser les numéros en groupes selon le nombre de voies
    Dim tousNumeros As Collection
    Set tousNumeros = New Collection
    
    ' Extraire tous les numéros dans l'ordre
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.Pattern = "\d+"
    reg.Global = True
    
    Dim matches As Object
    Set matches = reg.Execute(numerosTexte)
    
    Dim i As Long
    For i = 0 To matches.Count - 1
        Dim numero As Long
        numero = CLng(matches(i).Value)
        If numero > 0 Then
            tousNumeros.Add numero
        End If
    Next i
    
    ' Si pas de numéros, retourner collection vide
    If tousNumeros.Count = 0 Then Exit Function
    
    ' Diviser les numéros entre les voies
    ' Méthode simple : répartition séquentielle
    For i = indexVoie + 1 To tousNumeros.Count Step totalVoies
        ExtraireNumerosParVoie.Add tousNumeros(i)
    Next i
End Function

' =====================================================
' FUNCTION : Générer les bornes pour une voie unique
' =====================================================
Function GenererBornesVoieUnique(numerosVoie As Collection) As String
    If numerosVoie.Count = 0 Then
        GenererBornesVoieUnique = ""
        Exit Function
    End If
    
    ' Séparer pairs et impairs
    Dim pairs As New Collection
    Dim impairs As New Collection
    
    Dim i As Long
    For i = 1 To numerosVoie.Count
        Dim numero As Long
        numero = numerosVoie(i)
        If numero Mod 2 = 0 Then
            pairs.Add numero
        Else
            impairs.Add numero
        End If
    Next i
    
    ' Générer les bornes pour chaque parité
    Dim res As String
    res = ""
    
    If pairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesSimples(pairs)
        If resPairs <> "" Then res = resPairs
    End If
    
    If impairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesSimples(impairs)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    GenererBornesVoieUnique = res
End Function

' =====================================================
' FUNCTION : Générer des bornes simples pour une collection de numéros
' =====================================================
Function GenererBornesSimples(coll As Collection) As String
    If coll.Count = 0 Then
        GenererBornesSimples = ""
        Exit Function
    End If
    
    ' Convertir en tableau et trier
    Dim arr() As Long
    ReDim arr(coll.Count - 1)
    
    Dim i As Long
    For i = 1 To coll.Count
        arr(i - 1) = coll(i)
    Next i
    
    ' Tri simple
    Dim j As Long, temp As Long
    For i = 0 To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
    
    ' Créer les plages
    Dim plages As New Collection
    Dim debut As Long, fin As Long
    debut = arr(0)
    fin = arr(0)
    
    For i = 1 To UBound(arr)
        If arr(i) = fin + 2 Then ' Même parité et consécutif
            fin = arr(i)
        Else
            ' Terminer la plage actuelle
            If debut = fin Then
                plages.Add CStr(debut)
            Else
                plages.Add debut & " à " & fin
            End If
            debut = arr(i)
            fin = arr(i)
        End If
    Next i
    
    ' Ajouter la dernière plage
    If debut = fin Then
        plages.Add CStr(debut)
    Else
        plages.Add debut & " à " & fin
    End If
    
    ' Construire le résultat
    Dim res As String
    res = ""
    For i = 1 To plages.Count
        If i > 1 Then res = res & " / "
        res = res & plages(i)
    Next i
    
    GenererBornesSimples = res
End Function

' =====================================================
' MACRO : Version améliorée pour les boutons
' =====================================================
Sub SimplifierBornesFromButtonMultivoies()
    ' Macro appelée par le bouton "Simplifier Bornes" avec support multivoies
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur la bonne feuille
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit être utilisée sur une feuille façade", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant exécution
    If MsgBox("Voulez-vous simplifier les bornes de numéros avec regroupement par voies ?" & vbCrLf & _
              "Cette action va regrouper les numéros consécutifs en plages avec crochets pour les multivoies." & vbCrLf & _
              "Exemple : [10 à 80 / 23 à 53] [12 à 98 / 45 à 99]", _
              vbQuestion + vbYesNo, "Simplifier Bornes Multivoies") = vbYes Then
        
        ' Exécuter la macro de simplification multivoies
        Call SimplificationBornesNumPDIMultivoies
    End If
End Sub

' =====================================================
' MACRO DE TEST : Analyser une cellule multivoies
' =====================================================
Sub TesterCelluleMultivoies()
    On Error Resume Next
    
    Dim cellule As Range
    Set cellule = Selection.Cells(1, 1)
    
    Dim valeurNum As String
    Dim valeurVoie As String
    
    valeurNum = CStr(cellule.Value)
    
    ' Obtenir la voie correspondante
    If cellule.Row Mod 2 = 1 Then ' Ligne de numéros
        valeurVoie = CStr(ActiveSheet.Cells(cellule.Row + 1, cellule.Column).Value)
    Else ' Ligne de voies
        valeurVoie = valeurNum
        valeurNum = CStr(ActiveSheet.Cells(cellule.Row - 1, cellule.Column).Value)
    End If
    
    Dim msg As String
    msg = "TEST CELLULE MULTIVOIES" & vbCrLf & vbCrLf
    msg = msg & "Adresse : " & cellule.Address & vbCrLf
    msg = msg & "Numéros : " & valeurNum & vbCrLf
    msg = msg & "Voies : " & valeurVoie & vbCrLf & vbCrLf
    
    ' Test de traitement
    Dim resultat As String
    resultat = TraiterCaseMultivoies(valeurNum, valeurVoie)
    
    msg = msg & "RÉSULTAT APRÈS TRAITEMENT :" & vbCrLf
    msg = msg & resultat & vbCrLf & vbCrLf
    
    ' Comparer avec l'original
    If resultat <> valeurNum Then
        msg = msg & "✅ La cellule sera modifiée"
    Else
        msg = msg & "ℹ️ Aucune modification nécessaire"
    End If
    
    MsgBox msg, vbInformation, "Test Multivoies"
    
    On Error GoTo 0
End Sub
