' =====================================================
' FONCTIONS UTILITAIRES N√âCESSAIRES
' =====================================================

' Fonction pour v√©rifier si une valeur contient seulement des symboles
Function EstUnSymbole(valeur As String) As Boolean
    On Error Resume Next
    EstUnSymbole = False
    
    ' Si la valeur est vide, ce n'est pas un symbole
    If Len(Trim(valeur)) = 0 Then Exit Function
    
    ' Test simple : si la valeur ne contient aucun chiffre, c'est probablement un symbole
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.pattern = "\d"
    reg.Global = True
    
    ' Si pas de chiffres trouv√©s, c'est un symbole
    If Not reg.Test(valeur) Then
        EstUnSymbole = True
    End If
    
    On Error GoTo 0
End Function

' Fonction pour extraire le symbole en d√©but de cha√Æne
Function ExtraireSymboleDebut(texte As String) As String
    Dim premier As String
    
    If Len(texte) = 0 Then
        ExtraireSymboleDebut = ""
        Exit Function
    End If
    
    premier = Left(texte, 1)
    
    ' V√©rifier si c'est un symbole Unicode
    If premier = ChrW(&H25B2) Or premier = ChrW(&H25A0) Or premier = ChrW(&H25CB) Then
        ' Inclure l'espace qui suit si pr√©sent
        If Len(texte) > 1 And Mid(texte, 2, 1) = " " Then
            ExtraireSymboleDebut = Left(texte, 2)
        Else
            ExtraireSymboleDebut = premier
        End If
    Else
        ExtraireSymboleDebut = ""
    End If
End Function

' Fonction pour enlever le symbole en d√©but de cha√Æne
Function EnleverSymboleDebut(texte As String) As String
    Dim symbole As String
    symbole = ExtraireSymboleDebut(texte)
    
    If symbole <> "" Then
        EnleverSymboleDebut = Trim(Mid(texte, Len(symbole) + 1))
    Else
        EnleverSymboleDebut = texte
    End If
End Function

' Fonction pour extraire les observations d'un texte PDI
Function ExtraireObservations(texte As String) As String
    Dim lignes As Variant
    
    ' Si il y a un saut de ligne, la deuxi√®me partie sont les observations
    If InStr(texte, vbCrLf) > 0 Then
        lignes = Split(texte, vbCrLf)
        If UBound(lignes) > 0 Then
            ExtraireObservations = Trim(lignes(1))
        Else
            ExtraireObservations = ""
        End If
    Else
        ExtraireObservations = ""
    End If
End Function

' Fonction pour obtenir le libell√© de voie pour une cellule PDI
Function ObtenirLibelleVoiePDI(ws As Worksheet, ligneNum As Long, colonne As Long) As String
    Dim ligneVoie As Long
    Dim valVoie As String
    
    ligneVoie = ligneNum + 1 ' La ligne de voie est juste en dessous
    
    ' V√©rifier que la ligne de voie existe
    If ligneVoie > ws.Rows.Count Then
        ObtenirLibelleVoiePDI = ""
        Exit Function
    End If
    
    ' R√©cup√©rer la valeur de la cellule de voie
    valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne).Value))
    
    ' Si la cellule de voie n'est pas vide, la retourner
    If valVoie <> "" Then
        ' Nettoyer le libell√© (enlever le cercle blanc si pr√©sent)
        If Left(valVoie, 1) = ChrW(&H25CB) Then ' Cercle blanc
            valVoie = Trim(Mid(valVoie, 3)) ' Enlever le cercle et l'espace
        End If
        ObtenirLibelleVoiePDI = valVoie
        Exit Function
    End If
    
    ' Si la cellule est fusionn√©e, r√©cup√©rer la valeur de la premi√®re cellule
    If ws.Cells(ligneVoie, colonne).MergeCells Then
        valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne).MergeArea.Cells(1, 1).Value))
        If Left(valVoie, 1) = ChrW(&H25CB) Then
            valVoie = Trim(Mid(valVoie, 3))
        End If
        ObtenirLibelleVoiePDI = valVoie
        Exit Function
    End If
    
    ' Sinon, chercher dans les cellules adjacentes
    Dim offset As Long
    For offset = 1 To 5
        ' Chercher √† gauche
        If colonne - offset > 0 Then
            valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne - offset).Value))
            If valVoie <> "" Then
                If Left(valVoie, 1) = ChrW(&H25CB) Then
                    valVoie = Trim(Mid(valVoie, 3))
                End If
                ObtenirLibelleVoiePDI = valVoie
                Exit Function
            End If
        End If
        
        ' Chercher √† droite
        If colonne + offset <= ws.Columns.Count Then
            valVoie = Trim(CStr(ws.Cells(ligneVoie, colonne + offset).Value))
            If valVoie <> "" Then
                If Left(valVoie, 1) = ChrW(&H25CB) Then
                    valVoie = Trim(Mid(valVoie, 3))
                End If
                ObtenirLibelleVoiePDI = valVoie
                Exit Function
            End If
        End If
    Next offset
    
    ObtenirLibelleVoiePDI = ""
End Function

' Fonction pour extraire les num√©ros pairs et impairs
Sub ExtraireNumerosPDI(valeur As String, ByRef numsP As Collection, ByRef numsI As Collection)
    On Error Resume Next
    
    ' Utiliser seulement l'expression r√©guli√®re pour extraire les num√©ros
    Dim reg As Object
    Set reg = CreateObject("VBScript.RegExp")
    reg.pattern = "\d+"
    reg.Global = True
    
    Dim matches As Object
    Set matches = reg.Execute(valeur)
    
    Dim i As Long
    Dim n As Long
    
    For i = 0 To matches.Count - 1
        n = CLng(matches(i).Value)
        If Err.Number = 0 And n > 0 Then
            If n Mod 2 = 0 Then
                numsP.Add n
            Else
                numsI.Add n
            End If
        End If
        Err.Clear
    Next i
    
    On Error GoTo 0
End Sub

' Fonction pour appliquer le formatage diff√©renci√© (version simplifi√©e)
Sub AppliquerFormatageDifferencieBornes(rng As Range, contenu As String)
    ' R√©appliquer le formatage de base
    On Error Resume Next
    With rng
        .Font.Bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    On Error GoTo 0
End Sub

' =====================================================
' SUB : Simplification des bornes avec regroupement par voies (VERSION MULTIVOIES AVEC EXCLUSIONS)
' =====================================================
Sub SimplificationBornesNumPDIMultivoies()
    Dim ws As Worksheet
    Dim wsFacade As Worksheet
    Dim lastRow As Long
    Dim lastCol As Long
    Dim nbModifiees As Long
    Dim dataParCellule As Object
    
    ' V√©rifier qu'on est sur la bonne feuille
    Set ws = ActiveSheet
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Veuillez activer une feuille fa√ßade avant d'ex√©cuter cette macro.", vbExclamation
        Exit Sub
    End If
    
    Set wsFacade = ws
    
    ' Trouver les limites de la feuille
    lastRow = wsFacade.Cells(wsFacade.Rows.Count, 1).End(xlUp).Row
    lastCol = 26 ' Colonnes A √† Z
    
    ' √âTAPE 1 : INDEXER TOUS LES NUM√âROS PAR VOIE DANS TOUTE LA FA√áADE
    Set dataParCellule = CreateObject("Scripting.Dictionary")
    Call IndexerTousLesNumerosFacade(wsFacade, lastRow, lastCol, dataParCellule)
    
    Application.ScreenUpdating = False
    nbModifiees = 0
    
    ' √âTAPE 2 : TRAITER CHAQUE CELLULE AVEC V√âRIFICATION DES EXCLUSIONS
    Dim i As Long, j As Long
    For i = 1 To lastRow Step 2 ' Lignes impaires (num√©ros PDI)
        For j = 1 To lastCol
            Dim celluleNum As Range
            Set celluleNum = wsFacade.Cells(i, j)
            
            ' V√©rifier si la cellule contient des num√©ros
            Dim valeurNum As String
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                ' Obtenir les libell√©s de voies correspondants
                Dim voies As String
                voies = ObtenirLibelleVoiePDI(wsFacade, i, j)
                
                If voies <> "" Then
                    ' Traiter la case multivoie avec exclusions
                    Dim nouveauTexte As String
                    nouveauTexte = TraiterCaseMultivoiesAvecExclusions(valeurNum, voies, dataParCellule, celluleNum.Address)
                    
                    If nouveauTexte <> "" And nouveauTexte <> celluleNum.Value Then
                        ' Conserver le formatage existant
                        Dim formatOriginal As Variant
                        Dim couleurFond As Long
                        Dim couleurTexte As Long
                        Dim estGras As Boolean
                        
                        formatOriginal = celluleNum.NumberFormat
                        couleurFond = celluleNum.Interior.Color
                        couleurTexte = celluleNum.Font.Color
                        estGras = celluleNum.Font.Bold
                        
                        ' Mettre √† jour la valeur
                        celluleNum.Value = nouveauTexte
                        
                        ' Restaurer le formatage
                        celluleNum.NumberFormat = formatOriginal
                        celluleNum.Interior.Color = couleurFond
                        celluleNum.Font.Color = couleurTexte
                        celluleNum.Font.Bold = estGras
                        
                        ' R√©appliquer le formatage diff√©renci√©
                        Call AppliquerFormatageDifferencieBornes(celluleNum, nouveauTexte)
                        
                        nbModifiees = nbModifiees + 1
                    End If
                End If
            End If
        Next j
    Next i
    
    Application.ScreenUpdating = True
    
    ' Message de confirmation
    MsgBox "Simplification des bornes multivoies termin√©e." & vbCrLf & _
           "Nombre de cellules modifi√©es : " & nbModifiees & vbCrLf & _
           "Exclusions appliqu√©es selon l'usage dans la fa√ßade.", _
           vbInformation, "Bornes Multivoies avec Exclusions"
End Sub

' =====================================================
' SUB : Indexer tous les num√©ros de la fa√ßade par voie
' =====================================================
Sub IndexerTousLesNumerosFacade(ws As Worksheet, lastRow As Long, lastCol As Long, dataParCellule As Object)
    Dim i As Long, j As Long
    
    For i = 1 To lastRow Step 2 ' Lignes impaires (num√©ros PDI)
        For j = 1 To lastCol
            Dim celluleNum As Range
            Set celluleNum = ws.Cells(i, j)
            
            Dim valeurNum As String
            valeurNum = Trim(CStr(celluleNum.Value))
            
            If valeurNum <> "" And Not EstUnSymbole(valeurNum) Then
                Dim voie As String
                voie = ObtenirLibelleVoiePDI(ws, i, j)
                
                If voie <> "" Then
                    Dim adresse As String
                    adresse = celluleNum.Address
                    
                    ' Cr√©er la structure de donn√©es si n√©cessaire
                    If Not dataParCellule.Exists(voie) Then
                        dataParCellule.Add voie, CreateObject("Scripting.Dictionary")
                    End If
                    
                    If Not dataParCellule(voie).Exists(adresse) Then
                        Dim pairImp As Object
                        Set pairImp = CreateObject("Scripting.Dictionary")
                        pairImp.Add "pairs", New Collection
                        pairImp.Add "impairs", New Collection
                        dataParCellule(voie).Add adresse, pairImp
                    End If
                    
                    ' Extraire les num√©ros pairs et impairs
                    Dim collPairs As Collection
                    Dim collImpairs As Collection
                    Set collPairs = New Collection
                    Set collImpairs = New Collection
                    
                    Call ExtraireNumerosPDI(valeurNum, collPairs, collImpairs)
                    
                    ' Ajouter aux collections (avec suppression des doublons)
                    Dim dictPairsUniques As Object
                    Dim dictImpairsUniques As Object
                    Set dictPairsUniques = CreateObject("Scripting.Dictionary")
                    Set dictImpairsUniques = CreateObject("Scripting.Dictionary")
                    
                    Dim num As Variant
                    For Each num In collPairs
                        If Not dictPairsUniques.Exists(num) Then
                            dictPairsUniques.Add num, True
                            dataParCellule(voie)(adresse)("pairs").Add num
                        End If
                    Next
                    For Each num In collImpairs
                        If Not dictImpairsUniques.Exists(num) Then
                            dictImpairsUniques.Add num, True
                            dataParCellule(voie)(adresse)("impairs").Add num
                        End If
                    Next
                End If
            End If
        Next j
    Next i
End Sub

' =====================================================
' FUNCTION : Traiter une case multivoies avec exclusions
' =====================================================
Function TraiterCaseMultivoiesAvecExclusions(numerosTexte As String, voiesTexte As String, dataParCellule As Object, adresseCellule As String) As String
    ' Extraire le symbole de d√©but et les observations
    Dim symbole As String
    Dim observations As String
    symbole = ExtraireSymboleDebut(numerosTexte)
    observations = ExtraireObservations(numerosTexte)
    
    ' Nettoyer le texte des num√©ros
    Dim numerosSeuls As String
    numerosSeuls = EnleverSymboleDebut(numerosTexte)
    If InStr(numerosSeuls, vbCrLf) > 0 Then
        numerosSeuls = Split(numerosSeuls, vbCrLf)(0)
    End If
    
    ' S√©parer les voies
    Dim voiesArray As Variant
    If InStr(voiesTexte, " / ") > 0 Then
        voiesArray = Split(voiesTexte, " / ")
    Else
        ReDim voiesArray(0)
        voiesArray(0) = voiesTexte
    End If
    
    ' Si une seule voie, traitement avec exclusions
    If UBound(voiesArray) = 0 Then
        Dim voieUnique As String
        voieUnique = Trim(voiesArray(0))
        Dim res As String
        res = TraiterVoieAvecExclusions(numerosSeuls, voieUnique, dataParCellule, adresseCellule)
        If observations <> "" Then
            res = res & vbCrLf & observations
        End If
        TraiterCaseMultivoiesAvecExclusions = symbole & res
        Exit Function
    End If
    
    ' Cas multivoies : traiter chaque voie avec ses exclusions
    Dim resultatsVoies As Collection
    Set resultatsVoies = New Collection
    
    Dim indexVoie As Integer
    For indexVoie = 0 To UBound(voiesArray)
        Dim voieActuelle As String
        voieActuelle = Trim(voiesArray(indexVoie))
        
        ' Extraire les num√©ros correspondant √† cette voie
        Dim numerosVoie As Collection
        Set numerosVoie = ExtraireNumerosParVoie(numerosSeuls, indexVoie, UBound(voiesArray) + 1)
        
        ' Construire la cha√Æne des num√©ros pour cette voie
        Dim chaineVoie As String
        chaineVoie = ""
        Dim k As Integer
        For k = 1 To numerosVoie.Count
            If k > 1 Then chaineVoie = chaineVoie & "-"
            chaineVoie = chaineVoie & numerosVoie(k)
        Next k
        
        ' G√©n√©rer les bornes pour cette voie avec exclusions
        Dim bornesVoie As String
        bornesVoie = TraiterVoieAvecExclusions(chaineVoie, voieActuelle, dataParCellule, adresseCellule)
        
        If bornesVoie <> "" Then
            resultatsVoies.Add "[" & bornesVoie & "]"
        End If
    Next indexVoie
    
    ' Construire le r√©sultat final
    Dim resultatFinal As String
    resultatFinal = ""
    
    Dim i As Integer
    For i = 1 To resultatsVoies.Count
        If i > 1 Then resultatFinal = resultatFinal & " "
        resultatFinal = resultatFinal & resultatsVoies(i)
    Next i
    
    ' Ajouter les observations si pr√©sentes
    If observations <> "" Then
        resultatFinal = resultatFinal & vbCrLf & observations
    End If
    
    TraiterCaseMultivoiesAvecExclusions = symbole & resultatFinal
End Function

' =====================================================
' FUNCTION : Traiter une voie avec exclusions
' =====================================================
Function TraiterVoieAvecExclusions(numerosTexte As String, nomVoie As String, dataParCellule As Object, adresseCellule As String) As String
    Dim collPairs As New Collection
    Dim collImpairs As New Collection
    
    ' Extraire les num√©ros pairs et impairs
    Call ExtraireNumerosPDI(numerosTexte, collPairs, collImpairs)
    
    ' R√©cup√©rer les num√©ros utilis√©s dans d'autres cellules de la m√™me voie
    Dim autresP As Object
    Dim autresI As Object
    Set autresP = CreateObject("Scripting.Dictionary")
    Set autresI = CreateObject("Scripting.Dictionary")
    
    If dataParCellule.Exists(nomVoie) Then
        Dim otherAdr As Variant
        For Each otherAdr In dataParCellule(nomVoie).Keys
            If otherAdr <> adresseCellule Then
                Dim num As Variant
                For Each num In dataParCellule(nomVoie)(otherAdr)("pairs")
                    autresP(num) = True
                Next
                For Each num In dataParCellule(nomVoie)(otherAdr)("impairs")
                    autresI(num) = True
                Next
            End If
        Next
    End If
    
    ' G√©n√©rer les bornes avec exclusions
    Dim res As String
    res = ""
    
    If collPairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesAvecExclusions(collPairs, autresP, True)
        If resPairs <> "" Then res = resPairs
    End If
    
    If collImpairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesAvecExclusions(collImpairs, autresI, False)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    TraiterVoieAvecExclusions = res
End Function

' =====================================================
' FUNCTION : G√©n√©rer des bornes avec exclusions (LOGIQUE CRUCIALE RESTAUR√âE)
' =====================================================
Function GenererBornesAvecExclusions(coll As Collection, exclus As Object, estPair As Boolean) As String
    ' √âliminer les doublons
    Dim dictUniques As Object
    Set dictUniques = CreateObject("Scripting.Dictionary")
    
    Dim i As Long
    For i = 1 To coll.Count
        Dim numero As Long
        numero = coll(i)
        If Not dictUniques.Exists(numero) Then
            dictUniques.Add numero, True
        End If
    Next i
    
    ' Convertir en tableau et trier
    Dim arr() As Long
    ReDim arr(dictUniques.Count - 1)
    i = 0
    Dim k As Variant
    For Each k In dictUniques.Keys
        arr(i) = CLng(k)
        i = i + 1
    Next
    
    ' Tri simple
    Dim j As Long, temp As Long
    For i = 0 To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
    
    ' Cr√©er les plages en v√©rifiant les exclusions
    Dim plages As New Collection
    Dim debut As Long, fin As Long
    debut = arr(0)
    fin = arr(0)
    
    For i = 1 To UBound(arr)
        Dim actuel As Long
        actuel = arr(i)
        
        ' V√©rifier s'il y a des exclusions entre fin et actuel
        Dim ok As Boolean
        ok = True
        
        ' LOGIQUE CRUCIALE : v√©rifier les num√©ros interm√©diaires de m√™me parit√©
        Dim numeroTest As Long
        For numeroTest = fin + 2 To actuel - 2 Step 2 ' +2/-2 pour rester dans la m√™me parit√©
            If exclus.Exists(numeroTest) Then
                ok = False
                Exit For
            End If
        Next numeroTest
        
        If ok And actuel = fin + 2 Then
            ' Num√©ros cons√©cutifs de m√™me parit√© ET pas d'exclusions
            fin = actuel
        ElseIf ok And actuel > fin + 2 Then
            ' Gap mais pas d'exclusions interm√©diaires -> on peut faire une borne continue
            fin = actuel
        Else
            ' Terminer la plage actuelle
            If debut = fin Then
                plages.Add CStr(debut)
            Else
                plages.Add debut & " √† " & fin
            End If
            debut = actuel
            fin = actuel
        End If
    Next i
    
    ' Ajouter la derni√®re plage
    If debut = fin Then
        plages.Add CStr(debut)
    Else
        plages.Add debut & " √† " & fin
    End If
    
    ' Construire le r√©sultat
    Dim res As String
    res = ""
    For i = 1 To plages.Count
        If i > 1 Then res = res & ", "
        res = res & plages(i)
    Next i
    
    GenererBornesAvecExclusions = res
End Function

' =====================================================
' FUNCTION : Traiter une case multivoies
' =====================================================
Function TraiterCaseMultivoies(numerosTexte As String, voiesTexte As String) As String
    ' Extraire le symbole de d√©but et les observations
    Dim symbole As String
    Dim observations As String
    symbole = ExtraireSymboleDebut(numerosTexte)
    observations = ExtraireObservations(numerosTexte)
    
    ' Nettoyer le texte des num√©ros (enlever symbole et observations)
    Dim numerosSeuls As String
    numerosSeuls = EnleverSymboleDebut(numerosTexte)
    If InStr(numerosSeuls, vbCrLf) > 0 Then
        numerosSeuls = Split(numerosSeuls, vbCrLf)(0)
    End If
    
    ' S√©parer les voies
    Dim voiesArray As Variant
    If InStr(voiesTexte, " / ") > 0 Then
        voiesArray = Split(voiesTexte, " / ")
    Else
        ReDim voiesArray(0)
        voiesArray(0) = voiesTexte
    End If
    
    ' Si une seule voie, traitement normal
    If UBound(voiesArray) = 0 Then
        Dim res As String
        res = TraiterVoieSimple(numerosSeuls)
        If observations <> "" Then
            res = res & vbCrLf & observations
        End If
        TraiterCaseMultivoies = symbole & res
        Exit Function
    End If
    
    ' Cas multivoies : extraire les num√©ros par voie
    Dim resultatsVoies As Collection
    Set resultatsVoies = New Collection
    
    Dim indexVoie As Integer
    For indexVoie = 0 To UBound(voiesArray)
        Dim voieActuelle As String
        voieActuelle = Trim(voiesArray(indexVoie))
        
        ' Extraire les num√©ros correspondant √† cette voie
        Dim numerosVoie As Collection
        Set numerosVoie = ExtraireNumerosParVoie(numerosSeuls, indexVoie, UBound(voiesArray) + 1)
        
        ' G√©n√©rer les bornes pour cette voie
        Dim bornesVoie As String
        bornesVoie = GenererBornesVoieUnique(numerosVoie)
        
        If bornesVoie <> "" Then
            resultatsVoies.Add "[" & bornesVoie & "]"
        End If
    Next indexVoie
    
    ' Construire le r√©sultat final
    Dim resultatFinal As String
    resultatFinal = ""
    
    Dim i As Integer
    For i = 1 To resultatsVoies.Count
        If i > 1 Then resultatFinal = resultatFinal & " "
        resultatFinal = resultatFinal & resultatsVoies(i)
    Next i
    
    ' Ajouter les observations si pr√©sentes
    If observations <> "" Then
        resultatFinal = resultatFinal & vbCrLf & observations
    End If
    
    TraiterCaseMultivoies = symbole & resultatFinal
End Function

' =====================================================
' FUNCTION : Traiter une voie simple (sans crochets)
' =====================================================
Function TraiterVoieSimple(numerosTexte As String) As String
    Dim collPairs As New Collection
    Dim collImpairs As New Collection
    
    ' Extraire les num√©ros pairs et impairs
    Call ExtraireNumerosPDI(numerosTexte, collPairs, collImpairs)
    
    ' G√©n√©rer les bornes
    Dim res As String
    res = ""
    
    If collPairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesSimples(collPairs)
        If resPairs <> "" Then res = resPairs
    End If
    
    If collImpairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesSimples(collImpairs)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    TraiterVoieSimple = res
End Function

' =====================================================
' FUNCTION : Extraire les num√©ros correspondant √† une voie sp√©cifique (SANS DOUBLONS)
' =====================================================
Function ExtraireNumerosParVoie(numerosTexte As String, indexVoie As Integer, totalVoies As Integer) As Collection
    Set ExtraireNumerosParVoie = New Collection
    
    ' Dictionnaire pour √©viter les doublons
    Dim dictUniques As Object
    Set dictUniques = CreateObject("Scripting.Dictionary")
    
    ' Nouvelle approche : analyser la structure du texte pour identifier les groupes par voie
    ' Si le texte contient des s√©parateurs de voies (" / "), les utiliser
    If InStr(numerosTexte, " / ") > 0 Then
        ' Le texte est d√©j√† s√©par√© par voies
        Dim partiesVoies As Variant
        partiesVoies = Split(numerosTexte, " / ")
        
        ' V√©rifier que l'index de voie correspond
        If indexVoie <= UBound(partiesVoies) Then
            Dim partieVoie As String
            partieVoie = Trim(partiesVoies(indexVoie))
            
            ' Extraire les num√©ros de cette partie
            Dim reg As Object
            Set reg = CreateObject("VBScript.RegExp")
            reg.Pattern = "\d+"
            reg.Global = True
            
            Dim matches As Object
            Set matches = reg.Execute(partieVoie)
            
            Dim i As Long
            For i = 0 To matches.Count - 1
                Dim numero As Long
                numero = CLng(matches(i).Value)
                If numero > 0 And Not dictUniques.Exists(numero) Then
                    dictUniques.Add numero, True
                    ExtraireNumerosParVoie.Add numero
                End If
            Next i
        End If
    Else
        ' Pas de s√©paration explicite : r√©partir √©quitablement
        Dim tousNumeros As Collection
        Set tousNumeros = New Collection
        
        ' Extraire tous les num√©ros dans l'ordre (sans doublons)
        Dim dictTousUniques As Object
        Set dictTousUniques = CreateObject("Scripting.Dictionary")
        
        'Dim reg As Object
        Set reg = CreateObject("VBScript.RegExp")
        reg.Pattern = "\d+"
        reg.Global = True
        
        'Dim matches As Object
        Set matches = reg.Execute(numerosTexte)
        
        'Dim i As Long
        For i = 0 To matches.Count - 1
            'Dim numero As Long
            numero = CLng(matches(i).Value)
            If numero > 0 And Not dictTousUniques.Exists(numero) Then
                dictTousUniques.Add numero, True
                tousNumeros.Add numero
            End If
        Next i
        
        ' R√©partir les num√©ros uniques entre les voies
        For i = indexVoie + 1 To tousNumeros.Count Step totalVoies
            ExtraireNumerosParVoie.Add tousNumeros(i)
        Next i
    End If
End Function

' =====================================================
' FUNCTION : G√©n√©rer les bornes pour une voie unique
' =====================================================
Function GenererBornesVoieUnique(numerosVoie As Collection) As String
    If numerosVoie.Count = 0 Then
        GenererBornesVoieUnique = ""
        Exit Function
    End If
    
    ' S√©parer pairs et impairs
    Dim pairs As New Collection
    Dim impairs As New Collection
    
    Dim i As Long
    For i = 1 To numerosVoie.Count
        Dim numero As Long
        numero = numerosVoie(i)
        If numero Mod 2 = 0 Then
            pairs.Add numero
        Else
            impairs.Add numero
        End If
    Next i
    
    ' G√©n√©rer les bornes pour chaque parit√©
    Dim res As String
    res = ""
    
    If pairs.Count > 0 Then
        Dim resPairs As String
        resPairs = GenererBornesSimples(pairs)
        If resPairs <> "" Then res = resPairs
    End If
    
    If impairs.Count > 0 Then
        Dim resImpairs As String
        resImpairs = GenererBornesSimples(impairs)
        If resImpairs <> "" Then
            If res <> "" Then
                res = res & " / " & resImpairs
            Else
                res = resImpairs
            End If
        End If
    End If
    
    GenererBornesVoieUnique = res
End Function

' =====================================================
' FUNCTION : G√©n√©rer des bornes simples pour une collection de num√©ros (AVEC PARIT√â ET SANS DOUBLONS)
' =====================================================
Function GenererBornesSimples(coll As Collection) As String
    If coll.Count = 0 Then
        GenererBornesSimples = ""
        Exit Function
    End If
    
    ' √âTAPE 1 : √âliminer les doublons avec un dictionnaire
    Dim dictUniques As Object
    Set dictUniques = CreateObject("Scripting.Dictionary")
    
    Dim i As Long
    For i = 1 To coll.Count
        Dim numero As Long
        numero = coll(i)
        If Not dictUniques.Exists(numero) Then
            dictUniques.Add numero, True
        End If
    Next i
    
    ' √âTAPE 2 : Convertir en tableau et trier
    Dim arr() As Long
    ReDim arr(dictUniques.Count - 1)
    
    i = 0
    Dim cle As Variant
    For Each cle In dictUniques.Keys
        arr(i) = CLng(cle)
        i = i + 1
    Next cle
    
    ' √âTAPE 3 : Tri simple
    Dim j As Long, temp As Long
    For i = 0 To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
    
    ' √âTAPE 4 : Cr√©er les plages en respectant la parit√©
    Dim plages As New Collection
    Dim debut As Long, fin As Long
    debut = arr(0)
    fin = arr(0)
    
    For i = 1 To UBound(arr)
        ' V√©rifier la parit√© ET la cons√©cutivit√©
        If arr(i) = fin + 2 And (arr(i) Mod 2 = debut Mod 2) Then
            ' M√™me parit√© et num√©ros cons√©cutifs dans cette parit√©
            fin = arr(i)
        Else
            ' Terminer la plage actuelle
            If debut = fin Then
                plages.Add CStr(debut)
            Else
                plages.Add debut & " √† " & fin
            End If
            debut = arr(i)
            fin = arr(i)
        End If
    Next i
    
    ' Ajouter la derni√®re plage
    If debut = fin Then
        plages.Add CStr(debut)
    Else
        plages.Add debut & " √† " & fin
    End If
    
    ' √âTAPE 5 : Construire le r√©sultat
    Dim res As String
    res = ""
    For i = 1 To plages.Count
        If i > 1 Then res = res & ", "
        res = res & plages(i)
    Next i
    
    GenererBornesSimples = res
End Function

' =====================================================
' MACRO : Version am√©lior√©e pour les boutons
' =====================================================
Sub SimplifierBornesFromButtonMultivoies()
    ' Macro appel√©e par le bouton "Simplifier Bornes" avec support multivoies
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' V√©rifier qu'on est sur la bonne feuille
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit √™tre utilis√©e sur une feuille fa√ßade", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant ex√©cution
    If MsgBox("Voulez-vous simplifier les bornes de num√©ros avec regroupement par voies ?" & vbCrLf & _
              "Cette action va regrouper les num√©ros cons√©cutifs en plages avec crochets pour les multivoies." & vbCrLf & _
              "Exemple : [10 √† 80 / 23 √† 53] [12 √† 98 / 45 √† 99]", _
              vbQuestion + vbYesNo, "Simplifier Bornes Multivoies") = vbYes Then
        
        ' Ex√©cuter la macro de simplification multivoies
        Call SimplificationBornesNumPDIMultivoies
    End If
End Sub

' =====================================================
' MACRO DE TEST : Analyser une cellule multivoies (AVEC EXCLUSIONS)
' =====================================================
Sub TesterCelluleMultivoiesAvecExclusions()
    On Error Resume Next
    
    Dim cellule As Range
    Set cellule = Selection.Cells(1, 1)
    
    Dim valeurNum As String
    Dim valeurVoie As String
    
    valeurNum = CStr(cellule.Value)
    
    ' Obtenir la voie correspondante
    If cellule.Row Mod 2 = 1 Then ' Ligne de num√©ros
        valeurVoie = CStr(ActiveSheet.Cells(cellule.Row + 1, cellule.Column).Value)
    Else ' Ligne de voies
        valeurVoie = valeurNum
        valeurNum = CStr(ActiveSheet.Cells(cellule.Row - 1, cellule.Column).Value)
    End If
    
    ' Indexer toute la fa√ßade pour les exclusions
    Dim dataParCellule As Object
    Set dataParCellule = CreateObject("Scripting.Dictionary")
    Call IndexerTousLesNumerosFacade(ActiveSheet, ActiveSheet.UsedRange.Rows.Count, 26, dataParCellule)
    
    Dim msg As String
    msg = "TEST CELLULE MULTIVOIES (AVEC EXCLUSIONS)" & vbCrLf & vbCrLf
    msg = msg & "Adresse : " & cellule.Address & vbCrLf
    msg = msg & "Num√©ros : " & valeurNum & vbCrLf
    msg = msg & "Voies : " & valeurVoie & vbCrLf & vbCrLf
    
    ' Test de traitement avec exclusions
    Dim resultat As String
    resultat = TraiterCaseMultivoiesAvecExclusions(valeurNum, valeurVoie, dataParCellule, cellule.Address)
    
    msg = msg & "R√âSULTAT APR√àS TRAITEMENT :" & vbCrLf
    msg = msg & resultat & vbCrLf & vbCrLf
    
    ' Comparer avec l'original
    If resultat <> valeurNum Then
        msg = msg & "‚úÖ La cellule sera modifi√©e" & vbCrLf
        msg = msg & "üìã Doublons supprim√©s + exclusions appliqu√©es"
    Else
        msg = msg & "‚ÑπÔ∏è Aucune modification n√©cessaire"
    End If
    
    ' Ajouter un exemple pratique avec exclusions
    msg = msg & vbCrLf & vbCrLf & "üí° LOGIQUE D'EXCLUSIONS :" & vbCrLf
    msg = msg & "‚Ä¢ Si vous avez : 2,8,10,12 dans cette case" & vbCrLf
    msg = msg & "‚Ä¢ Et que 4,6 ne sont PAS utilis√©s ailleurs" & vbCrLf
    msg = msg & "‚Ä¢ Alors r√©sultat : '2 √† 12' (borne continue)" & vbCrLf
    msg = msg & "‚Ä¢ Sinon : '2,8 √† 12' (borne avec gap)"
    
    MsgBox msg, vbInformation, "Test Multivoies - Avec Exclusions"
    
    On Error GoTo 0
End Sub
