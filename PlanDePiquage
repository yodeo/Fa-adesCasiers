Sub PlanDePiquage()
    ' VERSION OPTIMISÉE POUR LES PERFORMANCES
    ' Utilise des tableaux et des opérations en lot pour drastiquement améliorer la vitesse
    
    Dim wsSource As Worksheet, wsDest As Worksheet
    Dim lastRow As Long, dataRows As Long
    Dim sourceData As Variant, destData As Variant
    Dim colorData() As Long, fontColorData() As Long
    Dim i As Long, destCol As Long, destRow As Long
    Dim maxCol As Long, currentCaseModule As String
    Dim nomTournee As String, nomFeuilleDestination As String
    
    ' Variables pour l'optimisation des tableaux
    Dim destCols As Long, destRows As Long
    Dim caseModuleData As Variant
    Dim formatInfo As Collection
    
    ' Définir la colonne maximale et initialisation
    maxCol = 15
    destCol = 2
    destRow = 1
    
    ' Optimisations critiques pour les performances
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.DisplayAlerts = False
    Application.EnableEvents = False ' CRITIQUE pour les performances
    
    ' Définir la feuille source et récupérer les informations
    Set wsSource = ActiveSheet
    nomTournee = wsSource.Name
    nomFeuilleDestination = "PPQ" & nomTournee
    
    ' Limiter le nom à 31 caractères
    If Len(nomFeuilleDestination) > 31 Then
        nomFeuilleDestination = "PPQ" & Left(nomTournee, 28)
    End If
    
    ' Supprimer et créer la feuille destination efficacement
    On Error Resume Next
    ThisWorkbook.Sheets(nomFeuilleDestination).Delete
    On Error GoTo 0
    
    Set wsDest = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))
    wsDest.Name = nomFeuilleDestination
    
    ' Configuration rapide des colonnes
    wsDest.Columns("A:A").Insert Shift:=xlToRight
    wsDest.Columns("A:A").ColumnWidth = 3
    
    ' OPTIMISATION MAJEURE: Charger toutes les données source en mémoire d'un coup
    lastRow = wsSource.Cells(wsSource.Rows.Count, "A").End(xlUp).Row
    dataRows = lastRow - 6 ' Exclure les 6 premières lignes
    
    If dataRows <= 0 Then GoTo CleanUp
    
    ' Charger les données source en une seule opération (ÉNORME gain de performance)
    sourceData = wsSource.Range("A7:H" & lastRow).Value2
    
    ' Charger les données de couleur séparément (les propriétés Interior.Color ne peuvent pas être chargées en tableau)
    Dim sourceRange As Range
    Set sourceRange = wsSource.Range("B7:B" & lastRow)
    ReDim colorData(1 To dataRows)
    ReDim fontColorData(1 To dataRows)
    
    ' Récupérer les couleurs individuellement (optimisé avec une seule boucle)
    Dim j As Long
    For j = 1 To dataRows
        colorData(j) = sourceRange.Cells(j, 1).Interior.Color
        fontColorData(j) = sourceRange.Cells(j, 1).Font.Color
    Next j
    
    ' Calculer les dimensions de destination avec marge de sécurité généreuse
    destCols = maxCol + 5 ' +5 pour sécurité
    ' Estimation très généreuse: chaque ligne de données peut créer jusqu'à 4 lignes de destination
    destRows = dataRows * 4 + 50 ' Marge très généreuse
    
    ' Initialiser les tableaux de destination
    ReDim destData(1 To destRows, 1 To destCols)
    ReDim caseModuleData(1 To destRows, 1 To 1)
    Set formatInfo = New Collection
    
    ' Trouver le premier module de case
    For i = 1 To dataRows
        If Trim(CStr(sourceData(i, 8))) <> "" Then
            currentCaseModule = CStr(sourceData(i, 8))
            Exit For
        End If
    Next i
    
    ' BOUCLE OPTIMISÉE: Traitement en mémoire uniquement
    For i = 1 To dataRows
        ' Vérifier changement de case module
        If CStr(sourceData(i, 8)) <> "" And CStr(sourceData(i, 8)) <> currentCaseModule Then
            currentCaseModule = CStr(sourceData(i, 8))
            If destCol > 2 Then
                destCol = 2
                destRow = destRow + 4
            End If
        End If
        
        ' Vérifier limite de colonnes
        If destCol > maxCol + 1 Then
            destCol = 2
            destRow = destRow + 4
        End If
        
        ' Vérifier les limites avant d'écrire dans les tableaux
        If destRow + 2 <= UBound(destData, 1) And destCol <= UBound(destData, 2) Then
            ' Remplir les données dans les tableaux (en mémoire)
            destData(destRow, destCol) = CStr(sourceData(i, 1))     ' NUM ext
            destData(destRow + 1, destCol) = CStr(sourceData(i, 4)) ' OBSERVATIONS
            destData(destRow + 2, destCol) = CStr(sourceData(i, 2)) ' VOIE
            caseModuleData(destRow, 1) = currentCaseModule
        End If
        
        ' Stocker les informations de formatage pour application ultérieure
        Dim formatItem As Object
        Set formatItem = CreateObject("Scripting.Dictionary")
        formatItem.Add "row", destRow + 2
        formatItem.Add "col", destCol
        formatItem.Add "color", colorData(i)
        formatItem.Add "fontColor", fontColorData(i)
        formatInfo.Add formatItem
        
        destCol = destCol + 1
    Next i
    
    ' ÉCRITURE EN LOT: Appliquer toutes les données d'un coup (ÉNORME gain)
    Dim actualRows As Long
    actualRows = destRow + 3
    
    ' Redimensionner les tableaux à la taille réelle
    ReDim Preserve destData(1 To actualRows, 1 To destCols)
    ReDim Preserve caseModuleData(1 To actualRows, 1 To 1)
    
    ' Écrire toutes les données principales en une seule opération
    If actualRows > 0 And destCols > 0 Then
        wsDest.Range(wsDest.Cells(1, 2), wsDest.Cells(actualRows, destCols)).Value2 = destData
        wsDest.Range(wsDest.Cells(1, 1), wsDest.Cells(actualRows, 1)).Value2 = caseModuleData
    End If
    
    ' FORMATAGE EN LOT optimisé
    ' Appliquer le format texte à toutes les cellules d'un coup
    wsDest.Range(wsDest.Cells(1, 1), wsDest.Cells(actualRows, destCols)).NumberFormat = "@"
    
    ' Appliquer les couleurs et formatage spécifique
    For Each formatItem In formatInfo
        With wsDest.Cells(formatItem("row"), formatItem("col"))
            .Interior.Color = formatItem("color")
            .Font.Color = formatItem("fontColor")
        End With
    Next formatItem
    
    ' Formatage en lot de la colonne des modules de case
    With wsDest.Range("A1:A" & actualRows)
        .Orientation = 90
        .Font.Bold = True
        .Interior.Color = RGB(230, 230, 230)
    End With
    
    ' BORDURES EN LOT - beaucoup plus rapide
    ApplyBordersOptimized wsDest, actualRows, destCols
    
CleanUp:
    ' Restaurer les paramètres Excel
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    Application.DisplayAlerts = True
    
    ' Appels aux fonctions de mise en forme optimisées
    Call FusionnerCellulesMemeLigne(nomFeuilleDestination)
    Call AjusterDimensions(nomFeuilleDestination)
    Call CentrerCellules(nomFeuilleDestination)
    Call FusionnerCellulesCase(nomFeuilleDestination)
    Call ConfigurerMiseEnPage(nomFeuilleDestination)
    Call AdjustFontSize(nomFeuilleDestination)
    
    MsgBox "Création du cahier de tournée terminée! (Version optimisée)"
End Sub

' NOUVELLE FONCTION: Application optimisée des bordures
Sub ApplyBordersOptimized(ws As Worksheet, lastRow As Long, lastCol As Long)
    Dim i As Long, j As Long
    Dim borderRanges As Collection
    Set borderRanges = New Collection
    
    ' Collecter les plages nécessitant des bordures
    For i = 1 To lastRow Step 4
        For j = 2 To lastCol
            If Not IsEmpty(ws.Cells(i, j).Value) Then
                borderRanges.Add ws.Range(ws.Cells(i, j), ws.Cells(i + 2, j)).Address
            End If
        Next j
    Next i
    
    ' Appliquer les bordures en lot
    Dim addr As Variant
    For Each addr In borderRanges
        With ws.Range(addr).Borders
            .LineStyle = xlContinuous
            .ColorIndex = 0
            .TintAndShade = 0
            .Weight = xlThin
        End With
    Next addr
End Sub

Sub FusionnerCellulesMemeLigne(ByRef FeuilleDest As String)
    ' VERSION OPTIMISÉE avec traitement par lots
    Dim ws As Worksheet
    Dim lastRow As Long, maxCol As Long
    Dim i As Long, j As Long, startCol As Long
    Dim mergeCandidates As Collection
    
    Application.DisplayAlerts = False
    Set ws = Worksheets(FeuilleDest)
    Set mergeCandidates = New Collection
    
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    maxCol = 16
    
    ' OPTIMISATION: Identifier toutes les fusions nécessaires d'abord
    For i = 1 To lastRow Step 4
        For rowOffset = 0 To 2
            Dim currentRow As Long
            currentRow = i + rowOffset
            
            If currentRow <= lastRow Then
                startCol = 2
                
                ' Algorithme optimisé de détection des fusions
                For j = 3 To maxCol
                    If Not IsEmpty(ws.Cells(currentRow, startCol)) Then
                        If IsEmpty(ws.Cells(currentRow, j)) Or _
                           ws.Cells(currentRow, j).Value <> ws.Cells(currentRow, startCol).Value Then
                            
                            If j - startCol > 1 Then
                                ' Ajouter à la liste des fusions
                                Dim mergeInfo As Object
                                Set mergeInfo = CreateObject("Scripting.Dictionary")
                                mergeInfo.Add "range", ws.Range(ws.Cells(currentRow, startCol), ws.Cells(currentRow, j - 1)).Address
                                mergeCandidates.Add mergeInfo
                            End If
                            startCol = j
                        End If
                    Else
                        startCol = j
                    End If
                Next j
                
                ' Traiter la fin de ligne
                If j - startCol > 1 And Not IsEmpty(ws.Cells(currentRow, startCol)) Then
                    Set mergeInfo = CreateObject("Scripting.Dictionary")
                    mergeInfo.Add "range", ws.Range(ws.Cells(currentRow, startCol), ws.Cells(currentRow, maxCol)).Address
                    mergeCandidates.Add mergeInfo
                End If
            End If
        Next rowOffset
    Next i
    
    ' FUSION EN LOT - beaucoup plus rapide
    For Each mergeInfo In mergeCandidates
        With ws.Range(mergeInfo("range"))
            .Merge
            .HorizontalAlignment = xlCenter
        End With
    Next mergeInfo
    
    Application.DisplayAlerts = True
End Sub

Sub FusionnerCellulesCase(ByRef FeuilleDest As String)
    ' VERSION OPTIMISÉE avec algorithme amélioré
    Dim ws As Worksheet
    Dim lastRow As Long, i As Long
    Dim valuesProcessed As Object
    Dim mergeOperations As Collection
    
    Application.DisplayAlerts = False
    Set ws = Worksheets(FeuilleDest)
    Set valuesProcessed = CreateObject("Scripting.Dictionary")
    Set mergeOperations = New Collection
    
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    
    ' PHASE 1: Identifier toutes les opérations de fusion
    For i = 1 To lastRow
        If Not IsEmpty(ws.Cells(i, 1)) And Not valuesProcessed.Exists(ws.Cells(i, 1).Value) Then
            Dim currentValue As String
            currentValue = ws.Cells(i, 1).Value
            valuesProcessed.Add currentValue, True
            
            ' Collecter les informations de fusion pour cette valeur
            CollectMergeInfo ws, currentValue, lastRow, mergeOperations
        End If
    Next i
    
    ' PHASE 2: Exécuter toutes les fusions en lot
    For Each mergeOp In mergeOperations
        ExecuteMergeOperation ws, mergeOp
    Next mergeOp
    
    Application.DisplayAlerts = True
End Sub

Sub CollectMergeInfo(ws As Worksheet, valueToFind As String, lastRow As Long, mergeOps As Collection)
    Dim i As Long, startRow As Long, endRow As Long
    Dim inSequence As Boolean
    
    inSequence = False
    
    For i = 1 To lastRow
        If Not IsEmpty(ws.Cells(i, 1)) And ws.Cells(i, 1).Value = valueToFind Then
            If Not inSequence Then
                startRow = i
                inSequence = True
            End If
        Else
            If inSequence Then
                endRow = i - 1
                
                ' Ajouter l'opération de fusion si nécessaire
                If endRow > startRow Then
                    Dim mergeOp As Object
                    Set mergeOp = CreateObject("Scripting.Dictionary")
                    mergeOp.Add "startRow", startRow
                    mergeOp.Add "endRow", endRow
                    mergeOp.Add "value", valueToFind
                    mergeOps.Add mergeOp
                End If
                
                inSequence = False
            End If
        End If
    Next i
    
    ' Traiter la fin si nécessaire
    If inSequence And i > startRow Then
        Set mergeOp = CreateObject("Scripting.Dictionary")
        mergeOp.Add "startRow", startRow
        mergeOp.Add "endRow", lastRow
        mergeOp.Add "value", valueToFind
        mergeOps.Add mergeOp
    End If
End Sub

Sub ExecuteMergeOperation(ws As Worksheet, mergeOp As Object)
    Dim startRow As Long, endRow As Long
    startRow = mergeOp("startRow")
    endRow = mergeOp("endRow")
    
    ' Effectuer la fusion
    ws.Range(ws.Cells(startRow, 1), ws.Cells(endRow, 1)).Merge
    
    ' Appliquer le formatage en une seule opération
    With ws.Cells(startRow, 1)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .Orientation = 90
        .Font.Bold = True
        .Interior.Color = RGB(230, 230, 230)
    End With
End Sub

Sub AjusterDimensions(ByRef FeuilleDest As String)
    ' VERSION OPTIMISÉE avec formatage par plages
    Dim ws As Worksheet, lastRow As Long
    
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    
    Set ws = Worksheets(FeuilleDest)
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    
    ' Ajustements de colonnes en une seule opération
    ws.Columns("A:A").ColumnWidth = 3
    ws.Columns("B:P").ColumnWidth = 8.5
    
    ' OPTIMISATION MAJEURE: Formatage par groupes de lignes
    Dim i As Long
    Dim row1Ranges As String, row2Ranges As String, row3Ranges As String, row4Ranges As String
    
    ' Construire les plages de lignes à formater
    For i = 1 To lastRow Step 4
        If i > 1 Then
            row1Ranges = row1Ranges & ","
            row2Ranges = row2Ranges & ","
            row3Ranges = row3Ranges & ","
            row4Ranges = row4Ranges & ","
        End If
        
        row1Ranges = row1Ranges & i & ":" & i
        If i + 1 <= lastRow Then row2Ranges = row2Ranges & (i + 1) & ":" & (i + 1)
        If i + 2 <= lastRow Then row3Ranges = row3Ranges & (i + 2) & ":" & (i + 2)
        If i + 3 <= lastRow Then row4Ranges = row4Ranges & (i + 3) & ":" & (i + 3)
    Next i
    
    ' Appliquer le formatage par lots (ÉNORME gain de performance)
    If row1Ranges <> "" Then
        With ws.Range(row1Ranges).Rows
            .RowHeight = 18
            .Font.Size = 14
            .Font.Bold = True
        End With
    End If
    
    If row2Ranges <> "" Then
        With ws.Range(row2Ranges).Rows
            .RowHeight = 33
            .Font.Size = 8
            .Font.Bold = False
        End With
    End If
    
    If row3Ranges <> "" Then
        ws.Range(row3Ranges).RowHeight = 33
    End If
    
    If row4Ranges <> "" Then
        ws.Range(row4Ranges).RowHeight = 10
    End If
    
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
End Sub

Sub CentrerCellules(ByRef FeuilleDest As String)
    ' VERSION OPTIMISÉE avec formatage de plage unique
    Dim ws As Worksheet
    Dim usedRange As Range
    
    Set ws = Worksheets(FeuilleDest)
    
    ' OPTIMISATION: Formater toute la plage d'un coup
    Set usedRange = ws.Range(ws.Cells(1, 2), ws.Cells(ws.Cells(ws.Rows.Count, "B").End(xlUp).Row, 16))
    
    With usedRange
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
End Sub

Sub ConfigurerMiseEnPage(ByRef FeuilleDest As String)
    ' VERSION OPTIMISÉE avec configuration ciblée
    Dim ws As Worksheet, lastRow As Long
    
    Application.ScreenUpdating = False
    Set ws = Worksheets(FeuilleDest)
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    
    ' Configuration des sauts de page optimisée
    ws.ResetAllPageBreaks
    
    ' Ajouter les sauts de page en une seule boucle
    Dim i As Long
    For i = 24 To lastRow Step 24
        ws.HPageBreaks.Add Before:=ws.Rows(i + 1)
    Next i
    
    ' Configuration de mise en page uniquement pour la feuille concernée
    With ws.PageSetup
        .Orientation = xlLandscape
        .PaperSize = xlPaperA4
        .TopMargin = Application.InchesToPoints(0)
        .BottomMargin = Application.InchesToPoints(0)
        .LeftMargin = Application.InchesToPoints(0)
        .RightMargin = Application.InchesToPoints(0)
        .HeaderMargin = Application.InchesToPoints(0)
        .FooterMargin = Application.InchesToPoints(0)
        .CenterFooter = "Page &P"
        .FitToPagesWide = 1
        .FitToPagesTall = False
        .Zoom = False
    End With
    
    Application.ScreenUpdating = True
End Sub

Sub AdjustFontSize(ByRef FeuilleDest As String)
    ' VERSION OPTIMISÉE avec plages ciblées
    Dim ws As Worksheet
    Dim endRow As Long, targetRange As Range
    
    Set ws = Worksheets(FeuilleDest)
    endRow = ws.Cells(ws.Rows.Count, "B").End(xlUp).Row
    
    ' OPTIMISATION: Appliquer la taille de police à toute la plage d'un coup
    ' Cibler les lignes impaires (3, 7, 11, etc.)
    Dim rangeAddress As String
    Dim i As Long
    
    For i = 3 To endRow Step 4
        If rangeAddress <> "" Then rangeAddress = rangeAddress & ","
        rangeAddress = rangeAddress & i & ":" & i
    Next i
    
    If rangeAddress <> "" Then
        Set targetRange = ws.Range(rangeAddress)
        If Not targetRange Is Nothing Then
            targetRange.Font.Size = 6
        End If
    End If
End Sub

Sub AjouterIndicateursContinuite(ByRef FeuilleDest As String)
    ' FONCTION CONSERVÉE pour compatibilité
    Dim ws As Worksheet, lastRow As Long, i As Long
    Dim currentCase As String, isFirstEmpty As Boolean
    
    Set ws = Worksheets(FeuilleDest)
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    
    Const FLECHE = "?" ' Caractère Unicode 2193
    currentCase = ""
    isFirstEmpty = True
    
    For i = 1 To lastRow
        If Not IsEmpty(ws.Cells(i, 1)) Then
            currentCase = ws.Cells(i, 1).Value
            isFirstEmpty = True
        ElseIf currentCase <> "" Then
            If i < lastRow Then
                If Not IsEmpty(ws.Cells(i + 1, 1)) And ws.Cells(i + 1, 1).Value = currentCase Then
                    If isFirstEmpty Then
                        With ws.Cells(i, 1)
                            .Value = FLECHE
                            .HorizontalAlignment = xlCenter
                            .VerticalAlignment = xlCenter
                            .Font.Bold = True
                            .Font.Size = 14
                            .Interior.Color = RGB(230, 230, 230)
                        End With
                        isFirstEmpty = False
                    End If
                ElseIf Not IsEmpty(ws.Cells(i + 1, 1)) And ws.Cells(i + 1, 1).Value <> currentCase Then
                    currentCase = ""
                    isFirstEmpty = True
                End If
            End If
        End If
    Next i
End Sub
