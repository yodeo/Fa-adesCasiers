Sub GenererFacadePDI()
    '=====================================================
    ' MACRO : G√©n√©ration automatique d'une fa√ßade de casiers PDI
    ' MODIFICATION : La source est maintenant la feuille active, et non plus "Accueil".
    ' Destination : Nouvelle feuille nomm√©e avec le nom de la tourn√©e + "Fac"
    '=====================================================
    
    Dim wsSource As Worksheet, wsDest As Worksheet
    Dim derniereLigne As Long, i As Long
    Dim numPDI As String, Observations As String, nomVoie As String
    Dim largeurPDI As Integer
    Dim ligneActuelle As Long, colonneActuelle As Long
    Dim rngHaut As Range, rngBas As Range, rngCaisson As Range
    Dim valeurLargeur As Variant
    Dim dictCouleurs As Object
    Dim paletteCouleurs As Object
    Dim couleurActuelle As Long
    Dim indexCouleur As Integer
    
    ' Variables pour la gestion des caissons
    Dim maxParCaisson As Integer
    Dim compteurDansCaisson As Integer
    Dim numeroCaisson As Integer
    Dim lettreCaisson As String
    Dim codeCaisson As String
    Dim horsCapacitePermanent As Boolean ' Variable pour tracker le d√©passement permanent
    
    ' Variables pour l'accumulation
    Dim blocEnCours As Boolean
    Dim numAccumule As String
    Dim obsAccumulees As String
    Dim voieAccumulee As String
    Dim largeurBloc As Integer
    
    ' Variables pour la mise √† jour des codes caisson en temps r√©el
    Dim dictMiseAJourCodes As Object
    Dim dictLignesHorsCapacite As Object ' Pour stocker les lignes qui d√©passent
    Dim ligneSourceActuelle As Long
    
    ' NOUVELLE VARIABLE : Nom de la tourn√©e et nom de la feuille destination
    Dim nomTournee As String
    Dim nomFeuilleDestination As String
    
    ' D√©sactiver les mises √† jour √©cran pour am√©liorer les performances
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    ' NETTOYER LE MENU CONTEXTUEL AVANT DE COMMENCER
    Call SupprimerOptionMenuContextuel
    
    ' Cr√©er un dictionnaire pour g√©rer les couleurs par nom de voie
    Set dictCouleurs = CreateObject("Scripting.Dictionary")
    
    ' Cr√©er la palette de couleurs √©tendues
    Set paletteCouleurs = CreateObject("Scripting.Dictionary")
    Call InitialiserPaletteCouleursEtendues(paletteCouleurs)
    indexCouleur = 0
    
    ' Cr√©er un dictionnaire pour stocker les codes caisson √† mettre √† jour
    Set dictMiseAJourCodes = CreateObject("Scripting.Dictionary")
    
    ' Cr√©er un dictionnaire pour stocker les lignes hors capacit√©
    Set dictLignesHorsCapacite = CreateObject("Scripting.Dictionary")
    
    ' MODIFICATION : D√©finir la feuille source comme √©tant la feuille active
    Set wsSource = ActiveSheet
    
    ' NOUVELLE LOGIQUE : R√©cup√©rer le nom de la tourn√©e depuis A1
    nomTournee = Trim(CStr(wsSource.Range("A1").Value))
    
    ' Si A1 est vide, utiliser le nom de la feuille source
    If nomTournee = "" Then
        nomTournee = wsSource.Name
    End If
    
    ' Nettoyer le nom de la tourn√©e (supprimer les caract√®res non autoris√©s dans les noms de feuille)
    nomTournee = NettoyerNomFeuille(nomTournee)
    
    ' Construire le nom de la feuille destination
    nomFeuilleDestination = nomTournee & "Fac"
    
    ' S'assurer que le nom ne d√©passe pas 31 caract√®res (limite Excel)
    If Len(nomFeuilleDestination) > 31 Then
        nomFeuilleDestination = Left(nomFeuilleDestination, 28) & "Fac"
    End If
    
    ' R√©cup√©rer la valeur max par caisson depuis C1 de la feuille active
    maxParCaisson = val(wsSource.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4 ' Valeur par d√©faut si C1 est vide ou invalide
    
    ' Initialiser les compteurs de caisson
    compteurDansCaisson = 1  ' Commence √† 1, pas 0
    numeroCaisson = 1
    lettreCaisson = "A"
    horsCapacitePermanent = False ' Pas encore en d√©passement
    
    ' Supprimer la feuille destination si elle existe d√©j√†
    On Error Resume Next
    ThisWorkbook.Sheets(nomFeuilleDestination).Delete
    On Error GoTo 0
    
    ' Cr√©er la nouvelle feuille destination apr√®s la feuille active
    Set wsDest = ThisWorkbook.Sheets.Add(After:=wsSource)
    wsDest.Name = nomFeuilleDestination
    
    ' Configurer les largeurs de colonnes
    wsDest.Columns("A:B").ColumnWidth = 5.57
    wsDest.Columns("Y:Z").ColumnWidth = 5.57
    wsDest.Columns("AA").ColumnWidth = 3.29
    wsDest.Columns("C:X").ColumnWidth = 4.29
    
    ' Trouver la derni√®re ligne avec des donn√©es dans la feuille source
    derniereLigne = wsSource.Cells(wsSource.Rows.Count, "A").End(xlUp).Row
    
    ' Initialiser les positions de d√©part
    ligneActuelle = 1
    colonneActuelle = 1
    blocEnCours = False
    
    ' PARCOURIR LES DONN√âES √Ä PARTIR DE LA LIGNE 7
    i = 7
    Do While i <= derniereLigne
        ' Lire les donn√©es de la ligne actuelle depuis la feuille source
        numPDI = CStr(wsSource.Cells(i, 1).Text)
        nomVoie = CStr(wsSource.Cells(i, 2).Text)
        Observations = CStr(wsSource.Cells(i, 4).Text)
        valeurLargeur = wsSource.Cells(i, 7).Value
        largeurPDI = ConvertirEnEntier(valeurLargeur, 0)
        
        ' Lire la valeur de la colonne V pour le fond jaune
        Dim valeurColV As String
        valeurColV = CStr(wsSource.Cells(i, 22).Text) ' Colonne V = 22
        
        ' Lire le type PDI (colonne F)
        Dim typePDI As String
        typePDI = CStr(wsSource.Cells(i, 6).Text) ' Colonne F = 6
        
        ' Si on a une largeur > 0, c'est le d√©but d'un nouveau bloc
        If largeurPDI > 0 Then
            ' Stocker la ligne source de d√©but pour ce bloc
            ligneSourceActuelle = i
            
            ' Initialiser l'accumulation pour ce bloc
            numAccumule = numPDI
            obsAccumulees = Observations
            voieAccumulee = nomVoie
            largeurBloc = largeurPDI
            
            ' Variable pour savoir si c'est un bloc multi-voies
            Dim estMultiVoies As Boolean
            estMultiVoies = False
            
            ' Regarder les lignes suivantes pour accumulation
            Dim j As Long
            j = i + 1
            Do While j <= derniereLigne
                Dim largeurSuivante As Integer
                largeurSuivante = ConvertirEnEntier(wsSource.Cells(j, 7).Value, 0)
                
                ' Si largeur = 0, accumuler
                If largeurSuivante = 0 Then
                    Dim numSuivant As String, voieSuivante As String, obsSuivante As String
                    numSuivant = CStr(wsSource.Cells(j, 1).Text)
                    voieSuivante = CStr(wsSource.Cells(j, 2).Text)
                    obsSuivante = CStr(wsSource.Cells(j, 4).Text)
                    
                    ' D√©terminer le s√©parateur pour les num√©ros
                    If voieSuivante <> voieAccumulee And voieSuivante <> "" Then
                        ' Voie diff√©rente : slash
                        numAccumule = numAccumule & " / " & numSuivant
                        estMultiVoies = True
                        ' Ajouter la voie si diff√©rente
                        If InStr(voieAccumulee, voieSuivante) = 0 Then
                            voieAccumulee = voieAccumulee & " / " & voieSuivante
                        End If
                    Else
                        ' M√™me voie : tiret
                        numAccumule = numAccumule & "-" & numSuivant
                    End If
                    
                    ' Accumuler les observations
                    If obsSuivante <> "" Then
                        If obsAccumulees = "" Then
                            obsAccumulees = obsSuivante
                        Else
                            obsAccumulees = obsAccumulees & " / " & obsSuivante
                        End If
                    End If
                    
                    ' V√©rifier aussi la colonne V pour les lignes accumul√©es
                    If wsSource.Cells(j, 22).Text = "B" Then
                        valeurColV = "B"
                    End If
                    
                    ' V√©rifier aussi le type PDI pour les lignes accumul√©es
                    If wsSource.Cells(j, 6).Text = "Bat P" Or wsSource.Cells(j, 6).Text = "Bat C" Then
                        typePDI = wsSource.Cells(j, 6).Text
                    End If
                    
                    j = j + 1
                Else
                    ' On a trouv√© une largeur > 0, on arr√™te l'accumulation
                    Exit Do
                End If
            Loop
            
            ' Mettre √† jour i pour sauter les lignes accumul√©es
            i = j - 1
            
            ' CR√âER LE BLOC PDI
            ' V√©rifier la validit√© de la largeur
            If largeurBloc < 1 Then largeurBloc = 1
            If largeurBloc > 26 Then largeurBloc = 26
            
            ' V√©rifier si on d√©passe la colonne Z (26)
            If colonneActuelle + largeurBloc - 1 > 26 Then
                ' Ajouter le code caisson avant de passer √† la ligne
                If colonneActuelle > 1 Then
                    ' V√©rifier si le caisson actuel d√©passe la capacit√©
                    Dim codeActuel As String
                    codeActuel = numeroCaisson & lettreCaisson
                    If horsCapacitePermanent Or CaissonDepasse(codeActuel, maxParCaisson) Then
                        Call AjouterCodeCaisson(wsDest, ligneActuelle, "HC")
                    Else
                        Call AjouterCodeCaisson(wsDest, ligneActuelle, codeActuel)
                    End If
                End If
                
                ligneActuelle = ligneActuelle + 2
                colonneActuelle = 1
                
                ' Incr√©menter le compteur de caisson selon la nouvelle logique
                numeroCaisson = numeroCaisson + 1
                
                ' Si on d√©passe maxParCaisson, on passe √† la lettre suivante
                If numeroCaisson > maxParCaisson Then
                    numeroCaisson = 1
                    ' Passer √† la lettre suivante
                    If lettreCaisson = "D" Then
                        ' Si on d√©passe D, on est maintenant hors capacit√© de fa√ßon permanente
                        horsCapacitePermanent = True
                        ' On recommence √† A mais on reste hors capacit√©
                        lettreCaisson = "A"
                    Else
                        lettreCaisson = Chr(Asc(lettreCaisson) + 1)
                        ' V√©rifier si on vient d'atteindre le d√©passement
                        If lettreCaisson > "D" And Not horsCapacitePermanent Then
                            horsCapacitePermanent = True
                            lettreCaisson = "A" ' Red√©marre mais reste hors capacit√©
                            numeroCaisson = 1
                        End If
                    End If
                End If
            End If
            
            ' Calculer le code caisson complet pour ce PDI
            Dim codeCompletCaisson As String
            Dim numeroPosition As String
            Dim codeBaseCaisson As String
            
            ' Code de base du caisson (ex: "1A", "2B", etc.)
            codeBaseCaisson = numeroCaisson & lettreCaisson
            
            ' V√©rifier si on d√©passe la limite pour le fond rouge
            Dim fondRouge As Boolean
            fondRouge = horsCapacitePermanent Or CaissonDepasse(codeBaseCaisson, maxParCaisson)
            
            ' Calculer le num√©ro de position (format 01, 02, etc.)
            numeroPosition = Format(colonneActuelle, "00")
            codeCompletCaisson = codeBaseCaisson & " " & numeroPosition
            
            ' Stocker le code pour toutes les lignes de ce bloc (ligne principale + lignes accumul√©es)
            For k = ligneSourceActuelle To j - 1
                dictMiseAJourCodes.Add k, codeCompletCaisson
                ' Si c'est hors capacit√©, l'ajouter au dictionnaire des lignes √† colorer
                If fondRouge Then
                    dictLignesHorsCapacite.Add k, True
                End If
            Next k
            
            ' Cr√©er la cellule du haut (N¬∞ + Observations) - AVEC FORMATAGE DIFF√âRENCI√â
            Set rngHaut = wsDest.Range(wsDest.Cells(ligneActuelle, colonneActuelle), _
                                        wsDest.Cells(ligneActuelle, colonneActuelle + largeurBloc - 1))
            rngHaut.Merge
            
            With rngHaut
                .NumberFormat = "@"
                
                ' Construire le texte avec symbole si n√©cessaire (SANS cercle blanc)
                Dim texteComplet As String
                Dim symbole As String
                symbole = ""
                
                
                ' Ajouter un symbole pour Bat P ou Bat C SEULEMENT
                If typePDI = "Bat P" Then
                    symbole = ChrW(&H25B2) & " " ' Triangle Unicode
                ElseIf typePDI = "Bat C" Then
                    symbole = ChrW(&H25B2) & " " ' Triangle Unicode
                End If

                
                ' Construction du texte avec formatage diff√©renci√© et saut de ligne
                If obsAccumulees <> "" Then
                    ' Format : [Symbole] Num√©ro + SAUT DE LIGNE + Observations
                    texteComplet = symbole & numAccumule & vbCrLf & obsAccumulees
                Else
                    ' Format : [Symbole] Num√©ro seul
                    texteComplet = symbole & numAccumule
                End If
                
                .Value = texteComplet
                .HorizontalAlignment = xlCenter
                .VerticalAlignment = xlCenter
                .WrapText = True
                
                ' Bordures : toujours fines
                .Borders.LineStyle = xlContinuous
                .Borders.Weight = xlThin
                
                ' Priorit√© : rouge si d√©passe > jaune si colonne V = "B" > pas de couleur
                If fondRouge Then
                    .Interior.Color = RGB(255, 0, 0) ' Rouge (priorit√© 1)
                    .Font.Color = RGB(255, 255, 255) ' Texte blanc sur fond rouge
                ElseIf valeurColV = "B" Then
                    .Interior.Color = RGB(255, 255, 0) ' Jaune (priorit√© 2)
                    .Font.Color = RGB(0, 0, 0) ' Texte noir sur fond jaune
                Else
                    .Interior.Pattern = xlNone ' Pas de couleur
                End If
            End With
            
            ' APPLIQUER LE FORMATAGE DIFF√âRENCI√â POUR NUM√âROS VS OBSERVATIONS
            Call AppliquerFormatageDifferencie(rngHaut, symbole, numAccumule, obsAccumulees)
            
            ' Cr√©er la cellule du bas (Nom de la voie) - AVEC LE CERCLE BLANC SI MULTI-VOIES
            Set rngBas = wsDest.Range(wsDest.Cells(ligneActuelle + 1, colonneActuelle), _
                                        wsDest.Cells(ligneActuelle + 1, colonneActuelle + largeurBloc - 1))
            rngBas.Merge
            
            ' Appliquer les abr√©viations au nom de voie
            Dim voieAbregee As String
            voieAbregee = AbregerTypeVoie(voieAccumulee)
            
            ' Construire le texte de la voie avec cercle blanc si multi-voies
            Dim texteVoie As String
            If estMultiVoies Then
                texteVoie = ChrW(&H25CB) & " " & voieAbregee ' Cercle blanc + nom de voie
            Else
                texteVoie = voieAbregee ' Nom de voie seul
            End If
            
            With rngBas
                .NumberFormat = "@"
                .Value = texteVoie ' Utiliser le texte avec ou sans cercle
            End With
            
            ' G√©rer la couleur pour les voies
            If voieAccumulee <> "" Then
                ' Pour les voies multiples, utiliser la couleur de la premi√®re voie
                Dim premiereVoie As String
                Dim posSlash As Integer
                posSlash = InStr(voieAccumulee, " / ")
                If posSlash > 0 Then
                    premiereVoie = Left(voieAccumulee, posSlash - 1)
                Else
                    premiereVoie = voieAccumulee
                End If
                
                If Not dictCouleurs.Exists(premiereVoie) Then
                    ' Utiliser la nouvelle palette de couleurs √©tendues avec v√©rification d'adjacence
                    Dim couleurRGB As Long
                    couleurRGB = ObtenirCouleurDistinctePourVoieAvecAdjacence(premiereVoie, paletteCouleurs, dictCouleurs, colonneActuelle, wsDest, ligneActuelle)
                    dictCouleurs.Add premiereVoie, couleurRGB
                    indexCouleur = indexCouleur + 1
                End If
                couleurActuelle = dictCouleurs(premiereVoie)
            Else
                couleurActuelle = xlNone
            End If
            
            With rngBas
                .HorizontalAlignment = xlCenter
                .VerticalAlignment = xlCenter
                .Font.Bold = True
                .WrapText = True
                
                ' Souligner le texte si multi-voies
                If estMultiVoies Then
                    .Font.Underline = xlUnderlineStyleSingle
                End If
                
                ' Bordures : toujours fines
                .Borders.LineStyle = xlContinuous
                .Borders.Weight = xlThin
                
                If couleurActuelle <> xlNone Then
                    ' Priorit√© : rouge si d√©passe > couleur normale
                    If fondRouge Then
                        .Interior.Color = RGB(255, 0, 0) ' Rouge (priorit√© 1)
                        .Font.Color = RGB(255, 255, 255) ' Texte blanc sur fond rouge
                    Else
                        ' Utiliser la couleur RGB de la nouvelle palette
                        .Interior.Color = couleurActuelle
                        .Font.Color = ObtenirCouleurTexteRGB(couleurActuelle)
                    End If
                Else
                    ' M√™me si pas de couleur de voie, appliquer le rouge si d√©passe
                    If fondRouge Then
                        .Interior.Color = RGB(255, 0, 0) ' Rouge
                        .Font.Color = RGB(255, 255, 255) ' Texte blanc
                    End If
                End If
            End With
            
            ' Ajuster les hauteurs de lignes - CONSERV√âES COMME AVANT
            wsDest.Rows(ligneActuelle).RowHeight = 48.75
            wsDest.Rows(ligneActuelle + 1).RowHeight = 39
            
            ' AJUSTER LA TAILLE DE POLICE SELON LA LARGEUR DE LA CELLULE
            Call AjusterTaillePoliceSelonLargeur(rngHaut, largeurBloc) ' √âchelle num√©ros PDI
            Call AjusterTaillePoliceVoiesSelonLargeur(rngBas, largeurBloc) ' √âchelle noms de voies
            
            ' Avancer √† la position suivante
            colonneActuelle = colonneActuelle + largeurBloc
        End If
        
        i = i + 1
    Loop
    
    ' Ajouter le code caisson pour la derni√®re ligne si n√©cessaire
    If colonneActuelle > 1 Then
        Dim codeFinal As String
        codeFinal = numeroCaisson & lettreCaisson
        If horsCapacitePermanent Or CaissonDepasse(codeFinal, maxParCaisson) Then
            Call AjouterCodeCaisson(wsDest, ligneActuelle, "HC")
        Else
            Call AjouterCodeCaisson(wsDest, ligneActuelle, codeFinal)
        End If
    End If
    
    ' METTRE √Ä JOUR LA COLONNE H DE LA FEUILLE SOURCE AVEC LES CODES CALCUL√âS ET COLORER LES LIGNES HORS CAPACIT√â
    Call MettreAJourColonneHAvecCouleur(wsSource, dictMiseAJourCodes, dictLignesHorsCapacite)
    
    ' Fusionner les cellules adjacentes avec le m√™me nom de voie
    Call FusionnerVoiesAdjacentes(wsDest)
    
    ' Mettre √† jour les cellules vides dans la feuille source
    ' Utiliser la colonne W pour stocker le nombre de cellules vides
    Call MettreAJourCellulesVides(wsSource, wsDest, "W")
    
    ' AJOUTER LES BOUTONS ET MENU CONTEXTUEL √Ä LA FEUILLE FACADE_PDI (VERSION SIMPLIFI√âE)
    Call AjouterBoutonsSeulement(wsDest)
    ' Les menus contextuels sont maintenant g√©r√©s par les √©v√©nements du classeur
    
    ' Masquer le quadrillage
    With wsDest
        ActiveWindow.DisplayGridlines = False
    End With
    
    ' Configuration finale de la feuille
    With wsDest.PageSetup
        .Orientation = xlLandscape
        .FitToPagesWide = 1
        .FitToPagesTall = False
        .CenterHorizontally = True
    End With
    
    ' R√©activer les mises √† jour
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    
    wsDest.Activate
    
    ' NOUVEAU : Appeler la macro d'ajustement des param√®tres d'impression
    ' avec une pause pour s'assurer que la feuille est bien cr√©√©e
    DoEvents
    Application.Wait (Now + TimeValue("0:00:01"))
    
    ' Message de confirmation avec le nouveau nom
    MsgBox "La fa√ßade PDI a √©t√© g√©n√©r√©e avec succ√®s !" & vbCrLf & _
           "Feuille source trait√©e : '" & wsSource.Name & "'" & vbCrLf & _
           "Feuille destination cr√©√©e : '" & nomFeuilleDestination & "'" & vbCrLf & _
           "Nom de tourn√©e utilis√© : '" & nomTournee & "'" & vbCrLf & _
           "Nombre de lignes trait√©es : " & (derniereLigne - 6) & vbCrLf & _
           "Les param√®tres d'impression ont √©t√© configur√©s.", _
           vbInformation, "G√©n√©ration termin√©e"
    
    wsDest.Activate
    
End Sub

' =====================================================
' FONCTION UTILITAIRE : Nettoyer le nom pour qu'il soit valide comme nom de feuille Excel
' =====================================================
Function NettoyerNomFeuille(nomOriginal As String) As String
    Dim nomNettoye As String
    Dim caracteresInterdits As String
    Dim i As Integer
    
    ' Caract√®res interdits dans les noms de feuille Excel
    caracteresInterdits = "[\]/*?:"
    
    nomNettoye = Trim(nomOriginal)
    
    ' Remplacer les caract√®res interdits par des underscores
    For i = 1 To Len(caracteresInterdits)
        nomNettoye = Replace(nomNettoye, Mid(caracteresInterdits, i, 1), "_")
    Next i
    
    ' Supprimer les espaces multiples et les remplacer par un seul underscore
    Do While InStr(nomNettoye, "  ") > 0
        nomNettoye = Replace(nomNettoye, "  ", " ")
    Loop
    
    ' S'assurer que le nom n'est pas vide
    If Len(nomNettoye) = 0 Then
        nomNettoye = "Tournee"
    End If
    
    ' Limiter la longueur pour laisser de la place pour "Fac"
    If Len(nomNettoye) > 28 Then
        nomNettoye = Left(nomNettoye, 28)
    End If
    
    NettoyerNomFeuille = nomNettoye
End Function

' =====================================================
' NOUVEAU SYST√àME DE MENU CONTEXTUEL AM√âLIOR√â
' =====================================================

' Variables globales pour le menu contextuel
Public menuContextuelActif As Boolean
Public derniereFeuilleActive As String

' =====================================================
' GESTIONNAIRE UNIVERSEL DU MENU CONTEXTUEL
' =====================================================

Sub GererMenuContextuelUniversel(ws As Worksheet, Target As Range)
    ' Supprimer l'ancien menu
    Call SupprimerOptionMenuContextuel
    
    ' D√©terminer le type de feuille et ajouter les options appropri√©es
    If InStr(ws.Name, "Fac") > 0 Then
        ' C'est une feuille fa√ßade
        Call AjouterMenuContextuelFacade(Target, ws)
    ElseIf EstFeuilleSource(ws) Then
        ' C'est une feuille source avec donn√©es PDI
        Call AjouterMenuContextuelSource(Target, ws)
    End If
End Sub

' =====================================================
' MENU CONTEXTUEL POUR FEUILLES FACADE
' =====================================================

Sub AjouterMenuContextuelFacade(Target As Range, ws As Worksheet)
    Dim menuContextuel As CommandBar
    Dim nouvelleOption As CommandBarButton
    
    ' V√©rifier qu'on n'est pas dans la colonne des codes caisson
    If Target.Column = 27 Then Exit Sub
    
    Set menuContextuel = Application.CommandBars("Cell")
    
    ' Option principale : Navigation vers source
    Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, before:=1)
    With nouvelleOption
        .Caption = "üìç Naviguer vers ligne Source"
        .OnAction = "NaviguerDepuisFacadeVersSource"
        .Tag = "NavigationPDI"
        .FaceId = 1695
    End With
    
    ' S√©parateur
    Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, before:=2)
    With nouvelleOption
        .Caption = "-"
        .BeginGroup = True
        .Tag = "NavigationPDI"
    End With
    
    ' Options d'optimisation selon le contenu de la cellule
    If Not IsEmpty(Target.Value) Then
        Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, before:=3)
        With nouvelleOption
            .Caption = "üîß Optimiser cette zone"
            .OnAction = "OptimiserZoneSelectionnee"
            .Tag = "NavigationPDI"
        End With
    End If
    
    ' Option pour cellules vides
    If IsEmpty(Target.Value) Then
        Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, before:=3)
        With nouvelleOption
            .Caption = "üñºÔ∏è Ins√©rer image ici"
            .OnAction = "InsererImageCellule"
            .Tag = "NavigationPDI"
        End With
    End If
End Sub

' =====================================================
' MENU CONTEXTUEL POUR FEUILLES SOURCE
' =====================================================

Sub AjouterMenuContextuelSource(Target As Range, ws As Worksheet)
    Dim menuContextuel As CommandBar
    Dim nouvelleOption As CommandBarButton
    
    ' V√©rifier qu'on est dans la zone des donn√©es (ligne 7+, colonnes utiles)
    If Target.Row < 7 Or Target.Column > 8 Then Exit Sub
    
    ' V√©rifier qu'il y a un code caisson en colonne H
    If ws.Cells(Target.Row, 8).Value = "" Then Exit Sub
    
    Set menuContextuel = Application.CommandBars("Cell")
    
    ' Option principale : Navigation vers fa√ßade
    Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, before:=1)
    With nouvelleOption
        .Caption = "üìç Naviguer vers case Fa√ßade"
        .OnAction = "NaviguerDepuisSourceVersFacade"
        .Tag = "NavigationPDI"
        .FaceId = 1695
    End With
    
    ' Option : R√©g√©n√©rer fa√ßade
    Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, before:=2)
    With nouvelleOption
        .Caption = "üîÑ R√©g√©n√©rer la fa√ßade"
        .OnAction = "GenererFacadePDI"
        .Tag = "NavigationPDI"
        .BeginGroup = True
    End With
End Sub

' =====================================================
' FONCTIONS DE NAVIGATION AM√âLIOR√âES
' =====================================================

Sub NaviguerDepuisFacadeVersSource()
    Dim celluleCible As Range
    Dim wsSource As Worksheet
    Dim wsFacade As Worksheet
    Dim codePosition As String
    Dim ligneSourceCible As Long
    
    Set wsFacade = ActiveSheet
    Set celluleCible = Selection
    
    ' Trouver la feuille source correspondante
    Set wsSource = TrouverFeuilleSource(wsFacade)
    If wsSource Is Nothing Then
        MsgBox "‚ùå Impossible de trouver la feuille source correspondante.", vbExclamation, "Navigation impossible"
        Exit Sub
    End If
    
    ' Calculer le code de position
    codePosition = CalculerCodePosition(celluleCible, wsSource)
    If codePosition = "" Then
        MsgBox "‚ùå Impossible de calculer la position. V√©rifiez que vous √™tes sur une case valide.", vbExclamation, "Navigation impossible"
        Exit Sub
    End If
    
    ' Chercher la ligne correspondante
    ligneSourceCible = TrouverLigneAvecCode(wsSource, codePosition)
    If ligneSourceCible > 0 Then
        ' Navigation r√©ussie
        wsSource.Activate
        wsSource.Cells(ligneSourceCible, 1).Select
        
        ' Message de confirmation optionnel
        Application.StatusBar = "‚úÖ Navigation r√©ussie vers " & wsSource.Name & " ligne " & ligneSourceCible
        Application.OnTime Now + TimeValue("00:00:03"), "EffacerStatusBar"
    Else
        MsgBox "‚ùå Position " & codePosition & " non trouv√©e dans la feuille source.", vbExclamation, "Navigation impossible"
    End If
End Sub

Sub NaviguerDepuisSourceVersFacade()
    Dim celluleCible As Range
    Dim wsSource As Worksheet
    Dim wsFacade As Worksheet
    Dim codePosition As String
    
    Set wsSource = ActiveSheet
    Set celluleCible = Selection
    
    ' Lire le code en colonne H
    codePosition = wsSource.Cells(celluleCible.Row, 8).Value
    If codePosition = "" Then
        MsgBox "‚ùå Aucun code de position trouv√© sur cette ligne.", vbExclamation, "Navigation impossible"
        Exit Sub
    End If
    
    ' Trouver la feuille fa√ßade correspondante
    Set wsFacade = TrouverFeuilleFacade(wsSource)
    If wsFacade Is Nothing Then
        MsgBox "‚ùå Aucune feuille fa√ßade trouv√©e. Veuillez d'abord g√©n√©rer la fa√ßade.", vbExclamation, "Navigation impossible"
        Exit Sub
    End If
    
    ' Calculer et naviguer vers la position
    If NaviguerVersPositionFacade(wsFacade, codePosition, wsSource) Then
        Application.StatusBar = "‚úÖ Navigation r√©ussie vers " & wsFacade.Name
        Application.OnTime Now + TimeValue("00:00:03"), "EffacerStatusBar"
    Else
        MsgBox "‚ùå Position " & codePosition & " non trouv√©e dans la fa√ßade.", vbExclamation, "Navigation impossible"
    End If
End Sub

' =====================================================
' FONCTIONS UTILITAIRES AM√âLIOR√âES
' =====================================================

Function EstFeuilleSource(ws As Worksheet) As Boolean
    ' V√©rifier si c'est une feuille source en cherchant des indicateurs
    On Error Resume Next
    
    ' V√©rifier s'il y a des donn√©es en colonne A √† partir de la ligne 7
    If ws.Cells(7, 1).Value <> "" Then
        ' V√©rifier s'il y a une valeur en C1 (max par caisson)
        If IsNumeric(ws.Range("C1").Value) Then
            EstFeuilleSource = True
            Exit Function
        End If
    End If
    
    EstFeuilleSource = False
    On Error GoTo 0
End Function

Function TrouverFeuilleSource(wsFacade As Worksheet) As Worksheet
    Dim ws As Worksheet
    Dim nomTournee As String
    
    ' Extraire le nom de la tourn√©e du nom de la fa√ßade
    nomTournee = Replace(wsFacade.Name, "Fac", "")
    
    ' Chercher une feuille avec ce nom
    For Each ws In ThisWorkbook.Worksheets
        If ws.Name = nomTournee And EstFeuilleSource(ws) Then
            Set TrouverFeuilleSource = ws
            Exit Function
        End If
    Next ws
    
    ' Si pas trouv√© par nom, chercher la feuille pr√©c√©dente
    On Error Resume Next
    Set ws = wsFacade.Previous
    If Not ws Is Nothing And EstFeuilleSource(ws) Then
        Set TrouverFeuilleSource = ws
        Exit Function
    End If
    On Error GoTo 0
    
    Set TrouverFeuilleSource = Nothing
End Function

Function TrouverFeuilleFacade(wsSource As Worksheet) As Worksheet
    Dim ws As Worksheet
    Dim nomTournee As String
    Dim nomFacadeAttendu As String
    
    ' Construire le nom de fa√ßade attendu
    nomTournee = Trim(CStr(wsSource.Range("A1").Value))
    If nomTournee = "" Then nomTournee = wsSource.Name
    nomFacadeAttendu = NettoyerNomFeuille(nomTournee) & "Fac"
    
    ' Chercher la feuille fa√ßade
    For Each ws In ThisWorkbook.Worksheets
        If ws.Name = nomFacadeAttendu Then
            Set TrouverFeuilleFacade = ws
            Exit Function
        End If
    Next ws
    
    ' Si pas trouv√© par nom exact, chercher toute feuille contenant "Fac"
    For Each ws In ThisWorkbook.Worksheets
        If InStr(ws.Name, "Fac") > 0 And ws.Name <> wsSource.Name Then
            Set TrouverFeuilleFacade = ws
            Exit Function
        End If
    Next ws
    
    Set TrouverFeuilleFacade = Nothing
End Function

Function CalculerCodePosition(cellule As Range, wsSource As Worksheet) As String
    Dim ligneFacade As Long, colonneFacade As Long
    Dim maxParCaisson As Integer
    Dim numeroCaisson As Integer, lettreCaisson As String
    Dim indiceLigne As Integer, lettreIndex As Integer
    Dim numeroPosition As String
    
    On Error GoTo ErreurCalcul
    
    ' Obtenir la position de r√©f√©rence
    Set cellule = cellule.Cells(1, 1) ' Premi√®re cellule de la s√©lection
    ligneFacade = cellule.Row
    colonneFacade = cellule.Column
    
    ' Ajuster pour ligne du haut si on est sur ligne du bas
    If ligneFacade Mod 2 = 0 Then ligneFacade = ligneFacade - 1
    
    ' Pour cellules fusionn√©es, prendre la colonne de d√©but
    If cellule.MergeCells Then
        colonneFacade = cellule.MergeArea.Column
    End If
    
    ' R√©cup√©rer les param√®tres
    maxParCaisson = val(wsSource.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4
    
    ' Calculer le caisson
    indiceLigne = (ligneFacade + 1) / 2
    numeroCaisson = ((indiceLigne - 1) Mod (maxParCaisson * 4)) Mod maxParCaisson + 1
    lettreIndex = ((indiceLigne - 1) \ maxParCaisson) Mod 4
    lettreCaisson = Chr(Asc("A") + lettreIndex)
    
    ' Construire le code
    numeroPosition = Format(colonneFacade, "00")
    CalculerCodePosition = numeroCaisson & lettreCaisson & " " & numeroPosition
    
    Exit Function
    
ErreurCalcul:
    CalculerCodePosition = ""
End Function

Function TrouverLigneAvecCode(ws As Worksheet, codeRecherche As String) As Long
    Dim i As Long
    Dim derniereLigne As Long
    
    derniereLigne = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    
    For i = 7 To derniereLigne
        If ws.Cells(i, 8).Value = codeRecherche Then
            TrouverLigneAvecCode = i
            Exit Function
        End If
    Next i
    
    TrouverLigneAvecCode = 0
End Function

Function NaviguerVersPositionFacade(wsFacade As Worksheet, codePosition As String, wsSource As Worksheet) As Boolean
    Dim partieCode As String, partiePosition As String
    Dim posEspace As Integer
    Dim numeroCaisson As Integer, lettreCaisson As String
    Dim maxParCaisson As Integer
    Dim lettreIndex As Integer, indiceLigne As Integer
    Dim ligneFacade As Integer, colonneFacade As Integer
    
    On Error GoTo ErreurNavigation
    
    ' Parser le code (ex: "2A 15")
    posEspace = InStr(codePosition, " ")
    If posEspace = 0 Then GoTo ErreurNavigation
    
    partieCode = Left(codePosition, posEspace - 1)
    partiePosition = Right(codePosition, Len(codePosition) - posEspace)
    
    ' Extraire num√©ro et lettre
    numeroCaisson = val(Left(partieCode, Len(partieCode) - 1))
    lettreCaisson = Right(partieCode, 1)
    colonneFacade = val(partiePosition)
    
    ' Calculer la ligne
    maxParCaisson = val(wsSource.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4
    
    lettreIndex = Asc(lettreCaisson) - Asc("A")
    indiceLigne = (lettreIndex * maxParCaisson) + numeroCaisson
    ligneFacade = (indiceLigne * 2) - 1
    
    ' Naviguer
    wsFacade.Activate
    wsFacade.Cells(ligneFacade, colonneFacade).Select
    
    NaviguerVersPositionFacade = True
    Exit Function
    
ErreurNavigation:
    NaviguerVersPositionFacade = False
End Function

' =====================================================
' NETTOYAGE ET UTILITAIRES
' =====================================================

Sub EffacerStatusBar()
    Application.StatusBar = False
End Sub

' Version am√©lior√©e de la suppression du menu contextuel
Sub SupprimerOptionMenuContextuel()
    Dim ctrl As CommandBarControl
    Dim menuContextuel As CommandBar
    Dim i As Integer
    
    On Error Resume Next
    Set menuContextuel = Application.CommandBars("Cell")
    
    ' Supprimer en partant de la fin pour √©viter les d√©calages d'index
    For i = menuContextuel.Controls.Count To 1 Step -1
        Set ctrl = menuContextuel.Controls(i)
        If ctrl.Tag = "NavigationPDI" Then
            ctrl.Delete
        End If
    Next i
    
    On Error GoTo 0
End Sub

' =====================================================
' MACROS POUR LES OPTIONS DU MENU CONTEXTUEL
' =====================================================

Sub OptimiserZoneSelectionnee()
    Dim cellule As Range
    Set cellule = Selection
    
    MsgBox "üîß Optimisation de la zone autour de " & cellule.Address & vbCrLf & _
           "Cette fonctionnalit√© peut √™tre d√©velopp√©e selon vos besoins sp√©cifiques.", _
           vbInformation, "Optimisation locale"
End Sub

Sub InsererImageCellule()
    Dim cellule As Range
    Set cellule = Selection
    
    If IsEmpty(cellule.Value) Then
        ' Appeler la fonction d'insertion d'image existante ou cr√©er une nouvelle
        MsgBox "üñºÔ∏è Insertion d'image dans " & cellule.Address & vbCrLf & _
               "S√©lectionnez un fichier image √† ins√©rer.", _
               vbInformation, "Insertion d'image"
        ' Ici vous pouvez appeler votre fonction d'insertion d'image existante
        ' Call InsererImagesDansCellulesVides
    Else
        MsgBox "‚ö†Ô∏è Cette cellule n'est pas vide. Veuillez s√©lectionner une cellule vide.", _
               vbExclamation, "Cellule non vide"
    End If
End Sub

' =====================================================
' SUB : G√©rer les changements en temps r√©el de la colonne G - CALCUL PAR CAISSON
' =====================================================
Sub GererChangementColonneG(Target As Range)
    Dim wsSource As Worksheet
    
    ' V√©rifier si le changement concerne la colonne G (largeur) et ligne >= 7
    If Target.Column <> 7 Or Target.Row < 7 Then Exit Sub
    
    ' MODIFICATION : Utiliser la feuille o√π le changement a eu lieu
    Set wsSource = Target.Worksheet
    
    ' D√©sactiver les √©v√©nements pour √©viter les boucles
    Application.EnableEvents = False
    
    ' Recalculer les cellules vides pour tous les caissons
    Call RecalculerCellulesVidesParCaisson(wsSource)
    
    ' R√©activer les √©v√©nements
    Application.EnableEvents = True
    
End Sub

' =====================================================
' SUB : Recalculer les cellules vides par caisson
' =====================================================
Sub RecalculerCellulesVidesParCaisson(ws As Worksheet)
    Dim maxParCaisson As Integer
    Dim derniereLigne As Long
    Dim i As Long
    Dim largeurActuelle As Integer
    Dim colonneVirtuelle As Integer
    Dim ligneVirtuelle As Integer
    Dim numeroCaisson As Integer
    Dim lettreCaisson As String
    Dim horsCapacitePermanent As Boolean
    Dim dictCaissonsLignes As Object ' Pour stocker la derni√®re ligne de chaque caisson
    Dim dictCaissonsVides As Object ' Pour stocker le nombre de cellules vides par caisson
    Dim codeCaisson As String
    Dim ligneDebutCaisson As Long
    
    ' R√©cup√©rer la valeur max par caisson
    maxParCaisson = val(ws.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4
    
    ' Cr√©er les dictionnaires
    Set dictCaissonsLignes = CreateObject("Scripting.Dictionary")
    Set dictCaissonsVides = CreateObject("Scripting.Dictionary")
    
    ' Initialiser les compteurs
    colonneVirtuelle = 1
    numeroCaisson = 1
    lettreCaisson = "A"
    horsCapacitePermanent = False
    derniereLigne = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    ligneDebutCaisson = 7
    
    ' Effacer d'abord toute la colonne W
    ws.Range("W7:W" & derniereLigne).ClearContents
    
    ' Parcourir toutes les lignes pour simuler la disposition
    For i = 7 To derniereLigne
        largeurActuelle = ConvertirEnEntier(ws.Cells(i, 7).Value, 0)
        
        ' Si on a une largeur > 0, c'est un bloc PDI
        If largeurActuelle > 0 Then
            ' V√©rifier si on d√©passe la colonne Z (26)
            If colonneVirtuelle + largeurActuelle - 1 > 26 Then
                ' Finaliser le caisson pr√©c√©dent
                codeCaisson = numeroCaisson & lettreCaisson
                If Not horsCapacitePermanent And Not CaissonDepasse(codeCaisson, maxParCaisson) Then
                    ' Calculer les cellules vides du caisson pr√©c√©dent
                    Dim cellulesVides As Integer
                    cellulesVides = 26 - colonneVirtuelle + 1
                    
                    ' Stocker dans le dictionnaire avec la derni√®re ligne du caisson
                    If ligneDebutCaisson > 0 Then
                        dictCaissonsVides.Add codeCaisson, cellulesVides
                        dictCaissonsLignes.Add codeCaisson, i - 1 ' Ligne pr√©c√©dente = derni√®re du caisson
                    End If
                End If
                
                ' Passer au caisson suivant
                colonneVirtuelle = 1
                numeroCaisson = numeroCaisson + 1
                ligneDebutCaisson = i
                
                ' G√©rer le passage √† la lettre suivante
                If numeroCaisson > maxParCaisson Then
                    numeroCaisson = 1
                    If lettreCaisson = "D" Then
                        horsCapacitePermanent = True
                        lettreCaisson = "A"
                    Else
                        lettreCaisson = Chr(Asc(lettreCaisson) + 1)
                        If lettreCaisson > "D" And Not horsCapacitePermanent Then
                            horsCapacitePermanent = True
                            lettreCaisson = "A"
                            numeroCaisson = 1
                        End If
                    End If
                End If
            End If
            
            ' Avancer la position virtuelle
            colonneVirtuelle = colonneVirtuelle + largeurActuelle
        End If
    Next i
    
    ' Finaliser le dernier caisson
    codeCaisson = numeroCaisson & lettreCaisson
    If Not horsCapacitePermanent And Not CaissonDepasse(codeCaisson, maxParCaisson) Then
        If colonneVirtuelle <= 26 Then
            cellulesVides = 26 - colonneVirtuelle + 1
            dictCaissonsVides.Add codeCaisson, cellulesVides
            dictCaissonsLignes.Add codeCaisson, derniereLigne
        End If
    End If
    
    ' Maintenant, √©crire les valeurs dans la colonne W seulement sur les derni√®res lignes de chaque caisson
    Dim cle As Variant
    For Each cle In dictCaissonsLignes.Keys
        Dim ligneCible As Long
        ligneCible = dictCaissonsLignes(cle)
        ws.Cells(ligneCible, 23).Value = dictCaissonsVides(cle) ' Colonne W = 23
    Next cle
    
End Sub

' =====================================================
' SUB : Ajuster la taille de police intelligemment selon contenu et largeur
' =====================================================
Sub AjusterTaillePoliceIntelligente(rng As Range, largeurCellule As Integer, contenu As String, estVoie As Boolean)
    Dim tailleOptimale As Integer
    Dim tailleMax As Integer
    Dim tailleMin As Integer
    Dim longueurMaxLigne As Integer
    Dim nbLignesEstimees As Integer
    
    ' D√©finir les limites de taille selon le type de contenu
    If estVoie Then
        ' Pour les noms de voies : plus de libert√©
        tailleMin = 6
        tailleMax = 28
    Else
        ' Pour les num√©ros PDI : plus conservateur
        tailleMin = 6
        tailleMax = 16
    End If
    
    ' Analyser le contenu et estimer la r√©partition des lignes
    Call AnalyserContenuAvecWrapText(contenu, largeurCellule, longueurMaxLigne, nbLignesEstimees)
    
    ' Calculer la taille optimale bas√©e sur l'espace disponible
    tailleOptimale = CalculerTailleOptimaleAvecWrap(largeurCellule, longueurMaxLigne, nbLignesEstimees, estVoie)
    
    ' Appliquer les limites
    If tailleOptimale < tailleMin Then tailleOptimale = tailleMin
    If tailleOptimale > tailleMax Then tailleOptimale = tailleMax
    
    ' Appliquer la taille
    With rng.Font
        .Size = tailleOptimale
    End With
End Sub

' =====================================================
' SUB : Analyser le contenu en tenant compte du WrapText - VERSION CONSERVATRICE
' =====================================================
Sub AnalyserContenuAvecWrapText(contenu As String, largeurCellule As Integer, ByRef longueurMaxLigne As Integer, ByRef nbLignesEstimees As Integer)
    Dim lignesExplicites As Variant
    Dim i As Integer, j As Integer
    Dim ligneActuelle As String
    Dim mots As Variant
    Dim longueurLigneActuelle As Integer
    Dim capaciteParLigne As Integer
    Dim lignesFinales As Collection
    
    ' Estimer la capacit√© de caract√®res par ligne selon la largeur - PLUS CONSERVATEUR
    ' R√©duction significative pour √©viter tout d√©bordement
    Select Case largeurCellule
        Case 1
            capaciteParLigne = 5   ' Tr√®s conservateur pour 1 colonne
        Case 2
            capaciteParLigne = 10  ' Conservateur pour 2 colonnes
        Case 3
            capaciteParLigne = 16  ' 3 colonnes
        Case 4
            capaciteParLigne = 22  ' 4 colonnes
        Case 5
            capaciteParLigne = 28  ' 5 colonnes
        Case Else
            capaciteParLigne = largeurCellule * 6  ' Formule conservatrice
    End Select
    
    Set lignesFinales = New Collection
    longueurMaxLigne = 0
    
    ' Si le contenu est vide, valeurs par d√©faut
    If Len(contenu) = 0 Then
        longueurMaxLigne = 1
        nbLignesEstimees = 1
        Exit Sub
    End If
    
    ' S√©parer d'abord par les sauts de ligne explicites (vbCrLf)
    If InStr(contenu, vbCrLf) > 0 Then
        lignesExplicites = Split(contenu, vbCrLf)
    Else
        ReDim lignesExplicites(0)
        lignesExplicites(0) = contenu
    End If
    
    ' Pour chaque ligne explicite, analyser le wrap automatique
    For i = 0 To UBound(lignesExplicites)
        ligneActuelle = Trim(lignesExplicites(i))
        
        ' Si la ligne est courte, pas de wrap n√©cessaire
        If Len(ligneActuelle) <= capaciteParLigne Then
            lignesFinales.Add ligneActuelle
            If Len(ligneActuelle) > longueurMaxLigne Then
                longueurMaxLigne = Len(ligneActuelle)
            End If
        Else
            ' La ligne est trop longue, simuler le wrap par mots
            mots = Split(ligneActuelle, " ")
            Dim ligneEnCours As String
            ligneEnCours = ""
            
            For j = 0 To UBound(mots)
                ' Tester si on peut ajouter le mot suivant
                Dim ligneTest As String
                If ligneEnCours = "" Then
                    ligneTest = mots(j)
                Else
                    ligneTest = ligneEnCours & " " & mots(j)
                End If
                
                ' Si √ßa rentre encore, continuer
                If Len(ligneTest) <= capaciteParLigne Then
                    ligneEnCours = ligneTest
                Else
                    ' Finir la ligne actuelle et commencer une nouvelle
                    If ligneEnCours <> "" Then
                        lignesFinales.Add ligneEnCours
                        If Len(ligneEnCours) > longueurMaxLigne Then
                            longueurMaxLigne = Len(ligneEnCours)
                        End If
                    End If
                    ligneEnCours = mots(j)
                End If
            Next j
            
            ' Ajouter la derni√®re ligne en cours
            If ligneEnCours <> "" Then
                lignesFinales.Add ligneEnCours
                If Len(ligneEnCours) > longueurMaxLigne Then
                    longueurMaxLigne = Len(ligneEnCours)
                End If
            End If
        End If
    Next i
    
    ' R√©sultats finaux
    nbLignesEstimees = lignesFinales.Count
    If longueurMaxLigne = 0 Then longueurMaxLigne = 1
    
End Sub

' =====================================================
' FONCTION : Calculer la taille optimale avec WrapText - VERSION S√âCURIS√âE
' =====================================================
Function CalculerTailleOptimaleAvecWrap(largeurCellule As Integer, longueurMaxLigne As Integer, nbLignesEstimees As Integer, estVoie As Boolean) As Integer
    Dim espaceHorizontal As Double
    Dim espaceVertical As Double
    Dim tailleParLargeur As Integer
    Dim tailleParHauteur As Integer
    Dim tailleOptimale As Integer
    Dim margeSecurite As Double
    
    ' Marges de s√©curit√© pour √©viter tout d√©bordement
    margeSecurite = 0.7  ' Utiliser seulement 70% de l'espace estim√©
    
    ' Estimer l'espace horizontal disponible - PLUS CONSERVATEUR
    espaceHorizontal = largeurCellule * 20 * margeSecurite ' R√©duit de 25 √† 20 pixels
    
    ' Estimer l'espace vertical disponible - PLUS CONSERVATEUR
    If estVoie Then
        espaceVertical = 35 * margeSecurite ' R√©duit de 39 √† 35
    Else
        espaceVertical = 43 * margeSecurite ' R√©duit de 48.75 √† 43
    End If
    
    ' Calculer la taille optimale selon la largeur (contrainte horizontale)
    If longueurMaxLigne > 0 Then
        tailleParLargeur = Int(espaceHorizontal / (longueurMaxLigne * 1.6)) ' Augment√© de 1.3 √† 1.6
    Else
        tailleParLargeur = 8
    End If
    
    ' Calculer la taille optimale selon la hauteur (contrainte verticale)
    If nbLignesEstimees > 0 Then
        tailleParHauteur = Int(espaceVertical / (nbLignesEstimees * 1.8)) ' Augment√© de 1.4 √† 1.8
    Else
        tailleParHauteur = 8
    End If
    
    ' Prendre la contrainte la plus restrictive
    tailleOptimale = Application.WorksheetFunction.Min(tailleParLargeur, tailleParHauteur)
    
    ' Limites absolues de s√©curit√©
    If estVoie Then
        ' Pour les voies : limites plus strictes
        Select Case largeurCellule
            Case 1
                If tailleOptimale > 7 Then tailleOptimale = 7   ' Max tr√®s bas pour 1 col
                If tailleOptimale < 6 Then tailleOptimale = 6
            Case 2
                If tailleOptimale > 9 Then tailleOptimale = 9   ' Max bas pour 2 col
                If tailleOptimale < 7 Then tailleOptimale = 7
            Case 3
                If tailleOptimale > 11 Then tailleOptimale = 11
                If tailleOptimale < 8 Then tailleOptimale = 8
            Case 4
                If tailleOptimale > 13 Then tailleOptimale = 13
                If tailleOptimale < 9 Then tailleOptimale = 9
            Case Else
                If tailleOptimale > 16 Then tailleOptimale = 16
                If tailleOptimale < 10 Then tailleOptimale = 10
        End Select
    Else
        ' Pour les num√©ros : encore plus conservateur
        Select Case largeurCellule
            Case 1
                If tailleOptimale > 6 Then tailleOptimale = 6   ' Max tr√®s bas
                If tailleOptimale < 6 Then tailleOptimale = 6
            Case 2
                If tailleOptimale > 8 Then tailleOptimale = 8
                If tailleOptimale < 6 Then tailleOptimale = 6
            Case 3
                If tailleOptimale > 10 Then tailleOptimale = 10
                If tailleOptimale < 7 Then tailleOptimale = 7
            Case Else
                If tailleOptimale > 12 Then tailleOptimale = 12
                If tailleOptimale < 8 Then tailleOptimale = 8
        End Select
    End If
    
    CalculerTailleOptimaleAvecWrap = tailleOptimale
End Function

' =====================================================
' SUB : Ajuster la taille de police selon la largeur de cellule - VERSION S√âCURIS√âE
' =====================================================
Sub AjusterTaillePoliceSelonLargeur(rng As Range, largeurCellule As Integer)
    ' Cette fonction est maintenant un wrapper pour la version intelligente
    ' On analyse le contenu de la cellule de mani√®re s√©curis√©e
    Dim contenu As String
    Dim valeurCellule As Variant
    
    ' R√©cup√©ration s√©curis√©e du contenu
    On Error Resume Next
    valeurCellule = rng.Value
    If Err.Number <> 0 Or IsNull(valeurCellule) Or IsEmpty(valeurCellule) Then
        contenu = ""
        Err.Clear
    Else
        contenu = CStr(valeurCellule)
    End If
    On Error GoTo 0
    
    Call AjusterTaillePoliceIntelligente(rng, largeurCellule, contenu, False) ' False = num√©ros PDI
End Sub

' =====================================================
' SUB : Ajuster la taille de police pour les noms de voies - VERSION S√âCURIS√âE
' =====================================================
Sub AjusterTaillePoliceVoiesSelonLargeur(rng As Range, largeurCellule As Integer)
    ' Cette fonction est maintenant un wrapper pour la version intelligente
    ' On analyse le contenu de la cellule de mani√®re s√©curis√©e
    Dim contenu As String
    Dim valeurCellule As Variant
    
    ' R√©cup√©ration s√©curis√©e du contenu
    On Error Resume Next
    valeurCellule = rng.Value
    If Err.Number <> 0 Or IsNull(valeurCellule) Or IsEmpty(valeurCellule) Then
        contenu = ""
        Err.Clear
    Else
        contenu = CStr(valeurCellule)
    End If
    On Error GoTo 0
    
    Call AjusterTaillePoliceIntelligente(rng, largeurCellule, contenu, True) ' True = noms de voies
End Sub

' =====================================================
' SUB : Appliquer un formatage diff√©renci√© pour num√©ros et observations - SANS √âCRASER LES TAILLES
' =====================================================
Sub AppliquerFormatageDifferencie(rng As Range, symbole As String, numAccumule As String, obsAccumulees As String)
    Dim longueurNumeroAvecSymbole As Integer
    Dim debutObservations As Integer
    
    ' Calculer la longueur de la partie num√©ro + symbole
    longueurNumeroAvecSymbole = Len(symbole & numAccumule)
    
    ' V√©rifier qu'on a quelque chose √† formater
    If longueurNumeroAvecSymbole = 0 Then Exit Sub
    
    ' Formatage avec gestion d'erreur compl√®te
    On Error GoTo FormatageFallback
    
    ' Si pas d'observations, formater tout en gras
    If obsAccumulees = "" Then
        ' Tout le texte (symbole + num√©ro) en gras - SANS MODIFIER LA TAILLE
        rng.Characters(1, longueurNumeroAvecSymbole).Font.Bold = True
    Else
        ' Formater la partie num√©ro (symbole + num√©ro) : gras - SANS MODIFIER LA TAILLE
        rng.Characters(1, longueurNumeroAvecSymbole).Font.Bold = True
        
        ' Formater la partie observations (apr√®s le saut de ligne) : pas gras - SANS MODIFIER LA TAILLE
        debutObservations = longueurNumeroAvecSymbole + 2 ' +2 pour vbCrLf (saut de ligne)
        
        If Len(obsAccumulees) > 0 Then
            rng.Characters(debutObservations, Len(obsAccumulees)).Font.Bold = False
        End If
    End If
    
    On Error GoTo 0
    Exit Sub
    
FormatageFallback:
    ' En cas d'erreur, appliquer un formatage global simple - SANS MODIFIER LA TAILLE
    On Error Resume Next
    rng.Font.Bold = True
    On Error GoTo 0
    
End Sub

' =====================================================
' SUB MODIFI√âE : Ajouter les boutons avec macros int√©gr√©es - DISPOSITION VERTICALE COLONNE AC
' =====================================================
Sub AjouterBoutonsSeulement(wsFacade As Worksheet)
    Dim btn As Object
    Dim positionX As Double
    Dim espacement As Double
    Dim largeurBouton As Double
    Dim hauteurBouton As Double
    
    ' Supprimer les boutons existants s'ils existent
    Dim shp As Shape
    For Each shp In wsFacade.Shapes
        If shp.Type = msoFormControl Then shp.Delete
    Next shp
    
    ' Configuration de la disposition verticale en colonne AC
    positionX = wsFacade.Columns("AC").Left + 2  ' Position X en colonne AC avec petite marge
    largeurBouton = wsFacade.Columns("AC").Width + 80  ' Largeur adapt√©e √† la colonne moins marges
    hauteurBouton = 25  ' Hauteur standard des boutons
    espacement = 20     ' Espacement vertical entre les boutons
    
    ' BOUTON 1 : Optimiser Affichage
    Set btn = wsFacade.Buttons.Add(positionX, 10, largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "1. Supprimer contenu voies uniques"
        .OnAction = "OptimiserAffichageFromButton"
        .Font.Bold = True
        .Font.Size = 9
    End With
    
    ' BOUTON 2 : Ins√©rer Images
    Set btn = wsFacade.Buttons.Add(positionX, 10 + (espacement * 2), largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "2. Ins√©rer Images voies uniques"
        .OnAction = "InsererImagesFromButton"
        .Font.Bold = True
        .Font.Size = 9
    End With
        
    ' BOUTON 3 : Simplifier Bornes
    Set btn = wsFacade.Buttons.Add(positionX, 10 + (espacement * 4), largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "3. Simplifier Bornes"
        .OnAction = "SimplifierBornesFromButton"
        .Font.Bold = True
        .Font.Size = 9
    End With
    
     ' BOUTON 4 : Ajuster Polices Intelligentes
    Set btn = wsFacade.Buttons.Add(positionX, 10 + (espacement * 6), largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "4. Ajuster taille polices"
        .OnAction = "AjusterPolicesFromButton"
        .Font.Bold = True
        .Font.Size = 9
    End With
    
End Sub

' =====================================================
' NOUVELLES MACROS POUR LES BOUTONS
' =====================================================

Sub OptimiserAffichageFromButton()
    ' Macro appel√©e par le bouton "Optimiser Affichage"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' V√©rifier qu'on est sur la bonne feuille
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit √™tre utilis√©e sur une feuille fa√ßade", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant ex√©cution
    If MsgBox("Voulez-vous optimiser l'affichage de la fa√ßade ?" & vbCrLf & _
              "Cette action va supprimer les num√©ros uniques pour simplifier la vue.", _
              vbQuestion + vbYesNo, "Optimiser Affichage") = vbYes Then
        
        ' Ex√©cuter la macro d'optimisation
        Call OptimiserAffichageFacade
    End If
End Sub

Sub SimplifierBornesFromButton()
    ' Macro appel√©e par le bouton "Simplifier Bornes"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' V√©rifier qu'on est sur la bonne feuille
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit √™tre utilis√©e sur une feuille fa√ßade", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant ex√©cution
    If MsgBox("Voulez-vous simplifier les bornes de num√©ros ?" & vbCrLf & _
              "Cette action va regrouper les num√©ros cons√©cutifs en plages.", _
              vbQuestion + vbYesNo, "Simplifier Bornes") = vbYes Then
        
        ' Ex√©cuter la macro de simplification des bornes
        Call SimplificationBornesNumPDI
    End If
End Sub

Sub AjusterPolicesFromButton()
    ' Macro appel√©e par le bouton "Ajuster Polices"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' V√©rifier qu'on est sur la bonne feuille
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit √™tre utilis√©e sur une feuille fa√ßade", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant ex√©cution
    If MsgBox("Voulez-vous ajuster automatiquement la taille des polices ?" & vbCrLf & _
              "Cette action va optimiser la lisibilit√© selon la taille des cellules.", _
              vbQuestion + vbYesNo, "Ajuster Polices") = vbYes Then
        
        ' Ex√©cuter la macro d'ajustement des polices
        Call AjusterTaillePolice
    End If
End Sub

Sub InsererImagesFromButton()
    ' Macro appel√©e par le bouton "Ins√©rer Images"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' V√©rifier qu'on est sur la bonne feuille
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit √™tre utilis√©e sur une feuille fa√ßade", vbExclamation
        Exit Sub
    End If
    
    ' Message d'information et confirmation
    If MsgBox("Voulez-vous ins√©rer des images dans les cellules vides ?" & vbCrLf & _
              "Vous devrez s√©lectionner un fichier image √† utiliser.", _
              vbQuestion + vbYesNo, "Ins√©rer Images") = vbYes Then
        
        ' Ex√©cuter la macro d'insertion d'images
        Call InsererImagesDansCellulesVides
    End If
End Sub

' =====================================================
' FONCTION CORRIG√âE : V√©rifier si un caisson d√©passe la limite
' =====================================================
Function CaissonDepasse(codeCaisson As String, maxParCaisson As Integer) As Boolean
    ' Extraire le num√©ro et la lettre du code caisson
    ' Format : "1A", "2B", etc.
    Dim numero As Integer
    Dim lettre As String
    
    If Len(codeCaisson) >= 2 Then
        numero = val(Left(codeCaisson, Len(codeCaisson) - 1))
        lettre = Right(codeCaisson, 1)
        
        ' LOGIQUE CORRIG√âE : on d√©passe si on est au-del√† de [maxParCaisson]D
        ' Exemples avec maxParCaisson = 7 :
        ' - 1A √† 7D : OK (dans la capacit√©)
        ' - 8D, 9D, etc. : D√âPASSE (hors capacit√©)
        ' - 1E, 2E, etc. : D√âPASSE (lettre apr√®s D)
        
        If lettre > "D" Then
            ' Toute lettre apr√®s D d√©passe automatiquement
            CaissonDepasse = True
        ElseIf lettre = "D" And numero > maxParCaisson Then
            ' Pour la lettre D, on d√©passe si le num√©ro > maxParCaisson
            CaissonDepasse = True
        Else
            ' Dans tous les autres cas, c'est dans la capacit√©
            CaissonDepasse = False
        End If
    Else
        CaissonDepasse = False
    End If
End Function

' =====================================================
' SUB AM√âLIOR√âE : Mettre √† jour la colonne H avec couleur
' =====================================================
Sub MettreAJourColonneHAvecCouleur(wsSource As Worksheet, dictCodes As Object, dictHorsCapacite As Object)
    Dim Ligne As Long
    Dim cle As Variant
    
    ' Parcourir toutes les cl√©s du dictionnaire (num√©ros de ligne)
    For Each cle In dictCodes.Keys
        Ligne = CLng(cle)
        
        ' Mettre √† jour la colonne H (colonne 8) avec le code calcul√©
        wsSource.Cells(Ligne, 8).Value = dictCodes(cle)
        
        ' Si cette ligne est hors capacit√©, la colorer en rouge
        If dictHorsCapacite.Exists(Ligne) Then
            With wsSource.Cells(Ligne, 8)
                .Interior.Color = RGB(255, 0, 0) ' Fond rouge
                .Font.Color = RGB(255, 255, 255) ' Texte blanc
                .Font.Bold = True
            End With
        Else
            ' R√©initialiser le formatage pour les cases normales
            With wsSource.Cells(Ligne, 8)
                .Interior.Pattern = xlNone ' Pas de couleur de fond
                .Font.Color = RGB(0, 0, 0) ' Texte noir
                .Font.Bold = False
            End With
        End If
    Next cle
End Sub

' =====================================================
' SUB : Mettre √† jour les cellules vides dans la feuille source - MODIFI√âE POUR DERNI√àRE LIGNE PAR CAISSON
' =====================================================
Sub MettreAJourCellulesVides(wsSource As Worksheet, wsFacade As Worksheet, colonneMiseAJour As String)
    ' Utiliser la nouvelle logique de calcul par caisson
    Call RecalculerCellulesVidesParCaisson(wsSource)
End Sub

' =====================================================
' FONCTION : Abr√©ger les types de voies
' =====================================================
Function AbregerTypeVoie(nomVoie As String) As String
    Dim result As String
    result = nomVoie
    
    ' Remplacer les types de voies par leurs abr√©viations
    ' Ordre important : les plus longs d'abord pour √©viter les conflits
    result = Replace(result, "Chemin de Grande communication", "CHDG", , , vbTextCompare)
    result = Replace(result, "Chemin de Liaison", "CHDL", , , vbTextCompare)
    result = Replace(result, "Chemin de Petite transport", "CRPT", , , vbTextCompare)
    result = Replace(result, "Impasse en cul-de-sac", "IMP-CUL", , , vbTextCompare)
    result = Replace(result, "Prolongement", "PROL", , , vbTextCompare)
    result = Replace(result, "Boulevard", "BD", , , vbTextCompare)
    result = Replace(result, "Avenue", "AV", , , vbTextCompare)
    result = Replace(result, "Route", "RTE", , , vbTextCompare)
    result = Replace(result, "Impasse", "IMP", , , vbTextCompare)
    result = Replace(result, "Chemin", "CH", , , vbTextCompare)
    result = Replace(result, "Place", "PL", , , vbTextCompare)
    result = Replace(result, "All√©e", "ALL", , , vbTextCompare)
    result = Replace(result, "Square", "SQ", , , vbTextCompare)
    result = Replace(result, "Voie", "V", , , vbTextCompare)
    result = Replace(result, "Quai", "QU", , , vbTextCompare)
    result = Replace(result, "Passage", "PSG", , , vbTextCompare)
    result = Replace(result, "Sentier", "SENT", , , vbTextCompare)
    result = Replace(result, "Travers√©e", "TR", , , vbTextCompare)
    result = Replace(result, "Lotissement", "LOT", , , vbTextCompare)
    result = Replace(result, "R√©sidence", "RES", , , vbTextCompare)
    result = Replace(result, "Cit√©", "CIT", , , vbTextCompare)
    result = Replace(result, "Hameau", "H", , , vbTextCompare)
    result = Replace(result, "Parc", "PARC", , , vbTextCompare)
    result = Replace(result, "P√¢ture", "PAT", , , vbTextCompare)
    result = Replace(result, "Petite rue", "PTE", , , vbTextCompare)
    result = Replace(result, "Galerie", "GAL", , , vbTextCompare)
    result = Replace(result, "Places", "PL", , , vbTextCompare)
    result = Replace(result, "Ruelle", "RLE", , , vbTextCompare)
    result = Replace(result, "Promenade", "PR", , , vbTextCompare)
    result = Replace(result, "Esplanade", "ESPL", , , vbTextCompare)
    result = Replace(result, "Pont", "PT", , , vbTextCompare)
    result = Replace(result, "Vall√©e", "VAL", , , vbTextCompare)
    result = Replace(result, "Val", "VAL", , , vbTextCompare)
    
    ' G√©rer les cas avec "de", "du", "des", "de la"
    result = Replace(result, " de la ", " ", , , vbTextCompare)
    result = Replace(result, " du ", " ", , , vbTextCompare)
    result = Replace(result, " des ", " ", , , vbTextCompare)
    result = Replace(result, " de ", " ", , , vbTextCompare)
    result = Replace(result, " d'", " ", , , vbTextCompare)
    
    ' Nettoyer les espaces doubles
    Do While InStr(result, "  ") > 0
        result = Replace(result, "  ", " ")
    Loop
    
    AbregerTypeVoie = Trim(result)
End Function

' =====================================================
' SUB : Ajouter le code caisson en colonne AA
' =====================================================
Sub AjouterCodeCaisson(ws As Worksheet, Ligne As Long, code As String)
    Dim rngCode As Range
    
    ' Fusionner les 2 lignes en colonne AA
    Set rngCode = ws.Range(ws.Cells(Ligne, 27), ws.Cells(Ligne + 1, 27))
    rngCode.Merge
    
    ' Ajouter le code
    With rngCode
        .NumberFormat = "@" ' Format texte
        .Value = code
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .Font.Bold = True
        .Font.Size = 12
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin ' Bordures simples
        
        ' Si c'est "HC", colorer en rouge
        If code = "HC" Then
            .Interior.Color = RGB(255, 0, 0) ' Fond rouge
            .Font.Color = RGB(255, 255, 255) ' Texte blanc
        Else
            .Interior.Pattern = xlNone ' Pas de couleur
            .Font.Color = RGB(0, 0, 0) ' Texte noir
        End If
    End With
End Sub

' =====================================================
' FONCTION : Conversion s√©curis√©e en entier
' =====================================================
Function ConvertirEnEntier(valeur As Variant, valeurParDefaut As Integer) As Integer
    On Error Resume Next
    ConvertirEnEntier = CInt(valeur)
    If Err.Number <> 0 Then
        ConvertirEnEntier = valeurParDefaut
        Err.Clear
    End If
    On Error GoTo 0
End Function

' =====================================================
' SUB : Fusionner les cellules adjacentes avec m√™me nom de voie
' =====================================================
Sub FusionnerVoiesAdjacentes(ws As Worksheet)
    Dim ligneVoie As Long
    Dim col As Long, colDebut As Long
    Dim nomVoieActuel As String, nomVoieSuivant As String
    Dim rngFusion As Range
    Dim derniereLigne As Long
    Dim derniereColonne As Long
    Dim couleurIndex As Long
    Dim couleurTexte As Long
    
    ' Trouver les limites de la feuille utilis√©e
    derniereLigne = ws.UsedRange.Rows.Count
    derniereColonne = 26 ' S'arr√™ter √† la colonne Z
    
    ' Parcourir toutes les lignes de noms de voies (lignes 2, 4, 6, etc.)
    For ligneVoie = 2 To derniereLigne Step 2
        col = 1
        
        ' Parcourir les colonnes de cette ligne
        Do While col <= derniereColonne
            ' Ignorer les cellules vides
            If ws.Cells(ligneVoie, col).Value = "" Then
                col = col + 1
            Else
                ' R√©cup√©rer le nom de voie actuel (sans slash pour comparaison)
                nomVoieActuel = Trim(ws.Cells(ligneVoie, col).Value)
                
                ' Extraire le nom de voie sans le cercle blanc pour la comparaison
                Dim nomVoieComparaison As String
                If Left(nomVoieActuel, 1) = ChrW(&H25CB) Then
                    ' Enlever le cercle blanc et l'espace qui suit pour la comparaison
                    nomVoieComparaison = Trim(Mid(nomVoieActuel, 3))
                Else
                    nomVoieComparaison = nomVoieActuel
                End If
                
                ' Si c'est une voie multiple, ne pas fusionner
                If InStr(nomVoieComparaison, " / ") > 0 Then
                    ' Passer √† la cellule suivante sans fusionner
                    If ws.Cells(ligneVoie, col).MergeCells Then
                        col = ws.Cells(ligneVoie, col).MergeArea.Column + _
                              ws.Cells(ligneVoie, col).MergeArea.Columns.Count
                    Else
                        col = col + 1
                    End If
                Else
                    ' Proc√©der √† la fusion normale pour les voies simples
                    colDebut = col
                    
                    ' M√©moriser la couleur et v√©rifier si c'est rouge (hors capacit√©)
                    Dim estRouge As Boolean
                    estRouge = False
                    If ws.Cells(ligneVoie, col).Interior.Color = RGB(255, 0, 0) Then
                        estRouge = True
                        couleurIndex = xlNone ' On utilisera le rouge directement
                        couleurTexte = RGB(255, 255, 255)
                    ElseIf ws.Cells(ligneVoie, col).Interior.ColorIndex <> xlNone Then
                        couleurIndex = ws.Cells(ligneVoie, col).Interior.ColorIndex
                        couleurTexte = ws.Cells(ligneVoie, col).Font.Color
                    Else
                        couleurIndex = xlNone
                    End If
                    
                    ' Trouver la fin de la cellule fusionn√©e actuelle
                    If ws.Cells(ligneVoie, col).MergeCells Then
                        col = ws.Cells(ligneVoie, col).MergeArea.Column + _
                              ws.Cells(ligneVoie, col).MergeArea.Columns.Count - 1
                    End If
                    
                    ' V√©rifier les cellules suivantes pour le m√™me nom de voie
                    Do While col < derniereColonne
                        ' V√©rifier la cellule suivante
                        If ws.Cells(ligneVoie, col + 1).Value = "" Then
                            Exit Do
                        End If
                        
                        nomVoieSuivant = Trim(ws.Cells(ligneVoie, col + 1).Value)
                        
                        ' Extraire le nom de voie sans le cercle blanc pour la comparaison
                        Dim nomVoieSuivantComparaison As String
                        If Left(nomVoieSuivant, 1) = ChrW(&H25CB) Then
                            ' Enlever le cercle blanc et l'espace qui suit pour la comparaison
                            nomVoieSuivantComparaison = Trim(Mid(nomVoieSuivant, 3))
                        Else
                            nomVoieSuivantComparaison = nomVoieSuivant
                        End If
                        
                        ' Ne pas fusionner si la cellule suivante contient des voies multiples
                        If InStr(nomVoieSuivantComparaison, " / ") > 0 Then
                            Exit Do
                        End If
                        
                        ' Si c'est le m√™me nom de voie (en ignorant le cercle blanc), √©tendre la fusion
                        If nomVoieComparaison = nomVoieSuivantComparaison And nomVoieComparaison <> "" Then
                            ' Trouver la fin de la cellule suivante
                            If ws.Cells(ligneVoie, col + 1).MergeCells Then
                                col = ws.Cells(ligneVoie, col + 1).MergeArea.Column + _
                                      ws.Cells(ligneVoie, col + 1).MergeArea.Columns.Count - 1
                            Else
                                col = col + 1
                            End If
                        Else
                            Exit Do
                        End If
                    Loop
                    
                    ' Si on a trouv√© plusieurs cellules adjacentes avec le m√™me nom
                    If col > colDebut Then
                        ' D√©fusionner d'abord toutes les cellules concern√©es
                        For i = colDebut To col
                            If ws.Cells(ligneVoie, i).MergeCells Then
                                ws.Cells(ligneVoie, i).MergeArea.UnMerge
                            End If
                        Next i
                        
                        ' Refusionner l'ensemble
                        Set rngFusion = ws.Range(ws.Cells(ligneVoie, colDebut), ws.Cells(ligneVoie, col))
                        rngFusion.Merge
                        
                        ' R√©appliquer le formatage avec le nom abr√©g√© et le cercle blanc si n√©cessaire
                        Dim texteVoieFusionne As String
                        ' V√©rifier si le texte original contenait un cercle blanc
                        If InStr(nomVoieActuel, ChrW(&H25CB)) > 0 Then
                            texteVoieFusionne = ChrW(&H25CB) & " " & AbregerTypeVoie(nomVoieComparaison)
                        Else
                            texteVoieFusionne = AbregerTypeVoie(nomVoieComparaison)
                        End If
                        
                        With rngFusion
                            .NumberFormat = "@" ' Format texte
                            .Value = texteVoieFusionne
                            .HorizontalAlignment = xlCenter
                            .VerticalAlignment = xlCenter
                            .Font.Bold = True
                            .WrapText = True
                            .Borders.LineStyle = xlContinuous
                            .Borders.Weight = xlThin ' Bordures simples pour la fusion
                            
                            ' Souligner si c'√©tait une voie multiple
                            If InStr(nomVoieActuel, ChrW(&H25CB)) > 0 Then
                                .Font.Underline = xlUnderlineStyleSingle
                            End If
                            
                            ' Appliquer la couleur appropri√©e
                            If estRouge Then
                                .Interior.Color = RGB(255, 0, 0) ' Rouge pour hors capacit√©
                                .Font.Color = RGB(255, 255, 255) ' Texte blanc
                            ElseIf couleurIndex <> xlNone Then
                                .Interior.ColorIndex = couleurIndex
                                .Font.Color = couleurTexte
                            End If
                        End With
                        
                        ' APPLIQUER LA TAILLE DE POLICE OPTIMIS√âE POUR LES VOIES FUSIONN√âES
                        Call AjusterTaillePoliceVoiesSelonLargeur(rngFusion, col - colDebut + 1)
                    End If
                    
                    col = col + 1
                End If
            End If
        Loop
    Next ligneVoie
End Sub

' =====================================================
' GESTION DES COULEURS √âTENDUES
' =====================================================

' Initialise une palette de couleurs √©tendues avec 150+ couleurs distinctes
Sub InitialiserPaletteCouleursEtendues(dictPalette As Object)
    Dim i As Integer
    i = 0
    
    ' S√âRIE 1: COULEURS VIVES ET CONTRAST√âES (20 couleurs)
    dictPalette.Add i, RGB(255, 87, 87):   i = i + 1  ' Rouge corail
    dictPalette.Add i, RGB(255, 183, 77):  i = i + 1  ' Orange dor√©
    dictPalette.Add i, RGB(255, 235, 59):  i = i + 1  ' Jaune vif
    dictPalette.Add i, RGB(139, 195, 74):  i = i + 1  ' Vert lime
    dictPalette.Add i, RGB(38, 166, 154):  i = i + 1  ' Vert √©meraude
    dictPalette.Add i, RGB(41, 182, 246):  i = i + 1  ' Bleu cyan
    dictPalette.Add i, RGB(92, 107, 192):  i = i + 1  ' Indigo
    dictPalette.Add i, RGB(186, 104, 200): i = i + 1  ' Violet
    dictPalette.Add i, RGB(240, 98, 146):  i = i + 1  ' Rose fuchsia
    dictPalette.Add i, RGB(255, 138, 101): i = i + 1  ' Saumon
    dictPalette.Add i, RGB(78, 175, 79):   i = i + 1  ' Vert for√™t
    dictPalette.Add i, RGB(3, 169, 244):   i = i + 1  ' Bleu ciel
    dictPalette.Add i, RGB(156, 39, 176):  i = i + 1  ' Pourpre
    dictPalette.Add i, RGB(255, 87, 34):   i = i + 1  ' Orange rouge
    dictPalette.Add i, RGB(205, 220, 57):  i = i + 1  ' Jaune vert
    dictPalette.Add i, RGB(0, 188, 212):   i = i + 1  ' Turquoise
    dictPalette.Add i, RGB(103, 58, 183):  i = i + 1  ' Violet profond
    dictPalette.Add i, RGB(233, 30, 99):   i = i + 1  ' Rose vif
    dictPalette.Add i, RGB(121, 85, 72):   i = i + 1  ' Brun
    dictPalette.Add i, RGB(84, 110, 122):  i = i + 1  ' Bleu gris
    
    ' S√âRIE 2: COULEURS PASTEL DISTINCTIVES (20 couleurs)
    dictPalette.Add i, RGB(255, 205, 210): i = i + 1  ' Rose p√¢le
    dictPalette.Add i, RGB(255, 224, 178): i = i + 1  ' P√™che
    dictPalette.Add i, RGB(255, 249, 196): i = i + 1  ' Jaune pastel
    dictPalette.Add i, RGB(220, 237, 200): i = i + 1  ' Vert menthe
    dictPalette.Add i, RGB(178, 223, 219): i = i + 1  ' Vert d'eau
    dictPalette.Add i, RGB(187, 222, 251): i = i + 1  ' Bleu clair
    dictPalette.Add i, RGB(209, 196, 233): i = i + 1  ' Lavande
    dictPalette.Add i, RGB(248, 187, 208): i = i + 1  ' Rose poudr√©e
    dictPalette.Add i, RGB(255, 204, 188): i = i + 1  ' Abricot
    dictPalette.Add i, RGB(200, 230, 201): i = i + 1  ' Vert tendre
    dictPalette.Add i, RGB(179, 229, 252): i = i + 1  ' Bleu poudr√©e
    dictPalette.Add i, RGB(225, 190, 231): i = i + 1  ' Mauve clair
    dictPalette.Add i, RGB(255, 171, 145): i = i + 1  ' Corail clair
    dictPalette.Add i, RGB(240, 244, 195): i = i + 1  ' Citron vert
    dictPalette.Add i, RGB(204, 255, 229): i = i + 1  ' Menthe glac√©e
    dictPalette.Add i, RGB(191, 239, 255): i = i + 1  ' Bleu glac√©
    dictPalette.Add i, RGB(228, 187, 255): i = i + 1  ' Violet clair
    dictPalette.Add i, RGB(255, 194, 209): i = i + 1  ' Rose saumon
    dictPalette.Add i, RGB(215, 204, 200): i = i + 1  ' Beige ros√©
    dictPalette.Add i, RGB(207, 216, 220): i = i + 1  ' Gris bleut√©
    
    ' S√âRIE 3: COULEURS MOYENNES BIEN CONTRAST√âES (30 couleurs)
    dictPalette.Add i, RGB(244, 67, 54):   i = i + 1  ' Rouge Material
    dictPalette.Add i, RGB(233, 30, 99):   i = i + 1  ' Pink Material
    dictPalette.Add i, RGB(156, 39, 176):  i = i + 1  ' Purple Material
    dictPalette.Add i, RGB(103, 58, 183):  i = i + 1  ' Deep Purple
    dictPalette.Add i, RGB(63, 81, 181):   i = i + 1  ' Indigo Material
    dictPalette.Add i, RGB(33, 150, 243):  i = i + 1  ' Blue Material
    dictPalette.Add i, RGB(3, 169, 244):   i = i + 1  ' Light Blue
    dictPalette.Add i, RGB(0, 188, 212):   i = i + 1  ' Cyan Material
    dictPalette.Add i, RGB(0, 150, 136):   i = i + 1  ' Teal Material
    dictPalette.Add i, RGB(76, 175, 80):   i = i + 1  ' Green Material
    dictPalette.Add i, RGB(139, 195, 74):  i = i + 1  ' Light Green
    dictPalette.Add i, RGB(205, 220, 57):  i = i + 1  ' Lime Material
    dictPalette.Add i, RGB(255, 235, 59):  i = i + 1  ' Yellow Material
    dictPalette.Add i, RGB(255, 193, 7):   i = i + 1  ' Amber Material
    dictPalette.Add i, RGB(255, 152, 0):   i = i + 1  ' Orange Material
    dictPalette.Add i, RGB(255, 87, 34):   i = i + 1  ' Deep Orange
    dictPalette.Add i, RGB(121, 85, 72):   i = i + 1  ' Brown Material
    dictPalette.Add i, RGB(158, 158, 158): i = i + 1  ' Grey Material
    dictPalette.Add i, RGB(96, 125, 139):  i = i + 1  ' Blue Grey
    dictPalette.Add i, RGB(255, 112, 67):  i = i + 1  ' Orange vif
    dictPalette.Add i, RGB(174, 213, 129): i = i + 1  ' Vert clair vif
    dictPalette.Add i, RGB(100, 181, 246): i = i + 1  ' Bleu moyen
    dictPalette.Add i, RGB(149, 117, 205): i = i + 1  ' Violet moyen
    dictPalette.Add i, RGB(240, 113, 120): i = i + 1  ' Rose corail
    dictPalette.Add i, RGB(255, 183, 77):  i = i + 1  ' Orange dor√©
    dictPalette.Add i, RGB(129, 212, 250): i = i + 1  ' Bleu clair vif
    dictPalette.Add i, RGB(206, 147, 216): i = i + 1  ' Violet ros√©
    dictPalette.Add i, RGB(255, 138, 128): i = i + 1  ' Rouge saumon
    dictPalette.Add i, RGB(185, 246, 202): i = i + 1  ' Vert menthe vif
    dictPalette.Add i, RGB(144, 202, 249): i = i + 1  ' Bleu pervenche
    
    ' S√âRIE 4: COULEURS FONC√âES CONTRAST√âES (30 couleurs)
    dictPalette.Add i, RGB(183, 28, 28):   i = i + 1  ' Rouge fonc√©
    dictPalette.Add i, RGB(136, 14, 79):   i = i + 1  ' Rose fonc√©
    dictPalette.Add i, RGB(74, 20, 140):   i = i + 1  ' Violet fonc√©
    dictPalette.Add i, RGB(49, 27, 146):   i = i + 1  ' Indigo fonc√©
    dictPalette.Add i, RGB(26, 35, 126):   i = i + 1  ' Bleu fonc√©
    dictPalette.Add i, RGB(13, 71, 161):   i = i + 1  ' Bleu profond
    dictPalette.Add i, RGB(1, 87, 155):    i = i + 1  ' Bleu clair fonc√©
    dictPalette.Add i, RGB(0, 96, 100):    i = i + 1  ' Cyan fonc√©
    dictPalette.Add i, RGB(0, 77, 64):     i = i + 1  ' Vert fonc√©
    dictPalette.Add i, RGB(27, 94, 32):    i = i + 1  ' Vert profond
    dictPalette.Add i, RGB(51, 105, 30):   i = i + 1  ' Vert olive
    dictPalette.Add i, RGB(130, 119, 23):  i = i + 1  ' Jaune olive
    dictPalette.Add i, RGB(245, 127, 23):  i = i + 1  ' Orange fonc√©
    dictPalette.Add i, RGB(191, 54, 12):   i = i + 1  ' Rouge orange
    dictPalette.Add i, RGB(62, 39, 35):    i = i + 1  ' Brun fonc√©
    dictPalette.Add i, RGB(69, 90, 100):   i = i + 1  ' Gris bleu fonc√©
    dictPalette.Add i, RGB(101, 31, 255):  i = i + 1  ' Violet √©lectrique
    dictPalette.Add i, RGB(0, 230, 118):   i = i + 1  ' Vert n√©on
    dictPalette.Add i, RGB(255, 61, 0):    i = i + 1  ' Rouge orange vif
    dictPalette.Add i, RGB(196, 0, 140):   i = i + 1  ' Magenta fonc√©
    dictPalette.Add i, RGB(0, 145, 234):   i = i + 1  ' Bleu √©lectrique
    dictPalette.Add i, RGB(67, 160, 71):   i = i + 1  ' Vert franc
    dictPalette.Add i, RGB(251, 140, 0):   i = i + 1  ' Orange amber
    dictPalette.Add i, RGB(124, 77, 255):  i = i + 1  ' Violet clair
    dictPalette.Add i, RGB(255, 23, 68):   i = i + 1  ' Rose vif
    dictPalette.Add i, RGB(0, 191, 255):   i = i + 1  ' Bleu ciel vif
    dictPalette.Add i, RGB(198, 255, 0):   i = i + 1  ' Vert lime vif
    dictPalette.Add i, RGB(255, 64, 129):  i = i + 1  ' Rose accent
    dictPalette.Add i, RGB(101, 187, 255): i = i + 1  ' Bleu accent
    dictPalette.Add i, RGB(178, 255, 89):  i = i + 1  ' Vert accent
    
    ' S√âRIE 5: COULEURS SP√âCIALES ET DISTINCTIVES (30 couleurs)
    dictPalette.Add i, RGB(132, 94, 194):  i = i + 1  ' Am√©thyste
    dictPalette.Add i, RGB(207, 106, 135): i = i + 1  ' Rose antique
    dictPalette.Add i, RGB(72, 133, 237):  i = i + 1  ' Bleu royal
    dictPalette.Add i, RGB(245, 166, 35):  i = i + 1  ' Miel
    dictPalette.Add i, RGB(126, 211, 33):  i = i + 1  ' Chartreuse
    dictPalette.Add i, RGB(202, 111, 30):  i = i + 1  ' Terre de Sienne
    dictPalette.Add i, RGB(21, 101, 192):  i = i + 1  ' Saphir
    dictPalette.Add i, RGB(162, 155, 254): i = i + 1  ' Pervenche
    dictPalette.Add i, RGB(255, 204, 0):   i = i + 1  ' Or
    dictPalette.Add i, RGB(0, 200, 83):    i = i + 1  ' √âmeraude vif
    dictPalette.Add i, RGB(213, 0, 249):   i = i + 1  ' Magenta √©lectrique
    dictPalette.Add i, RGB(0, 184, 169):   i = i + 1  ' Turquoise fonc√©
    dictPalette.Add i, RGB(255, 109, 0):   i = i + 1  ' Orange mandarine
    dictPalette.Add i, RGB(149, 69, 53):   i = i + 1  ' Acajou
    dictPalette.Add i, RGB(56, 142, 60):   i = i + 1  ' Vert sapin
    dictPalette.Add i, RGB(94, 53, 177):   i = i + 1  ' Violet byzantin
    dictPalette.Add i, RGB(239, 83, 80):   i = i + 1  ' Rouge tomate
    dictPalette.Add i, RGB(26, 188, 156):  i = i + 1  ' Turquoise clair
    dictPalette.Add i, RGB(255, 193, 7):   i = i + 1  ' Ambre
    dictPalette.Add i, RGB(142, 36, 170):  i = i + 1  ' Violet orchid√©e
    dictPalette.Add i, RGB(67, 56, 202):   i = i + 1  ' Indigo √©lectrique
    dictPalette.Add i, RGB(46, 204, 113):  i = i + 1  ' Vert menthe √©lectrique
    dictPalette.Add i, RGB(231, 76, 60):   i = i + 1  ' Rouge brique
    dictPalette.Add i, RGB(230, 126, 34):  i = i + 1  ' Carotte
    dictPalette.Add i, RGB(241, 196, 15):  i = i + 1  ' Tournesol
    dictPalette.Add i, RGB(155, 89, 182):  i = i + 1  ' Am√©thyste clair
    dictPalette.Add i, RGB(52, 152, 219):  i = i + 1  ' Bleu peter river
    dictPalette.Add i, RGB(22, 160, 133):  i = i + 1  ' Vert sea
    dictPalette.Add i, RGB(243, 156, 18):  i = i + 1  ' Orange soleil
    dictPalette.Add i, RGB(211, 84, 0):    i = i + 1  ' Orange fonc√© pumpkin
End Sub

' Obtient une couleur distincte pour une voie avec v√©rification d'adjacence (VERSION AM√âLIOR√âE)
Function ObtenirCouleurDistinctePourVoieAvecAdjacence(nomVoie As String, paletteCouleurs As Object, dictCouleursExistantes As Object, colonne As Long, ws As Worksheet, Ligne As Long) As Long
    Dim hashVoie As Long
    Dim i As Integer
    Dim indexCouleur As Integer
    Dim couleurCandidate As Long
    Dim couleurGauche As Long, couleurDroite As Long
    Dim tentatives As Integer
    Dim contraste As Double
    Dim contrastelimite As Double
    
    ' Seuil de contraste minimum (plus c'est √©lev√©, plus les couleurs doivent √™tre diff√©rentes)
    contrastelimite = 30000 ' Diff√©rence RGB minimum
    
    ' Calculer un hash bas√© sur le nom de la voie
    hashVoie = 0
    For i = 1 To Len(nomVoie)
        hashVoie = hashVoie + Asc(Mid(nomVoie, i, 1)) * i
    Next i
    
    ' Obtenir les couleurs des voies adjacentes
    couleurGauche = ObtenirCouleurVoieAdjacente(ws, Ligne, colonne - 1)
    couleurDroite = ObtenirCouleurVoieAdjacente(ws, Ligne, colonne + 1)
    
    ' Essayer de trouver une couleur avec suffisamment de contraste
    tentatives = 0
    Do
        ' Calculer l'index de couleur avec variation selon les tentatives
        indexCouleur = ((hashVoie + tentatives * 17) Mod paletteCouleurs.Count)
        If indexCouleur < 0 Then indexCouleur = indexCouleur + paletteCouleurs.Count
        
        couleurCandidate = paletteCouleurs(indexCouleur)
        
        ' V√©rifier le contraste avec les couleurs adjacentes
        Dim contrasteBon As Boolean
        contrasteBon = True
        
        If couleurGauche <> xlNone And couleurGauche <> 0 Then
            contraste = CalculerContrasteRGB(couleurCandidate, couleurGauche)
            If contraste < contrastelimite Then contrasteBon = False
        End If
        
        If couleurDroite <> xlNone And couleurDroite <> 0 And contrasteBon Then
            contraste = CalculerContrasteRGB(couleurCandidate, couleurDroite)
            If contraste < contrastelimite Then contrasteBon = False
        End If
        
        ' Si la couleur a suffisamment de contraste, l'utiliser
        If contrasteBon Then
            ObtenirCouleurDistinctePourVoieAvecAdjacence = couleurCandidate
            Exit Function
        End If
        
        tentatives = tentatives + 1
        
        ' Limiter les tentatives pour √©viter une boucle infinie
        If tentatives > 50 Then
            ' Utiliser une couleur de la s√©rie sp√©ciale haute diff√©renciation
            indexCouleur = (tentatives Mod 30) + 100 ' Utiliser la s√©rie 5 (couleurs sp√©ciales)
            If indexCouleur >= paletteCouleurs.Count Then indexCouleur = paletteCouleurs.Count - 1
            ObtenirCouleurDistinctePourVoieAvecAdjacence = paletteCouleurs(indexCouleur)
            Exit Function
        End If
    Loop
End Function

' Fonction utilitaire pour obtenir la couleur d'une voie adjacente
Function ObtenirCouleurVoieAdjacente(ws As Worksheet, Ligne As Long, colonne As Long) As Long
    On Error GoTo ErrorHandler
    
    ' V√©rifier que la colonne est dans les limites
    If colonne < 1 Or colonne > ws.Columns.Count Then
        ObtenirCouleurVoieAdjacente = xlNone
        Exit Function
    End If
    
    ' V√©rifier la cellule de voie (ligne + 1 pour la ligne des voies)
    Dim celluleVoie As Range
    Set celluleVoie = ws.Cells(Ligne + 1, colonne)
    
    ' Si la cellule contient une voie (pas vide, pas num√©rique)
    If Not IsEmpty(celluleVoie.Value) And Not IsNumeric(celluleVoie.Value) Then
        ObtenirCouleurVoieAdjacente = celluleVoie.Interior.Color
    Else
        ObtenirCouleurVoieAdjacente = xlNone
    End If
    
    Exit Function
    
ErrorHandler:
    ObtenirCouleurVoieAdjacente = xlNone
End Function

' Calcule le contraste entre deux couleurs RGB
Function CalculerContrasteRGB(couleur1 As Long, couleur2 As Long) As Double
    Dim r1 As Integer, g1 As Integer, b1 As Integer
    Dim r2 As Integer, g2 As Integer, b2 As Integer
    
    ' Extraire les composantes RGB de la premi√®re couleur
    r1 = couleur1 Mod 256
    g1 = (couleur1 \ 256) Mod 256
    b1 = (couleur1 \ 65536) Mod 256
    
    ' Extraire les composantes RGB de la seconde couleur
    r2 = couleur2 Mod 256
    g2 = (couleur2 \ 256) Mod 256
    b2 = (couleur2 \ 65536) Mod 256
    
    ' Calculer la distance euclidienne dans l'espace RGB
    CalculerContrasteRGB = Sqr((r1 - r2) ^ 2 + (g1 - g2) ^ 2 + (b1 - b2) ^ 2)
End Function

' Version RGB de la fonction ObtenirCouleurTexte
Function ObtenirCouleurTexteRGB(couleurFondRGB As Long) As Long
    Dim r As Integer, g As Integer, b As Integer
    Dim luminosite As Double
    
    ' Extraire les composantes RGB
    r = couleurFondRGB Mod 256
    g = (couleurFondRGB \ 256) Mod 256
    b = (couleurFondRGB \ 65536) Mod 256
    
    ' Calculer la luminosit√© (formule standard)
    luminosite = (0.299 * r + 0.587 * g + 0.114 * b) / 255
    
    ' Si la couleur est sombre, texte blanc, sinon texte noir
    If luminosite < 0.5 Then
        ObtenirCouleurTexteRGB = RGB(255, 255, 255) ' Blanc
    Else
        ObtenirCouleurTexteRGB = RGB(0, 0, 0) ' Noir
    End If
End Function

' =====================================================
' FONCTIONS DE DIAGNOSTIC ET TEST
' =====================================================

' Fonction de diagnostic pour afficher les couleurs attribu√©es
Sub AfficherDiagnosticCouleurs()
    Dim ws As Worksheet
    Dim i As Long
    Dim rapport As String
    Dim cellule As Range
    Dim nomVoie As String
    Dim couleur As Long
    Dim voiesTraitees As Object
    
    Set ws = ActiveSheet
    Set voiesTraitees = CreateObject("Scripting.Dictionary")
    
    If ws Is Nothing Then
        MsgBox "Aucune feuille active d√©tect√©e.", vbExclamation
        Exit Sub
    End If
    
    rapport = "DIAGNOSTIC DES COULEURS ATTRIBU√âES" & vbCrLf & vbCrLf
    
    ' Parcourir les cellules de voies (lignes paires)
    For Each cellule In ws.UsedRange
        If cellule.Row Mod 2 = 0 And Not IsEmpty(cellule.Value) Then ' Lignes paires (voies)
            nomVoie = Trim(CStr(cellule.Value))
            
            If nomVoie <> "" And Not IsNumeric(nomVoie) And Not voiesTraitees.Exists(nomVoie) Then
                couleur = cellule.Interior.Color
                
                If couleur <> xlNone And couleur <> RGB(255, 255, 255) Then
                    rapport = rapport & "Voie: " & nomVoie & vbCrLf
                    rapport = rapport & "  Couleur RGB: " & couleur & vbCrLf
                    rapport = rapport & "  Cellule: " & cellule.Address & vbCrLf & vbCrLf
                    
                    voiesTraitees.Add nomVoie, True
                End If
            End If
        End If
    Next cellule
    
    rapport = rapport & "Total de voies color√©es: " & voiesTraitees.Count
    
    MsgBox rapport, vbInformation, "Diagnostic Couleurs"
End Sub

' =====================================================
' MACROS UTILITAIRES COMPL√âMENTAIRES
' =====================================================

' MACRO UTILITAIRE : Ajuster param√®tres d'impression
Sub AjusterParametresImpression()
    ' Fonction utilitaire pour optimiser l'impression de la fa√ßade
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Configuration de l'impression
    With ws.PageSetup
        .Orientation = xlLandscape
        .FitToPagesWide = 1
        .FitToPagesTall = False
        .CenterHorizontally = True
        .CenterVertically = False
        .PrintArea = "A1:AA" & ws.UsedRange.Rows.Count
        .LeftMargin = Application.InchesToPoints(0.25)
        .RightMargin = Application.InchesToPoints(0.25)
        .TopMargin = Application.InchesToPoints(0.25)
        .BottomMargin = Application.InchesToPoints(0.25)
        .HeaderMargin = Application.InchesToPoints(0.1)
        .FooterMargin = Application.InchesToPoints(0.1)
    End With
End Sub

' FONCTION UTILITAIRE : Obtenir le nom de l'onglet actif
Sub NomOngletActif()
    ' Fonction utilitaire utilis√©e par les autres macros
    Dim nomOnglet As String
    nomOnglet = ActiveSheet.Name
End Sub

' POINT D'ENTR√âE POUR L'IMPORT BDC
Sub LancerImportBDC()
    MsgBox "La fonctionnalit√© d'import BDC n'est pas d√©finie dans le code fourni.", vbInformation
End Sub

' =====================================================
' MACROS DE TEST ET V√âRIFICATION
' =====================================================

' MACRO DE TEST : V√©rifier la logique de d√©passement
Sub TesterLogiquleDepassement()
    Dim ws As Worksheet
    Dim maxPar As Integer
    Dim msg As String
    
    Set ws = ActiveSheet
    maxPar = val(ws.Range("C1").Value)
    If maxPar <= 0 Then maxPar = 4
    
    msg = "TEST DE LA LOGIQUE DE D√âPASSEMENT" & vbCrLf & vbCrLf
    msg = msg & "Valeur max par caisson (C1 de '" & ws.Name & "') : " & maxPar & vbCrLf & vbCrLf
    msg = msg & "EXEMPLES DE TESTS :" & vbCrLf
    
    ' Tester quelques codes
    msg = msg & "1A : " & IIf(CaissonDepasse("1A", maxPar), "D√âPASSE", "OK") & vbCrLf
    msg = msg & maxPar & "D : " & IIf(CaissonDepasse(maxPar & "D", maxPar), "D√âPASSE", "OK") & vbCrLf
    msg = msg & (maxPar + 1) & "D : " & IIf(CaissonDepasse((maxPar + 1) & "D", maxPar), "D√âPASSE", "OK") & vbCrLf
    msg = msg & "1E : " & IIf(CaissonDepasse("1E", maxPar), "D√âPASSE", "OK") & vbCrLf & vbCrLf
    
    msg = msg & "LIMITE : Tout au-del√† de " & maxPar & "D devrait √™tre en ROUGE avec HC" & vbCrLf
    msg = msg & "IMPORTANT : Une fois d√©pass√©, m√™me si √ßa repart √† 1A, √ßa reste ROUGE !"
    
    MsgBox msg, vbInformation, "Test logique d√©passement"
End Sub

' MACRO DE TEST : V√©rifier la structure des donn√©es
Sub VerifierStructureDonnees()
    Dim ws As Worksheet
    Dim msg As String
    
    Set ws = ActiveSheet
    
    msg = "V√âRIFICATION DE LA STRUCTURE DES DONN√âES SUR '" & ws.Name & "'" & vbCrLf & vbCrLf
    msg = msg & "Valeur max par caisson (C1) : " & ws.Range("C1").Value & vbCrLf & vbCrLf
    msg = msg & "Exemple de la ligne 7 :" & vbCrLf
    msg = msg & "- Colonne A (N¬∞) : " & ws.Cells(7, 1).Text & vbCrLf
    msg = msg & "- Colonne B (Nom voie) : " & ws.Cells(7, 2).Text & vbCrLf
    msg = msg & "- Colonne D (Observations) : " & ws.Cells(7, 4).Text & vbCrLf
    msg = msg & "- Colonne F (Type PDI) : " & ws.Cells(7, 6).Text & vbCrLf
    msg = msg & "- Colonne G (Largeur) : " & ws.Cells(7, 7).Text & vbCrLf
    msg = msg & "- Colonne V (Valeur B) : " & ws.Cells(7, 22).Text & vbCrLf & vbCrLf
    
    msg = msg & "R√âSULTAT ATTENDU :" & vbCrLf
    msg = msg & "Cellule du HAUT : " & ws.Cells(7, 1).Text & " - " & ws.Cells(7, 4).Text & vbCrLf
    msg = msg & "Cellule du BAS : " & ws.Cells(7, 2).Text
    
    MsgBox msg, vbInformation, "Structure des donn√©es"
End Sub
