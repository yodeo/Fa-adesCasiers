' =====================================================
' NOUVEAU SYSTÈME DE MENU CONTEXTUEL AMÉLIORÉ
' =====================================================

' Variables globales pour le menu contextuel
Public menuContextuelActif As Boolean
Public derniereFeuilleActive As String

Sub EnleverProtectionFeuilleActive()
    Dim motDePasse As String
    motDePasse = "" ' Remplace par le mot de passe réel

    On Error Resume Next
    ActiveSheet.Unprotect Password:=motDePasse

    If Err.Number <> 0 Then
        MsgBox "Échec de la suppression de la protection.", vbExclamation
    Else
        'MsgBox "La feuille a été déprotégée avec succès.", vbInformation
    End If
End Sub



Sub GenererFacadePDI()
    '=====================================================
    ' MACRO : Génération automatique d'une façade de casiers PDI
    ' MODIFICATION : La source est maintenant la feuille active, et non plus "Accueil".
    ' Destination : Nouvelle feuille nommée avec le nom de la tournée + "Fac"
    ' NOUVEAU : Ajout des hachures pour les cases multivoies
    '=====================================================
    
    Dim wsSource As Worksheet, wsDest As Worksheet
    Dim derniereLigne As Long, i As Long
    Dim numPDI As String, observations As String, nomVoie As String
    Dim largeurPDI As Integer
    Dim ligneActuelle As Long, colonneActuelle As Long
    Dim rngHaut As Range, rngBas As Range, rngCaisson As Range
    Dim valeurLargeur As Variant
    Dim dictCouleurs As Object
    Dim paletteCouleurs As Object
    Dim couleurActuelle As Long
    Dim indexCouleur As Integer
    
    ' Variables pour la gestion des caissons
    Dim maxParCaisson As Integer
    Dim compteurDansCaisson As Integer
    Dim numeroCaisson As Integer
    Dim lettreCaisson As String
    Dim codeCaisson As String
    Dim horsCapacitePermanent As Boolean ' Variable pour tracker le dépassement permanent
    
    ' Variables pour l'accumulation
    Dim blocEnCours As Boolean
    Dim numAccumule As String
    Dim obsAccumulees As String
    Dim voieAccumulee As String
    Dim largeurBloc As Integer
    
    ' Variables pour la mise à jour des codes caisson en temps réel
    Dim dictMiseAJourCodes As Object
    Dim dictLignesHorsCapacite As Object ' Pour stocker les lignes qui dépassent
    Dim ligneSourceActuelle As Long
    
    ' NOUVELLE VARIABLE : Nom de la tournée et nom de la feuille destination
    Dim nomTournee As String
    Dim nomFeuilleDestination As String
    
    ' Désactiver les mises à jour écran pour améliorer les performances
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    ' NETTOYER LE MENU CONTEXTUEL AVANT DE COMMENCER
    Call SupprimerOptionMenuContextuel
    
    ' Supprimer la protection de la feuille
    Call EnleverProtectionFeuilleActive
    
    ' Créer un dictionnaire pour gérer les couleurs par nom de voie
    Set dictCouleurs = CreateObject("Scripting.Dictionary")
    
    ' Créer la palette de couleurs étendues
    Set paletteCouleurs = CreateObject("Scripting.Dictionary")
    Call InitialiserPaletteCouleursEtendues(paletteCouleurs)
    indexCouleur = 0
    
    ' Créer un dictionnaire pour stocker les codes caisson à mettre à jour
    Set dictMiseAJourCodes = CreateObject("Scripting.Dictionary")
    
    ' Créer un dictionnaire pour stocker les lignes hors capacité
    Set dictLignesHorsCapacite = CreateObject("Scripting.Dictionary")
    
    ' MODIFICATION : Définir la feuille source comme étant la feuille active
    Set wsSource = ActiveSheet
    
    ' NOUVELLE LOGIQUE : Récupérer le nom de la tournée depuis A1
    nomTournee = Trim(CStr(wsSource.Range("A1").Value))
    
    ' Si A1 est vide, utiliser le nom de la feuille source
    If nomTournee = "" Then
        nomTournee = wsSource.Name
    End If
    
    ' Nettoyer le nom de la tournée (supprimer les caractères non autorisés dans les noms de feuille)
    nomTournee = NettoyerNomFeuille(nomTournee)
    
    ' Construire le nom de la feuille destination
    nomFeuilleDestination = nomTournee & "Fac"
    
    ' S'assurer que le nom ne dépasse pas 31 caractères (limite Excel)
    If Len(nomFeuilleDestination) > 31 Then
        nomFeuilleDestination = Left(nomFeuilleDestination, 28) & "Fac"
    End If
    
    ' Récupérer la valeur max par caisson depuis C1 de la feuille active
    maxParCaisson = Val(wsSource.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4 ' Valeur par défaut si C1 est vide ou invalide
    
    ' Initialiser les compteurs de caisson
    compteurDansCaisson = 1  ' Commence à 1, pas 0
    numeroCaisson = 1
    lettreCaisson = "A"
    horsCapacitePermanent = False ' Pas encore en dépassement
    
    ' Supprimer la feuille destination si elle existe déjà
    On Error Resume Next
    ThisWorkbook.Sheets(nomFeuilleDestination).Delete
    On Error GoTo 0
    
    ' Créer la nouvelle feuille destination après la feuille active
    Set wsDest = ThisWorkbook.Sheets.Add(After:=wsSource)
    wsDest.Name = nomFeuilleDestination
    
    ' Configurer les largeurs de colonnes
    wsDest.Columns("A:B").ColumnWidth = 5.57
    wsDest.Columns("Y:Z").ColumnWidth = 5.57
    wsDest.Columns("AA").ColumnWidth = 3.29
    wsDest.Columns("C:X").ColumnWidth = 4.29
    
    ' Trouver la dernière ligne avec des données dans la feuille source
    derniereLigne = wsSource.Cells(wsSource.Rows.Count, "A").End(xlUp).Row
    
    ' Initialiser les positions de départ
    ligneActuelle = 1
    colonneActuelle = 1
    blocEnCours = False
    
    ' PARCOURIR LES DONNÉES À PARTIR DE LA LIGNE 7
    i = 7
    Do While i <= derniereLigne
        ' Lire les données de la ligne actuelle depuis la feuille source
        numPDI = CStr(wsSource.Cells(i, 1).Text)
        nomVoie = CStr(wsSource.Cells(i, 2).Text)
        observations = CStr(wsSource.Cells(i, 4).Text)
        valeurLargeur = wsSource.Cells(i, 7).Value
        largeurPDI = ConvertirEnEntier(valeurLargeur, 0)
        
        ' Lire la valeur de la colonne V pour le fond jaune
        Dim valeurColV As String
        valeurColV = CStr(wsSource.Cells(i, 22).Text) ' Colonne V = 22
        
        ' Lire le type PDI (colonne F)
        Dim typePDI As String
        typePDI = CStr(wsSource.Cells(i, 6).Text) ' Colonne F = 6
        
        ' Si on a une largeur > 0, c'est le début d'un nouveau bloc
        If largeurPDI > 0 Then
            ' Stocker la ligne source de début pour ce bloc
            ligneSourceActuelle = i
            
            ' Initialiser l'accumulation pour ce bloc
            numAccumule = numPDI
            obsAccumulees = observations
            voieAccumulee = nomVoie
            largeurBloc = largeurPDI
            
            ' Variable pour savoir si c'est un bloc multi-voies
            Dim estMultiVoies As Boolean
            estMultiVoies = False
            
            ' Regarder les lignes suivantes pour accumulation
            Dim j As Long
            j = i + 1
            
            ' Collections pour regrouper par voie
            Dim dictVoies As Object
            Set dictVoies = CreateObject("Scripting.Dictionary")
            
            ' Ajouter le premier numéro à sa voie
            If Not dictVoies.Exists(voieAccumulee) Then
                dictVoies.Add voieAccumulee, Array()
            End If
            Dim tempArray As Variant
            tempArray = dictVoies(voieAccumulee)
            ReDim Preserve tempArray(UBound(tempArray) + 1)
            tempArray(UBound(tempArray)) = numPDI
            dictVoies(voieAccumulee) = tempArray
            
            Do While j <= derniereLigne
                Dim largeurSuivante As Integer
                largeurSuivante = ConvertirEnEntier(wsSource.Cells(j, 7).Value, 0)
                
                ' Si largeur = 0, accumuler
                If largeurSuivante = 0 Then
                    Dim numSuivant As String, voieSuivante As String, obsSuivante As String
                    numSuivant = CStr(wsSource.Cells(j, 1).Text)
                    voieSuivante = CStr(wsSource.Cells(j, 2).Text)
                    obsSuivante = CStr(wsSource.Cells(j, 4).Text)
                    
                    ' Ajouter le numéro à sa voie correspondante
                    If voieSuivante <> "" Then
                        If Not dictVoies.Exists(voieSuivante) Then
                            dictVoies.Add voieSuivante, Array()
                            estMultiVoies = True
                        End If
                        tempArray = dictVoies(voieSuivante)
                        ReDim Preserve tempArray(UBound(tempArray) + 1)
                        tempArray(UBound(tempArray)) = numSuivant
                        dictVoies(voieSuivante) = tempArray
                    End If
                    
                    ' Accumuler les observations
                    If obsSuivante <> "" Then
                        If obsAccumulees = "" Then
                            obsAccumulees = obsSuivante
                        Else
                            obsAccumulees = obsAccumulees & " / " & obsSuivante
                        End If
                    End If
                    
                    ' Vérifier aussi la colonne V pour les lignes accumulées
                    If wsSource.Cells(j, 22).Text = "B" Then
                        valeurColV = "B"
                    End If
                    
                    ' Vérifier aussi le type PDI pour les lignes accumulées
                    If wsSource.Cells(j, 6).Text = "Bat P" Or wsSource.Cells(j, 6).Text = "Bat C" Then
                        typePDI = wsSource.Cells(j, 6).Text
                    End If
                    
                    j = j + 1
                Else
                    ' On a trouvé une largeur > 0, on arrête l'accumulation
                    Exit Do
                End If
            Loop
            
            ' Construire numAccumule et voieAccumulee à partir du dictionnaire
            numAccumule = ""
            voieAccumulee = ""
            Dim voiesArray As Variant
            voiesArray = dictVoies.Keys
            
            Dim k As Long
            For k = 0 To UBound(voiesArray)
                Dim voieActuelle As String
                voieActuelle = voiesArray(k)
                
                ' Construire la chaîne des numéros pour cette voie
                Dim numerosVoie As Variant
                numerosVoie = dictVoies(voieActuelle)
                
                Dim chaineNumeros As String
                chaineNumeros = ""
                Dim n As Long
                For n = 0 To UBound(numerosVoie)
                    If chaineNumeros = "" Then
                        chaineNumeros = numerosVoie(n)
                    Else
                        chaineNumeros = chaineNumeros & "-" & numerosVoie(n)
                    End If
                Next n
                
                ' Ajouter à numAccumule
                If numAccumule = "" Then
                    numAccumule = chaineNumeros
                Else
                    numAccumule = numAccumule & " / " & chaineNumeros
                End If
                
                ' Ajouter à voieAccumulee
                If voieAccumulee = "" Then
                    voieAccumulee = voieActuelle
                Else
                    voieAccumulee = voieAccumulee & " / " & voieActuelle
                End If
            Next k
            
            ' Mettre à jour i pour sauter les lignes accumulées
            i = j - 1
            
            ' CRÉER LE BLOC PDI
            ' Vérifier la validité de la largeur
            If largeurBloc < 1 Then largeurBloc = 1
            If largeurBloc > 26 Then largeurBloc = 26
            
            ' Vérifier si on dépasse la colonne Z (26)
            If colonneActuelle + largeurBloc - 1 > 26 Then
                ' Ajouter le code caisson avant de passer à la ligne
                If colonneActuelle > 1 Then
                    ' Vérifier si le caisson actuel dépasse la capacité
                    Dim codeActuel As String
                    codeActuel = numeroCaisson & lettreCaisson
                    If horsCapacitePermanent Or CaissonDepasse(codeActuel, maxParCaisson) Then
                        Call AjouterCodeCaisson(wsDest, ligneActuelle, "HC")
                    Else
                        Call AjouterCodeCaisson(wsDest, ligneActuelle, codeActuel)
                    End If
                End If
                
                ligneActuelle = ligneActuelle + 2
                colonneActuelle = 1
                
                ' Incrémenter le compteur de caisson selon la nouvelle logique
                numeroCaisson = numeroCaisson + 1
                
                ' Si on dépasse maxParCaisson, on passe à la lettre suivante
                If numeroCaisson > maxParCaisson Then
                    numeroCaisson = 1
                    ' Passer à la lettre suivante
                    If lettreCaisson = "D" Then
                        ' Si on dépasse D, on est maintenant hors capacité de façon permanente
                        horsCapacitePermanent = True
                        ' On recommence à A mais on reste hors capacité
                        lettreCaisson = "A"
                    Else
                        lettreCaisson = Chr(Asc(lettreCaisson) + 1)
                        ' Vérifier si on vient d'atteindre le dépassement
                        If lettreCaisson > "D" And Not horsCapacitePermanent Then
                            horsCapacitePermanent = True
                            lettreCaisson = "A" ' Redémarre mais reste hors capacité
                            numeroCaisson = 1
                        End If
                    End If
                End If
            End If
            
            ' Calculer le code caisson complet pour ce PDI
            Dim codeCompletCaisson As String
            Dim numeroPosition As String
            Dim codeBaseCaisson As String
            
            ' Code de base du caisson (ex: "1A", "2B", etc.)
            codeBaseCaisson = numeroCaisson & lettreCaisson
            
            ' Vérifier si on dépasse la limite pour le fond rouge
            Dim fondRouge As Boolean
            fondRouge = horsCapacitePermanent Or CaissonDepasse(codeBaseCaisson, maxParCaisson)
            
            ' Calculer le numéro de position (format 01, 02, etc.)
            numeroPosition = Format(colonneActuelle, "00")
            codeCompletCaisson = codeBaseCaisson & " " & numeroPosition
            
            ' Stocker le code pour toutes les lignes de ce bloc (ligne principale + lignes accumulées)
            For k = ligneSourceActuelle To j - 1
                dictMiseAJourCodes.Add k, codeCompletCaisson
                ' Si c'est hors capacité, l'ajouter au dictionnaire des lignes à colorer
                If fondRouge Then
                    dictLignesHorsCapacite.Add k, True
                End If
            Next k
            
               
                '******************************************************************************************************************
                ' Créer la cellule du haut (N° + Observations) - AVEC FORMATAGE DIFFÉRENCIÉ ET TRIANGLE CONDITIONNEL
            Set rngHaut = wsDest.Range(wsDest.Cells(ligneActuelle, colonneActuelle), _
                                        wsDest.Cells(ligneActuelle, colonneActuelle + largeurBloc - 1))
            rngHaut.Merge
            
            With rngHaut
                .NumberFormat = "@"
                
                ' Construire le texte avec symbole si nécessaire - NOUVELLE LOGIQUE CONDITIONNELLE
                Dim texteComplet As String
                Dim symbole As String
                symbole = ""
                
                ' NOUVELLE CONDITION : Vérifier si TOUS les PDI du bloc sont batterie/rattachés
                Dim afficherTriangle As Boolean
                afficherTriangle = False
                
                ' Vérifier d'abord s'il y a au moins un PDI batterie dans le bloc
                Dim aUnePDIBatterie As Boolean
                aUnePDIBatterie = False
                
                For k = ligneSourceActuelle To j - 1
                    Dim typeVerif As String
                    typeVerif = UCase(Trim(CStr(wsSource.Cells(k, 6).Text)))
                    If typeVerif = "BAT C" Or typeVerif = "BAT P" Then
                        aUnePDIBatterie = True
                        Exit For
                    End If
                Next k
                
                ' Si on a au moins un PDI batterie, vérifier que TOUS sont batterie/rattachés
                If aUnePDIBatterie Then
                    afficherTriangle = TousLesPDISontBatterieOuRattaches(wsSource, ligneSourceActuelle, j - 1)
                End If
                
                ' Ajouter le triangle SEULEMENT si la condition est remplie
                If afficherTriangle Then
                    symbole = ChrW(&H25B2) & " " ' Triangle Unicode + espace
                End If
                
                ' Construction du texte avec formatage différencié et saut de ligne
                If obsAccumulees <> "" Then
                    ' Format : [Symbole conditionnel] Numéro + SAUT DE LIGNE + Observations
                    texteComplet = symbole & numAccumule & vbCrLf & obsAccumulees
                Else
                    ' Format : [Symbole conditionnel] Numéro seul
                    texteComplet = symbole & numAccumule
                End If
                
                .Value = texteComplet
                .HorizontalAlignment = xlCenter
                .VerticalAlignment = xlCenter
                .WrapText = True
                
                ' Bordures : toujours fines
                .Borders.LineStyle = xlContinuous
                .Borders.Weight = xlThin
                
                ' Priorité : rouge si dépasse > jaune si colonne V = "B" > pas de couleur
                If fondRouge Then
                    .Interior.Color = RGB(255, 0, 0) ' Rouge (priorité 1)
                    .Font.Color = RGB(255, 255, 255) ' Texte blanc sur fond rouge
                ElseIf valeurColV = "B" Then
                    .Interior.Color = RGB(255, 255, 0) ' Jaune (priorité 2)
                    .Font.Color = RGB(0, 0, 0) ' Texte noir sur fond jaune
                Else
                    .Interior.Pattern = xlNone ' Pas de couleur
                End If
            End With
            
            ' APPLIQUER LE FORMATAGE DIFFÉRENCIÉ POUR NUMÉROS VS OBSERVATIONS
            Call AppliquerFormatageDifferencie(rngHaut, symbole, numAccumule, obsAccumulees)
            
            ' Créer la cellule du bas (Nom de la voie) - AVEC LE CERCLE BLANC SI MULTI-VOIES
            Set rngBas = wsDest.Range(wsDest.Cells(ligneActuelle + 1, colonneActuelle), _
                                        wsDest.Cells(ligneActuelle + 1, colonneActuelle + largeurBloc - 1))
            rngBas.Merge
            
            ' Appliquer les abréviations au nom de voie
            Dim voieAbregee As String
            voieAbregee = AbregerTypeVoie(voieAccumulee)
            
            ' Construire le texte de la voie avec cercle blanc si multi-voies
            Dim texteVoie As String
            If estMultiVoies Then
                texteVoie = voieAbregee ' Cercle blanc + nom de voie
            Else
                texteVoie = voieAbregee ' Nom de voie seul
            End If
            
            With rngBas
                .NumberFormat = "@"
                .Value = texteVoie ' Utiliser le texte avec ou sans cercle
            End With
            
            ' Gérer la couleur pour les voies
            If voieAccumulee <> "" Then
                ' Pour les voies multiples, utiliser la couleur de la première voie
                Dim premiereVoie As String
                Dim posSlash As Integer
                posSlash = InStr(voieAccumulee, " / ")
                If posSlash > 0 Then
                    premiereVoie = Left(voieAccumulee, posSlash - 1)
                Else
                    premiereVoie = voieAccumulee
                End If
                
                If Not dictCouleurs.Exists(premiereVoie) Then
                    ' Utiliser la nouvelle palette de couleurs étendues avec vérification d'adjacence
                    Dim couleurRGB As Long
                    couleurRGB = ObtenirCouleurDistinctePourVoieAvecAdjacence(premiereVoie, paletteCouleurs, dictCouleurs, colonneActuelle, wsDest, ligneActuelle)
                    dictCouleurs.Add premiereVoie, couleurRGB
                    indexCouleur = indexCouleur + 1
                End If
                couleurActuelle = dictCouleurs(premiereVoie)
            Else
                couleurActuelle = xlNone
            End If
            
            With rngBas
                .HorizontalAlignment = xlCenter
                .VerticalAlignment = xlCenter
                .Font.Bold = True
                .WrapText = True
                
                ' Souligner le texte si multi-voies
                If estMultiVoies Then
                    .Font.Underline = xlUnderlineStyleSingle
                End If
                
                ' Bordures : toujours fines
                .Borders.LineStyle = xlContinuous
                .Borders.Weight = xlThin
                
                If couleurActuelle <> xlNone Then
                    ' Priorité : rouge si dépasse > couleur normale
                    If fondRouge Then
                        .Interior.Color = RGB(255, 0, 0) ' Rouge (priorité 1)
                        .Font.Color = RGB(255, 255, 255) ' Texte blanc sur fond rouge
                    Else
                        ' Utiliser la couleur RGB de la nouvelle palette
                        .Interior.Color = couleurActuelle
                        .Font.Color = ObtenirCouleurTexteRGB(couleurActuelle)
                    End If
                Else
                    ' Même si pas de couleur de voie, appliquer le rouge si dépasse
                    If fondRouge Then
                        .Interior.Color = RGB(255, 0, 0) ' Rouge
                        .Font.Color = RGB(255, 255, 255) ' Texte blanc
                    End If
                End If
            End With
            
            ' Ajuster les hauteurs de lignes - CONSERVÉES COMME AVANT
            wsDest.Rows(ligneActuelle).RowHeight = 48.75
            wsDest.Rows(ligneActuelle + 1).RowHeight = 39
            
            ' AJUSTER LA TAILLE DE POLICE SELON LA LARGEUR DE LA CELLULE
            Call AjusterTaillePoliceSelonLargeur(rngHaut, largeurBloc) ' Échelle numéros PDI
            Call AjusterTaillePoliceVoiesSelonLargeur(rngBas, largeurBloc) ' Échelle noms de voies
            
            ' Avancer à la position suivante
            colonneActuelle = colonneActuelle + largeurBloc
        End If
        
        i = i + 1
    Loop
    
    ' Ajouter le code caisson pour la dernière ligne si nécessaire
    If colonneActuelle > 1 Then
        Dim codeFinal As String
        codeFinal = numeroCaisson & lettreCaisson
        If horsCapacitePermanent Or CaissonDepasse(codeFinal, maxParCaisson) Then
            Call AjouterCodeCaisson(wsDest, ligneActuelle, "HC")
        Else
            Call AjouterCodeCaisson(wsDest, ligneActuelle, codeFinal)
        End If
    End If
    
    Call BasculerHachuresMultivoies
    
    ' METTRE À JOUR LA COLONNE H DE LA FEUILLE SOURCE AVEC LES CODES CALCULÉS ET COLORER LES LIGNES HORS CAPACITÉ
    ' DÉSACTIVÉ : Le système temps réel gère maintenant les codes caisson automatiquement
    ' Call MettreAJourColonneHAvecCouleur(wsSource, dictMiseAJourCodes, dictLignesHorsCapacite)
    
    ' Fusionner les cellules adjacentes avec le même nom de voie
    Call FusionnerVoiesAdjacentes(wsDest)
    
    ' Mettre à jour les cellules vides dans la feuille source
    ' Utiliser la colonne W pour stocker le nombre de cellules vides
    Call MettreAJourCellulesVides(wsSource, wsDest, "W")
    
    ' AJOUTER LES BOUTONS ET MENU CONTEXTUEL À LA FEUILLE FACADE_PDI (VERSION SIMPLIFIÉE)
    Call AjouterBoutonsSeulement(wsDest)
    ' Les menus contextuels sont maintenant gérés par les événements du classeur
    
    ' Masquer le quadrillage
    With wsDest
        ActiveWindow.DisplayGridlines = False
    End With
    
    ' Configuration finale de la feuille
    With wsDest.PageSetup
        .Orientation = xlLandscape
        .FitToPagesWide = 1
        .FitToPagesTall = False
        .CenterHorizontally = True
    End With
    
    ' Réactiver les mises à jour
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    
    wsDest.Activate
    
    ' NOUVEAU : Appeler la macro d'ajustement des paramètres d'impression
    ' avec une pause pour s'assurer que la feuille est bien créée
    DoEvents
    Application.Wait (Now + TimeValue("0:00:01"))
    
    ' Message de confirmation avec le nouveau nom
    MsgBox "La façade PDI a été générée avec succès !" & vbCrLf & _
           "Feuille source traitée : '" & wsSource.Name & "'" & vbCrLf & _
           "Feuille destination créée : '" & nomFeuilleDestination & "'" & vbCrLf & _
           "Nom de tournée utilisé : '" & nomTournee & "'" & vbCrLf & _
           "Nombre de lignes traitées : " & (derniereLigne - 6) & vbCrLf & _
           "Les paramètres d'impression ont été configurés." & vbCrLf & _
           "Les cases multivoies sont hachurées pour faciliter l'identification.", _
           vbInformation, "Génération terminée"
    
    ' Colorer l'onglet de la façade en jaune
    wsDest.Tab.Color = RGB(255, 255, 0) ' Jaune
    
    ' Calculer les espaces libres après génération de la façade (version temps réel)
    Call MiseAJourTempsReelComplete(wsSource)
    
    wsDest.Activate
    
End Sub

' =====================================================
' NOUVELLE FONCTION : Appliquer/Supprimer les hachures multivoies
' =====================================================
Sub AppliquerHachuresMultivoies()
    ' Macro pour appliquer les hachures aux cases multivoies existantes
    Dim ws As Worksheet
    Dim lastRow As Long, lastCol As Long
    Dim ligneNum As Long, col As Long
    Dim celluleNum As Range, celluleVoie As Range
    Dim contenuVoie As String
    Dim compteurHachures As Long
    
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur une feuille façade
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit être utilisée sur une feuille façade.", vbExclamation
        Exit Sub
    End If
    
    Application.ScreenUpdating = False
    
    lastRow = ws.usedRange.Rows.Count
    lastCol = 26 ' Colonnes A à Z
    compteurHachures = 0
    
    ' Parcourir toutes les lignes de numéros (lignes impaires)
    For ligneNum = 1 To lastRow Step 2
        For col = 1 To lastCol
            Set celluleNum = ws.Cells(ligneNum, col)
            
            ' Vérifier si la cellule contient des numéros
            If Not IsEmpty(celluleNum.Value) And celluleNum.Value <> "" Then
                ' Vérifier la cellule de voie correspondante (ligne suivante)
                Set celluleVoie = ws.Cells(ligneNum + 1, col)
                
                If Not IsEmpty(celluleVoie.Value) Then
                    contenuVoie = Trim(CStr(celluleVoie.Value))
                    
                    ' Vérifier si c'est une voie multiple (contient "/" ou cercle blanc)
                    If InStr(contenuVoie, " / ") > 0 Or Left(contenuVoie, 1) = ChrW(&H25CB) Then
                        ' Appliquer les hachures
                        With celluleNum.Interior
                            .Pattern = xlPatternLightDown
                            .PatternColor = RGB(100, 100, 100)  ' Hachures grises
                            ' Conserver la couleur de fond existante si elle existe
                            If .Color = xlNone Or .Color = RGB(255, 255, 255) Then
                                .Color = RGB(255, 255, 255) ' Fond blanc
                            End If
                        End With
                        compteurHachures = compteurHachures + 1
                    End If
                End If
            End If
        Next col
    Next ligneNum
    
    Application.ScreenUpdating = True
    
    MsgBox "Hachures appliquées à " & compteurHachures & " cases multivoies.", vbInformation, "Hachures Multivoies"
End Sub

Sub SupprimerHachuresMultivoies()
    ' Macro pour supprimer toutes les hachures
    Dim ws As Worksheet
    Dim lastRow As Long, lastCol As Long
    Dim ligneNum As Long, col As Long
    Dim cellule As Range
    Dim compteurSupprimees As Long
    
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur une feuille façade
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit être utilisée sur une feuille façade.", vbExclamation
        Exit Sub
    End If
    
    Application.ScreenUpdating = False
    
    lastRow = ws.usedRange.Rows.Count
    lastCol = 26 ' Colonnes A à Z
    compteurSupprimees = 0
    
    ' Parcourir toutes les lignes de numéros (lignes impaires)
    For ligneNum = 1 To lastRow Step 2
        For col = 1 To lastCol
            Set cellule = ws.Cells(ligneNum, col)
            
            ' Vérifier si la cellule a des hachures
            If cellule.Interior.Pattern = xlPatternLightDown Then
                ' Supprimer les hachures
                With cellule.Interior
                    .Pattern = xlNone
                    ' Conserver la couleur de fond si elle existe (rouge, jaune, etc.)
                End With
                compteurSupprimees = compteurSupprimees + 1
            End If
        Next col
    Next ligneNum
    
    Application.ScreenUpdating = True
    
    MsgBox "Hachures supprimées de " & compteurSupprimees & " cellules.", vbInformation, "Suppression Hachures"
End Sub

' =====================================================
' MACRO UTILITAIRE : Basculer les hachures multivoies
' =====================================================
Sub BasculerHachuresMultivoies()
    ' Fonction pour activer/désactiver les hachures selon l'état actuel
    Dim ws As Worksheet
    Dim cellule As Range
    Dim aDesHachures As Boolean
    
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur une feuille façade
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit être utilisée sur une feuille façade.", vbExclamation
        Exit Sub
    End If
    
    ' Vérifier s'il y a déjà des hachures
    aDesHachures = False
    For Each cellule In ws.usedRange
        If cellule.Interior.Pattern = xlPatternLightDown Then
            aDesHachures = True
            Exit For
        End If
    Next cellule
    
    ' Basculer selon l'état actuel
    If aDesHachures Then
        Call SupprimerHachuresMultivoies
    Else
        Call AppliquerHachuresMultivoies
    End If
End Sub



' =====================================================
' FONCTION UTILITAIRE : Identifier automatiquement les cases multivoies
' =====================================================
Function EstCaseMultivoie(celluleNum As Range, celluleVoie As Range) As Boolean
    ' Fonction pour déterminer si une case contient plusieurs voies
    Dim contenuNum As String, contenuVoie As String
    
    EstCaseMultivoie = False
    
    ' Vérifier le contenu des cellules
    If IsEmpty(celluleNum.Value) Or IsEmpty(celluleVoie.Value) Then Exit Function
    
    contenuNum = Trim(CStr(celluleNum.Value))
    contenuVoie = Trim(CStr(celluleVoie.Value))
    
    ' Méthode 1 : Vérifier si la voie contient des séparateurs
    If InStr(contenuVoie, " / ") > 0 Then
        EstCaseMultivoie = True
        Exit Function
    End If
    
    ' Méthode 2 : Vérifier si la voie commence par un cercle blanc (indicateur multivoie)
    If Left(contenuVoie, 1) = ChrW(&H25CB) Then
        EstCaseMultivoie = True
        Exit Function
    End If
    
    ' Méthode 3 : Vérifier si les numéros contiennent des slashes (différentes voies)
    If InStr(contenuNum, " / ") > 0 Then
        EstCaseMultivoie = True
        Exit Function
    End If
    
    ' Méthode 4 : Vérifier s'il y a soulignement sur la voie (indicateur multivoie)
    If celluleVoie.Font.Underline = xlUnderlineStyleSingle Then
        EstCaseMultivoie = True
        Exit Function
    End If
End Function

' =====================================================
' DIAGNOSTIC : Analyser les cases multivoies détectées
' =====================================================
Sub DiagnostiquerCasesMultivoiesHachures()
    Dim ws As Worksheet
    Dim lastRow As Long, lastCol As Long
    Dim ligneNum As Long, col As Long
    Dim celluleNum As Range, celluleVoie As Range
    Dim compteurMultivoies As Long
    Dim compteurAvecHachures As Long
    Dim rapport As String
    
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur une feuille façade
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit être utilisée sur une feuille façade.", vbExclamation
        Exit Sub
    End If
    
    lastRow = ws.usedRange.Rows.Count
    lastCol = 26
    compteurMultivoies = 0
    compteurAvecHachures = 0
    
    rapport = "DIAGNOSTIC DES CASES MULTIVOIES ET HACHURES" & vbCrLf & vbCrLf
    
    ' Analyser toutes les cases
    For ligneNum = 1 To lastRow Step 2
        For col = 1 To lastCol
            Set celluleNum = ws.Cells(ligneNum, col)
            Set celluleVoie = ws.Cells(ligneNum + 1, col)
            
            If Not IsEmpty(celluleNum.Value) Then
                If EstCaseMultivoie(celluleNum, celluleVoie) Then
                    compteurMultivoies = compteurMultivoies + 1
                    
                    If celluleNum.Interior.Pattern = xlPatternLightDown Then
                        compteurAvecHachures = compteurAvecHachures + 1
                    End If
                End If
            End If
        Next col
    Next ligneNum
    
    rapport = rapport & "Cases multivoies détectées : " & compteurMultivoies & vbCrLf
    rapport = rapport & "Cases avec hachures : " & compteurAvecHachures & vbCrLf & vbCrLf
    
    If compteurMultivoies = compteurAvecHachures Then
        rapport = rapport & "? Toutes les cases multivoies sont hachurées !"
    ElseIf compteurAvecHachures = 0 Then
        rapport = rapport & "?? Aucune case n'est hachurée." & vbCrLf
        rapport = rapport & "Utilisez le bouton 'Hachures Multivoies ON/OFF' pour les afficher."
    Else
        rapport = rapport & "?? " & (compteurMultivoies - compteurAvecHachures) & " cases multivoies ne sont pas hachurées." & vbCrLf
        rapport = rapport & "Utilisez le bouton 'Hachures Multivoies ON/OFF' pour corriger."
    End If
    
    MsgBox rapport, vbInformation, "Diagnostic Hachures Multivoies"
End Sub

' =====================================================
' AMÉLIORATION : Fonction FusionnerVoiesAdjacentes avec préservation des hachures
' =====================================================
Sub FusionnerVoiesAdjacentes(ws As Worksheet)
    Dim ligneVoie As Long
    Dim col As Long, colDebut As Long
    Dim nomVoieActuel As String, nomVoieSuivant As String
    Dim rngFusion As Range
    Dim derniereLigne As Long
    Dim derniereColonne As Long
    Dim couleurIndex As Long
    Dim couleurTexte As Long
    Dim avaitHachures As Boolean  ' NOUVEAU : pour préserver les hachures
    
    ' Trouver les limites de la feuille utilisée
    derniereLigne = ws.usedRange.Rows.Count
    derniereColonne = 26 ' S'arrêter à la colonne Z
    
    ' Parcourir toutes les lignes de noms de voies (lignes 2, 4, 6, etc.)
    For ligneVoie = 2 To derniereLigne Step 2
        col = 1
        
        ' Parcourir les colonnes de cette ligne
        Do While col <= derniereColonne
            ' Ignorer les cellules vides
            If ws.Cells(ligneVoie, col).Value = "" Then
                col = col + 1
            Else
                ' Récupérer le nom de voie actuel
                nomVoieActuel = Trim(ws.Cells(ligneVoie, col).Value)
                
                ' Extraire le nom de voie sans le cercle blanc pour la comparaison
                Dim nomVoieComparaison As String
                If Left(nomVoieActuel, 1) = ChrW(&H25CB) Then
                    nomVoieComparaison = Trim(Mid(nomVoieActuel, 3))
                Else
                    nomVoieComparaison = nomVoieActuel
                End If
                
                ' Si c'est une voie multiple, ne pas fusionner
                If InStr(nomVoieComparaison, " / ") > 0 Then
                    ' Passer à la cellule suivante sans fusionner
                    If ws.Cells(ligneVoie, col).MergeCells Then
                        col = ws.Cells(ligneVoie, col).MergeArea.Column + _
                              ws.Cells(ligneVoie, col).MergeArea.Columns.Count
                    Else
                        col = col + 1
                    End If
                Else
                    ' Procéder à la fusion normale pour les voies simples
                    colDebut = col
                    
                    ' NOUVEAU : Vérifier si la cellule de numéro correspondante a des hachures
                    avaitHachures = (ws.Cells(ligneVoie - 1, col).Interior.Pattern = xlPatternLightDown)
                    
                    ' Mémoriser la couleur et vérifier si c'est rouge (hors capacité)
                    Dim estRouge As Boolean
                    estRouge = False
                    If ws.Cells(ligneVoie, col).Interior.Color = RGB(255, 0, 0) Then
                        estRouge = True
                        couleurIndex = xlNone
                        couleurTexte = RGB(255, 255, 255)
                    ElseIf ws.Cells(ligneVoie, col).Interior.ColorIndex <> xlNone Then
                        couleurIndex = ws.Cells(ligneVoie, col).Interior.ColorIndex
                        couleurTexte = ws.Cells(ligneVoie, col).Font.Color
                    Else
                        couleurIndex = xlNone
                    End If
                    
                    ' Trouver la fin de la cellule fusionnée actuelle
                    If ws.Cells(ligneVoie, col).MergeCells Then
                        col = ws.Cells(ligneVoie, col).MergeArea.Column + _
                              ws.Cells(ligneVoie, col).MergeArea.Columns.Count - 1
                    End If
                    
                    ' Vérifier les cellules suivantes pour le même nom de voie
                    Do While col < derniereColonne
                        ' Vérifier la cellule suivante
                        If ws.Cells(ligneVoie, col + 1).Value = "" Then
                            Exit Do
                        End If
                        
                        nomVoieSuivant = Trim(ws.Cells(ligneVoie, col + 1).Value)
                        
                        ' Extraire le nom de voie sans le cercle blanc pour la comparaison
                        Dim nomVoieSuivantComparaison As String
                        If Left(nomVoieSuivant, 1) = ChrW(&H25CB) Then
                            nomVoieSuivantComparaison = Trim(Mid(nomVoieSuivant, 3))
                        Else
                            nomVoieSuivantComparaison = nomVoieSuivant
                        End If
                        
                        ' Ne pas fusionner si la cellule suivante contient des voies multiples
                        If InStr(nomVoieSuivantComparaison, " / ") > 0 Then
                            Exit Do
                        End If
                        
                        ' Si c'est le même nom de voie, étendre la fusion
                        If nomVoieComparaison = nomVoieSuivantComparaison And nomVoieComparaison <> "" Then
                            ' NOUVEAU : Vérifier les hachures sur toute la plage
                            If ws.Cells(ligneVoie - 1, col + 1).Interior.Pattern = xlPatternLightDown Then
                                avaitHachures = True
                            End If
                            
                            ' Trouver la fin de la cellule suivante
                            If ws.Cells(ligneVoie, col + 1).MergeCells Then
                                col = ws.Cells(ligneVoie, col + 1).MergeArea.Column + _
                                      ws.Cells(ligneVoie, col + 1).MergeArea.Columns.Count - 1
                            Else
                                col = col + 1
                            End If
                        Else
                            Exit Do
                        End If
                    Loop
                    
                    ' Si on a trouvé plusieurs cellules adjacentes avec le même nom
                    If col > colDebut Then
                        ' Défusionner d'abord toutes les cellules concernées
                        For i = colDebut To col
                            If ws.Cells(ligneVoie, i).MergeCells Then
                                ws.Cells(ligneVoie, i).MergeArea.UnMerge
                            End If
                        Next i
                        
                        ' Refusionner l'ensemble
                        Set rngFusion = ws.Range(ws.Cells(ligneVoie, colDebut), ws.Cells(ligneVoie, col))
                        rngFusion.Merge
                        
                        ' NOUVEAU : Appliquer les hachures aux numéros correspondants si nécessaire
                        If avaitHachures Then
                            Dim rngNumerosCorrespondants As Range
                            Set rngNumerosCorrespondants = ws.Range(ws.Cells(ligneVoie - 1, colDebut), ws.Cells(ligneVoie - 1, col))
                            With rngNumerosCorrespondants.Interior
                                .Pattern = xlPatternLightDown
                                .PatternColor = RGB(100, 100, 100)
                                If .Color = xlNone Then .Color = RGB(255, 255, 255)
                            End With
                        End If
                        
                        ' Réappliquer le formatage avec le nom abrégé et le cercle blanc si nécessaire
                        Dim texteVoieFusionne As String
                        ' Vérifier si le texte original contenait un cercle blanc
                        If InStr(nomVoieActuel, ChrW(&H25CB)) > 0 Then
                            texteVoieFusionne = ChrW(&H25CB) & " " & AbregerTypeVoie(nomVoieComparaison)
                        Else
                            texteVoieFusionne = AbregerTypeVoie(nomVoieComparaison)
                        End If
                        
                        With rngFusion
                            .NumberFormat = "@"
                            .Value = texteVoieFusionne
                            .HorizontalAlignment = xlCenter
                            .VerticalAlignment = xlCenter
                            .Font.Bold = True
                            .WrapText = True
                            .Borders.LineStyle = xlContinuous
                            .Borders.Weight = xlThin
                            
                            ' Souligner si c'était une voie multiple
                            If InStr(nomVoieActuel, ChrW(&H25CB)) > 0 Then
                                .Font.Underline = xlUnderlineStyleSingle
                            End If
                            
                            ' Appliquer la couleur appropriée
                            If estRouge Then
                                .Interior.Color = RGB(255, 0, 0)
                                .Font.Color = RGB(255, 255, 255)
                            ElseIf couleurIndex <> xlNone Then
                                .Interior.ColorIndex = couleurIndex
                                .Font.Color = couleurTexte
                            End If
                        End With
                        
                        ' APPLIQUER LA TAILLE DE POLICE OPTIMISÉE POUR LES VOIES FUSIONNÉES
                        Call AjusterTaillePoliceVoiesSelonLargeur(rngFusion, col - colDebut + 1)
                    End If
                    
                    col = col + 1
                End If
            End If
        Loop
    Next ligneVoie
End Sub

' =====================================================
' FONCTION UTILITAIRE : Nettoyer le nom pour qu'il soit valide comme nom de feuille Excel
' =====================================================
Function NettoyerNomFeuille(nomOriginal As String) As String
    Dim nomNettoye As String
    Dim caracteresInterdits As String
    Dim i As Integer
    
    ' Caractères interdits dans les noms de feuille Excel
    caracteresInterdits = "[\]/*?:"
    
    nomNettoye = Trim(nomOriginal)
    
    ' Remplacer les caractères interdits par des underscores
    For i = 1 To Len(caracteresInterdits)
        nomNettoye = Replace(nomNettoye, Mid(caracteresInterdits, i, 1), "_")
    Next i
    
    ' Supprimer les espaces multiples et les remplacer par un seul underscore
    Do While InStr(nomNettoye, "  ") > 0
        nomNettoye = Replace(nomNettoye, "  ", " ")
    Loop
    
    ' S'assurer que le nom n'est pas vide
    If Len(nomNettoye) = 0 Then
        nomNettoye = "Tournee"
    End If
    
    ' Limiter la longueur pour laisser de la place pour "Fac"
    If Len(nomNettoye) > 28 Then
        nomNettoye = Left(nomNettoye, 28)
    End If
    
    NettoyerNomFeuille = nomNettoye
End Function


' =====================================================
' GESTIONNAIRE UNIVERSEL DU MENU CONTEXTUEL
' =====================================================

Sub GererMenuContextuelUniversel(ws As Worksheet, Target As Range)
    ' Supprimer l'ancien menu
    Call SupprimerOptionMenuContextuel
    
    ' Déterminer le type de feuille et ajouter les options appropriées
    If InStr(ws.Name, "Fac") > 0 Then
        ' C'est une feuille façade
        Call AjouterMenuContextuelFacade(Target, ws)
    ElseIf EstFeuilleSource(ws) Then
        ' C'est une feuille source avec données PDI
        Call AjouterMenuContextuelSource(Target, ws)
    End If
End Sub

' =====================================================
' MENU CONTEXTUEL POUR FEUILLES FACADE
' =====================================================

Sub AjouterMenuContextuelFacade(Target As Range, ws As Worksheet)
    Dim menuContextuel As CommandBar
    Dim nouvelleOption As CommandBarButton
    
    ' Vérifier qu'on n'est pas dans la colonne des codes caisson
    If Target.Column = 27 Then Exit Sub
    
    Set menuContextuel = Application.CommandBars("Cell")
    
    ' Option principale : Navigation vers source
    Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, Before:=1)
    With nouvelleOption
        .Caption = "?? Naviguer vers ligne Source"
        .OnAction = "NaviguerDepuisFacadeVersSource"
        .Tag = "NavigationPDI"
        .FaceId = 1695
    End With
    
    ' Séparateur
    Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, Before:=2)
    With nouvelleOption
        .Caption = "-"
        .BeginGroup = True
        .Tag = "NavigationPDI"
    End With
    
    ' Options d'optimisation selon le contenu de la cellule
    If Not IsEmpty(Target.Value) Then
        Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, Before:=3)
        With nouvelleOption
            .Caption = "?? Optimiser cette zone"
            .OnAction = "OptimiserZoneSelectionnee"
            .Tag = "NavigationPDI"
        End With
    End If
    
    ' Option pour cellules vides
    If IsEmpty(Target.Value) Then
        Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, Before:=3)
        With nouvelleOption
            .Caption = "??? Insérer image ici"
            .OnAction = "InsererImageCellule"
            .Tag = "NavigationPDI"
        End With
    End If
End Sub

' =====================================================
' MENU CONTEXTUEL POUR FEUILLES SOURCE
' =====================================================

Sub AjouterMenuContextuelSource(Target As Range, ws As Worksheet)
    Dim menuContextuel As CommandBar
    Dim nouvelleOption As CommandBarButton
    
    ' Vérifier qu'on est dans la zone des données (ligne 7+, colonnes utiles)
    If Target.Row < 7 Or Target.Column > 8 Then Exit Sub
    
    ' Vérifier qu'il y a un code caisson en colonne H
    If ws.Cells(Target.Row, 8).Value = "" Then Exit Sub
    
    Set menuContextuel = Application.CommandBars("Cell")
    
    ' Option principale : Navigation vers façade
    Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, Before:=1)
    With nouvelleOption
        .Caption = "?? Naviguer vers case Façade"
        .OnAction = "NaviguerDepuisSourceVersFacade"
        .Tag = "NavigationPDI"
        .FaceId = 1695
    End With
    
    ' Option : Régénérer façade
    Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, Before:=2)
    With nouvelleOption
        .Caption = "?? Régénérer la façade"
        .OnAction = "GenererFacadePDI"
        .Tag = "NavigationPDI"
        .BeginGroup = True
    End With
End Sub

' =====================================================
' FONCTIONS DE NAVIGATION AMÉLIORÉES
' =====================================================

Sub NaviguerDepuisFacadeVersSource()
    Dim celluleCible As Range
    Dim wsSource As Worksheet
    Dim wsFacade As Worksheet
    Dim codePosition As String
    Dim ligneSourceCible As Long
    
    Set wsFacade = ActiveSheet
    Set celluleCible = Selection
    
    ' Trouver la feuille source correspondante
    Set wsSource = TrouverFeuilleSource(wsFacade)
    If wsSource Is Nothing Then
        MsgBox "? Impossible de trouver la feuille source correspondante.", vbExclamation, "Navigation impossible"
        Exit Sub
    End If
    
    ' Calculer le code de position
    codePosition = CalculerCodePosition(celluleCible, wsSource)
    If codePosition = "" Then
        MsgBox "? Impossible de calculer la position. Vérifiez que vous êtes sur une case valide.", vbExclamation, "Navigation impossible"
        Exit Sub
    End If
    
    ' Chercher la ligne correspondante
    ligneSourceCible = TrouverLigneAvecCode(wsSource, codePosition)
    If ligneSourceCible > 0 Then
        ' Navigation réussie
        wsSource.Activate
        wsSource.Cells(ligneSourceCible, 1).Select
        
        ' Message de confirmation optionnel
        Application.StatusBar = "? Navigation réussie vers " & wsSource.Name & " ligne " & ligneSourceCible
        Application.OnTime Now + TimeValue("00:00:03"), "EffacerStatusBar"
    Else
        MsgBox "? Position " & codePosition & " non trouvée dans la feuille source.", vbExclamation, "Navigation impossible"
    End If
End Sub

Sub NaviguerDepuisSourceVersFacade()
    Dim celluleCible As Range
    Dim wsSource As Worksheet
    Dim wsFacade As Worksheet
    Dim codePosition As String
    
    Set wsSource = ActiveSheet
    Set celluleCible = Selection
    
    ' Lire le code en colonne H
    codePosition = wsSource.Cells(celluleCible.Row, 8).Value
    If codePosition = "" Then
        MsgBox "? Aucun code de position trouvé sur cette ligne.", vbExclamation, "Navigation impossible"
        Exit Sub
    End If
    
    ' Trouver la feuille façade correspondante
    Set wsFacade = TrouverFeuilleFacade(wsSource)
    If wsFacade Is Nothing Then
        MsgBox "? Aucune feuille façade trouvée. Veuillez d'abord générer la façade.", vbExclamation, "Navigation impossible"
        Exit Sub
    End If
    
    ' Calculer et naviguer vers la position
    If NaviguerVersPositionFacade(wsFacade, codePosition, wsSource) Then
        Application.StatusBar = "? Navigation réussie vers " & wsFacade.Name
        Application.OnTime Now + TimeValue("00:00:03"), "EffacerStatusBar"
    Else
        MsgBox "? Position " & codePosition & " non trouvée dans la façade.", vbExclamation, "Navigation impossible"
    End If
End Sub

' =====================================================
' FONCTIONS UTILITAIRES AMÉLIORÉES
' =====================================================

Function EstFeuilleSource(ws As Worksheet) As Boolean
    ' Vérifier si c'est une feuille source en cherchant des indicateurs
    On Error Resume Next
    
    ' Vérifier s'il y a des données en colonne A à partir de la ligne 7
    If ws.Cells(7, 1).Value <> "" Then
        ' Vérifier s'il y a une valeur en C1 (max par caisson)
        If IsNumeric(ws.Range("C1").Value) Then
            EstFeuilleSource = True
            Exit Function
        End If
    End If
    
    EstFeuilleSource = False
    On Error GoTo 0
End Function

Function TrouverFeuilleSource(wsFacade As Worksheet) As Worksheet
    Dim ws As Worksheet
    Dim nomTournee As String
    
    ' Extraire le nom de la tournée du nom de la façade
    nomTournee = Replace(wsFacade.Name, "Fac", "")
    
    ' Chercher une feuille avec ce nom
    For Each ws In ThisWorkbook.Worksheets
        If ws.Name = nomTournee And EstFeuilleSource(ws) Then
            Set TrouverFeuilleSource = ws
            Exit Function
        End If
    Next ws
    
    ' Si pas trouvé par nom, chercher la feuille précédente
    On Error Resume Next
    Set ws = wsFacade.Previous
    If Not ws Is Nothing And EstFeuilleSource(ws) Then
        Set TrouverFeuilleSource = ws
        Exit Function
    End If
    On Error GoTo 0
    
    Set TrouverFeuilleSource = Nothing
End Function

Function TrouverFeuilleFacade(wsSource As Worksheet) As Worksheet
    Dim ws As Worksheet
    Dim nomTournee As String
    Dim nomFacadeAttendu As String
    
    ' Construire le nom de façade attendu
    nomTournee = Trim(CStr(wsSource.Range("A1").Value))
    If nomTournee = "" Then nomTournee = wsSource.Name
    nomFacadeAttendu = NettoyerNomFeuille(nomTournee) & "Fac"
    
    ' Chercher la feuille façade
    For Each ws In ThisWorkbook.Worksheets
        If ws.Name = nomFacadeAttendu Then
            Set TrouverFeuilleFacade = ws
            Exit Function
        End If
    Next ws
    
    ' Si pas trouvé par nom exact, chercher toute feuille contenant "Fac"
    For Each ws In ThisWorkbook.Worksheets
        If InStr(ws.Name, "Fac") > 0 And ws.Name <> wsSource.Name Then
            Set TrouverFeuilleFacade = ws
            Exit Function
        End If
    Next ws
    
    Set TrouverFeuilleFacade = Nothing
End Function

Function CalculerCodePosition(cellule As Range, wsSource As Worksheet) As String
    Dim ligneFacade As Long, colonneFacade As Long
    Dim maxParCaisson As Integer
    Dim numeroCaisson As Integer, lettreCaisson As String
    Dim indiceLigne As Integer, lettreIndex As Integer
    Dim numeroPosition As String
    
    On Error GoTo ErreurCalcul
    
    ' Obtenir la position de référence
    Set cellule = cellule.Cells(1, 1) ' Première cellule de la sélection
    ligneFacade = cellule.Row
    colonneFacade = cellule.Column
    
    ' Ajuster pour ligne du haut si on est sur ligne du bas
    If ligneFacade Mod 2 = 0 Then ligneFacade = ligneFacade - 1
    
    ' Pour cellules fusionnées, prendre la colonne de début
    If cellule.MergeCells Then
        colonneFacade = cellule.MergeArea.Column
    End If
    
    ' Récupérer les paramètres
    maxParCaisson = Val(wsSource.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4
    
    ' Calculer le caisson
    indiceLigne = (ligneFacade + 1) / 2
    numeroCaisson = ((indiceLigne - 1) Mod (maxParCaisson * 4)) Mod maxParCaisson + 1
    lettreIndex = ((indiceLigne - 1) \ maxParCaisson) Mod 4
    lettreCaisson = Chr(Asc("A") + lettreIndex)
    
    ' Construire le code
    numeroPosition = Format(colonneFacade, "00")
    CalculerCodePosition = numeroCaisson & lettreCaisson & " " & numeroPosition
    
    Exit Function
    
ErreurCalcul:
    CalculerCodePosition = ""
End Function

Function TrouverLigneAvecCode(ws As Worksheet, codeRecherche As String) As Long
    Dim i As Long
    Dim derniereLigne As Long
    
    derniereLigne = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    
    For i = 7 To derniereLigne
        If ws.Cells(i, 8).Value = codeRecherche Then
            TrouverLigneAvecCode = i
            Exit Function
        End If
    Next i
    
    TrouverLigneAvecCode = 0
End Function

Function NaviguerVersPositionFacade(wsFacade As Worksheet, codePosition As String, wsSource As Worksheet) As Boolean
    Dim partieCode As String, partiePosition As String
    Dim posEspace As Integer
    Dim numeroCaisson As Integer, lettreCaisson As String
    Dim maxParCaisson As Integer
    Dim lettreIndex As Integer, indiceLigne As Integer
    Dim ligneFacade As Integer, colonneFacade As Integer
    
    On Error GoTo ErreurNavigation
    
    ' Parser le code (ex: "2A 15")
    posEspace = InStr(codePosition, " ")
    If posEspace = 0 Then GoTo ErreurNavigation
    
    partieCode = Left(codePosition, posEspace - 1)
    partiePosition = Right(codePosition, Len(codePosition) - posEspace)
    
    ' Extraire numéro et lettre
    numeroCaisson = Val(Left(partieCode, Len(partieCode) - 1))
    lettreCaisson = Right(partieCode, 1)
    colonneFacade = Val(partiePosition)
    
    ' Calculer la ligne
    maxParCaisson = Val(wsSource.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4
    
    lettreIndex = Asc(lettreCaisson) - Asc("A")
    indiceLigne = (lettreIndex * maxParCaisson) + numeroCaisson
    ligneFacade = (indiceLigne * 2) - 1
    
    ' Naviguer
    wsFacade.Activate
    wsFacade.Cells(ligneFacade, colonneFacade).Select
    
    NaviguerVersPositionFacade = True
    Exit Function
    
ErreurNavigation:
    NaviguerVersPositionFacade = False
End Function

' =====================================================
' NETTOYAGE ET UTILITAIRES
' =====================================================

Sub EffacerStatusBar()
    Application.StatusBar = False
End Sub

' Version améliorée de la suppression du menu contextuel
Sub SupprimerOptionMenuContextuel()
    Dim ctrl As CommandBarControl
    Dim menuContextuel As CommandBar
    Dim i As Integer
    
    On Error Resume Next
    Set menuContextuel = Application.CommandBars("Cell")
    
    ' Supprimer en partant de la fin pour éviter les décalages d'index
    For i = menuContextuel.Controls.Count To 1 Step -1
        Set ctrl = menuContextuel.Controls(i)
        If ctrl.Tag = "NavigationPDI" Then
            ctrl.Delete
        End If
    Next i
    
    On Error GoTo 0
End Sub

' =====================================================
' MACROS POUR LES OPTIONS DU MENU CONTEXTUEL
' =====================================================

Sub OptimiserZoneSelectionnee()
    Dim cellule As Range
    Set cellule = Selection
    
    MsgBox "?? Optimisation de la zone autour de " & cellule.Address & vbCrLf & _
           "Cette fonctionnalité peut être développée selon vos besoins spécifiques.", _
           vbInformation, "Optimisation locale"
End Sub

Sub InsererImageCellule()
    Dim cellule As Range
    Set cellule = Selection
    
    If IsEmpty(cellule.Value) Then
        ' Appeler la fonction d'insertion d'image existante ou créer une nouvelle
        MsgBox "??? Insertion d'image dans " & cellule.Address & vbCrLf & _
               "Sélectionnez un fichier image à insérer.", _
               vbInformation, "Insertion d'image"
        ' Ici vous pouvez appeler votre fonction d'insertion d'image existante
        ' Call InsererImagesDansCellulesVides
    Else
        MsgBox "?? Cette cellule n'est pas vide. Veuillez sélectionner une cellule vide.", _
               vbExclamation, "Cellule non vide"
    End If
End Sub

' =====================================================
' SUB : Gérer les changements en temps réel de la colonne G - CALCUL PAR CAISSON
' =====================================================
Sub GererChangementColonneG(Target As Range)
    Dim wsSource As Worksheet
    
    ' Vérifier si le changement concerne la colonne G (largeur) et ligne >= 7
    If Target.Column <> 7 Or Target.Row < 7 Then Exit Sub
    
    ' MODIFICATION : Utiliser la feuille où le changement a eu lieu
    Set wsSource = Target.Worksheet
    
    ' Désactiver les événements pour éviter les boucles
    Application.EnableEvents = False
    
    ' Recalculer les cellules vides pour tous les caissons
    Call RecalculerCellulesVidesParCaisson(wsSource)
    
    ' Réactiver les événements
    Application.EnableEvents = True
    
End Sub

' =====================================================
' SUB : Recalculer les cellules vides par caisson
' =====================================================
Sub RecalculerCellulesVidesParCaisson(ws As Worksheet)
    Dim maxParCaisson As Integer
    Dim derniereLigne As Long
    Dim i As Long
    Dim largeurActuelle As Integer
    Dim colonneVirtuelle As Integer
    Dim ligneVirtuelle As Integer
    Dim numeroCaisson As Integer
    Dim lettreCaisson As String
    Dim horsCapacitePermanent As Boolean
    Dim dictCaissonsLignes As Object ' Pour stocker la dernière ligne de chaque caisson
    Dim dictCaissonsVides As Object ' Pour stocker le nombre de cellules vides par caisson
    Dim codeCaisson As String
    Dim ligneDebutCaisson As Long
    
    ' Récupérer la valeur max par caisson
    maxParCaisson = Val(ws.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4
    
    ' Créer les dictionnaires
    Set dictCaissonsLignes = CreateObject("Scripting.Dictionary")
    Set dictCaissonsVides = CreateObject("Scripting.Dictionary")
    
    ' Initialiser les compteurs
    colonneVirtuelle = 1
    numeroCaisson = 1
    lettreCaisson = "A"
    horsCapacitePermanent = False
    derniereLigne = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    ligneDebutCaisson = 7
    
    ' Effacer d'abord toute la colonne W
    ws.Range("W7:W" & derniereLigne).ClearContents
    
    ' Parcourir toutes les lignes pour simuler la disposition
    For i = 7 To derniereLigne
        largeurActuelle = ConvertirEnEntier(ws.Cells(i, 7).Value, 0)
        
        ' Si on a une largeur > 0, c'est un bloc PDI
        If largeurActuelle > 0 Then
            ' Vérifier si on dépasse la colonne Z (26)
            If colonneVirtuelle + largeurActuelle - 1 > 26 Then
                ' Finaliser le caisson précédent
                codeCaisson = numeroCaisson & lettreCaisson
                If Not horsCapacitePermanent And Not CaissonDepasse(codeCaisson, maxParCaisson) Then
                    ' Calculer les cellules vides du caisson précédent
                    Dim cellulesVides As Integer
                    cellulesVides = 26 - colonneVirtuelle + 1
                    
                    ' Stocker dans le dictionnaire avec la dernière ligne du caisson
                    If ligneDebutCaisson > 0 Then
                        dictCaissonsVides.Add codeCaisson, cellulesVides
                        dictCaissonsLignes.Add codeCaisson, i - 1 ' Ligne précédente = dernière du caisson
                    End If
                End If
                
                ' Passer au caisson suivant
                colonneVirtuelle = 1
                numeroCaisson = numeroCaisson + 1
                ligneDebutCaisson = i
                
                ' Gérer le passage à la lettre suivante
                If numeroCaisson > maxParCaisson Then
                    numeroCaisson = 1
                    If lettreCaisson = "D" Then
                        horsCapacitePermanent = True
                        lettreCaisson = "A"
                    Else
                        lettreCaisson = Chr(Asc(lettreCaisson) + 1)
                        If lettreCaisson > "D" And Not horsCapacitePermanent Then
                            horsCapacitePermanent = True
                            lettreCaisson = "A"
                            numeroCaisson = 1
                        End If
                    End If
                End If
            End If
            
            ' Avancer la position virtuelle
            colonneVirtuelle = colonneVirtuelle + largeurActuelle
        End If
    Next i
    
    ' Finaliser le dernier caisson
    codeCaisson = numeroCaisson & lettreCaisson
    If Not horsCapacitePermanent And Not CaissonDepasse(codeCaisson, maxParCaisson) Then
        If colonneVirtuelle <= 26 Then
            cellulesVides = 26 - colonneVirtuelle + 1
            dictCaissonsVides.Add codeCaisson, cellulesVides
            dictCaissonsLignes.Add codeCaisson, derniereLigne
        End If
    End If
    
    ' Maintenant, écrire les valeurs dans la colonne W seulement sur les dernières lignes de chaque caisson
    Dim cle As Variant
    For Each cle In dictCaissonsLignes.Keys
        Dim ligneCible As Long
        ligneCible = dictCaissonsLignes(cle)
        ws.Cells(ligneCible, 23).Value = dictCaissonsVides(cle) ' Colonne W = 23
    Next cle
    
End Sub

' =====================================================
' SUB : Ajuster la taille de police intelligemment selon contenu et largeur
' =====================================================
Sub AjusterTaillePoliceIntelligente(rng As Range, largeurCellule As Integer, contenu As String, estVoie As Boolean)
    Dim tailleOptimale As Integer
    Dim tailleMax As Integer
    Dim tailleMin As Integer
    Dim longueurMaxLigne As Integer
    Dim nbLignesEstimees As Integer
    
    ' Définir les limites de taille selon le type de contenu
    If estVoie Then
        ' Pour les noms de voies : plus de liberté
        tailleMin = 6
        tailleMax = 28
    Else
        ' Pour les numéros PDI : plus conservateur
        tailleMin = 6
        tailleMax = 16
    End If
    
    ' Analyser le contenu et estimer la répartition des lignes
    Call AnalyserContenuAvecWrapText(contenu, largeurCellule, longueurMaxLigne, nbLignesEstimees)
    
    ' Calculer la taille optimale basée sur l'espace disponible
    tailleOptimale = CalculerTailleOptimaleAvecWrap(largeurCellule, longueurMaxLigne, nbLignesEstimees, estVoie)
    
    ' Appliquer les limites
    If tailleOptimale < tailleMin Then tailleOptimale = tailleMin
    If tailleOptimale > tailleMax Then tailleOptimale = tailleMax
    
    ' Appliquer la taille
    With rng.Font
        .Size = tailleOptimale
    End With
End Sub

' =====================================================
' SUB : Analyser le contenu en tenant compte du WrapText - VERSION CONSERVATRICE
' =====================================================
Sub AnalyserContenuAvecWrapText(contenu As String, largeurCellule As Integer, ByRef longueurMaxLigne As Integer, ByRef nbLignesEstimees As Integer)
    Dim lignesExplicites As Variant
    Dim i As Integer, j As Integer
    Dim ligneActuelle As String
    Dim mots As Variant
    Dim longueurLigneActuelle As Integer
    Dim capaciteParLigne As Integer
    Dim lignesFinales As Collection
    
    ' Estimer la capacité de caractères par ligne selon la largeur - PLUS CONSERVATEUR
    ' Réduction significative pour éviter tout débordement
    Select Case largeurCellule
        Case 1
            capaciteParLigne = 5   ' Très conservateur pour 1 colonne
        Case 2
            capaciteParLigne = 10  ' Conservateur pour 2 colonnes
        Case 3
            capaciteParLigne = 16  ' 3 colonnes
        Case 4
            capaciteParLigne = 22  ' 4 colonnes
        Case 5
            capaciteParLigne = 28  ' 5 colonnes
        Case Else
            capaciteParLigne = largeurCellule * 6  ' Formule conservatrice
    End Select
    
    Set lignesFinales = New Collection
    longueurMaxLigne = 0
    
    ' Si le contenu est vide, valeurs par défaut
    If Len(contenu) = 0 Then
        longueurMaxLigne = 1
        nbLignesEstimees = 1
        Exit Sub
    End If
    
    ' Séparer d'abord par les sauts de ligne explicites (vbCrLf)
    If InStr(contenu, vbCrLf) > 0 Then
        lignesExplicites = Split(contenu, vbCrLf)
    Else
        ReDim lignesExplicites(0)
        lignesExplicites(0) = contenu
    End If
    
    ' Pour chaque ligne explicite, analyser le wrap automatique
    For i = 0 To UBound(lignesExplicites)
        ligneActuelle = Trim(lignesExplicites(i))
        
        ' Si la ligne est courte, pas de wrap nécessaire
        If Len(ligneActuelle) <= capaciteParLigne Then
            lignesFinales.Add ligneActuelle
            If Len(ligneActuelle) > longueurMaxLigne Then
                longueurMaxLigne = Len(ligneActuelle)
            End If
        Else
            ' La ligne est trop longue, simuler le wrap par mots
            mots = Split(ligneActuelle, " ")
            Dim ligneEnCours As String
            ligneEnCours = ""
            
            For j = 0 To UBound(mots)
                ' Tester si on peut ajouter le mot suivant
                Dim ligneTest As String
                If ligneEnCours = "" Then
                    ligneTest = mots(j)
                Else
                    ligneTest = ligneEnCours & " " & mots(j)
                End If
                
                ' Si ça rentre encore, continuer
                If Len(ligneTest) <= capaciteParLigne Then
                    ligneEnCours = ligneTest
                Else
                    ' Finir la ligne actuelle et commencer une nouvelle
                    If ligneEnCours <> "" Then
                        lignesFinales.Add ligneEnCours
                        If Len(ligneEnCours) > longueurMaxLigne Then
                            longueurMaxLigne = Len(ligneEnCours)
                        End If
                    End If
                    ligneEnCours = mots(j)
                End If
            Next j
            
            ' Ajouter la dernière ligne en cours
            If ligneEnCours <> "" Then
                lignesFinales.Add ligneEnCours
                If Len(ligneEnCours) > longueurMaxLigne Then
                    longueurMaxLigne = Len(ligneEnCours)
                End If
            End If
        End If
    Next i
    
    ' Résultats finaux
    nbLignesEstimees = lignesFinales.Count
    If longueurMaxLigne = 0 Then longueurMaxLigne = 1
    
End Sub

' =====================================================
' FONCTION : Calculer la taille optimale avec WrapText - VERSION SÉCURISÉE
' =====================================================
Function CalculerTailleOptimaleAvecWrap(largeurCellule As Integer, longueurMaxLigne As Integer, nbLignesEstimees As Integer, estVoie As Boolean) As Integer
    Dim espaceHorizontal As Double
    Dim espaceVertical As Double
    Dim tailleParLargeur As Integer
    Dim tailleParHauteur As Integer
    Dim tailleOptimale As Integer
    Dim margeSecurite As Double
    
    ' Marges de sécurité pour éviter tout débordement
    margeSecurite = 0.7  ' Utiliser seulement 70% de l'espace estimé
    
    ' Estimer l'espace horizontal disponible - PLUS CONSERVATEUR
    espaceHorizontal = largeurCellule * 20 * margeSecurite ' Réduit de 25 à 20 pixels
    
    ' Estimer l'espace vertical disponible - PLUS CONSERVATEUR
    If estVoie Then
        espaceVertical = 35 * margeSecurite ' Réduit de 39 à 35
    Else
        espaceVertical = 43 * margeSecurite ' Réduit de 48.75 à 43
    End If
    
    ' Calculer la taille optimale selon la largeur (contrainte horizontale)
    If longueurMaxLigne > 0 Then
        tailleParLargeur = Int(espaceHorizontal / (longueurMaxLigne * 1.6)) ' Augmenté de 1.3 à 1.6
    Else
        tailleParLargeur = 8
    End If
    
    ' Calculer la taille optimale selon la hauteur (contrainte verticale)
    If nbLignesEstimees > 0 Then
        tailleParHauteur = Int(espaceVertical / (nbLignesEstimees * 1.8)) ' Augmenté de 1.4 à 1.8
    Else
        tailleParHauteur = 8
    End If
    
    ' Prendre la contrainte la plus restrictive
    tailleOptimale = Application.WorksheetFunction.Min(tailleParLargeur, tailleParHauteur)
    
    ' Limites absolues de sécurité
    If estVoie Then
        ' Pour les voies : limites plus strictes
        Select Case largeurCellule
            Case 1
                If tailleOptimale > 7 Then tailleOptimale = 7   ' Max très bas pour 1 col
                If tailleOptimale < 6 Then tailleOptimale = 6
            Case 2
                If tailleOptimale > 9 Then tailleOptimale = 9   ' Max bas pour 2 col
                If tailleOptimale < 7 Then tailleOptimale = 7
            Case 3
                If tailleOptimale > 11 Then tailleOptimale = 11
                If tailleOptimale < 8 Then tailleOptimale = 8
            Case 4
                If tailleOptimale > 13 Then tailleOptimale = 13
                If tailleOptimale < 9 Then tailleOptimale = 9
            Case Else
                If tailleOptimale > 16 Then tailleOptimale = 16
                If tailleOptimale < 10 Then tailleOptimale = 10
        End Select
    Else
        ' Pour les numéros : encore plus conservateur
        Select Case largeurCellule
            Case 1
                If tailleOptimale > 6 Then tailleOptimale = 6   ' Max très bas
                If tailleOptimale < 6 Then tailleOptimale = 6
            Case 2
                If tailleOptimale > 8 Then tailleOptimale = 8
                If tailleOptimale < 6 Then tailleOptimale = 6
            Case 3
                If tailleOptimale > 10 Then tailleOptimale = 10
                If tailleOptimale < 7 Then tailleOptimale = 7
            Case Else
                If tailleOptimale > 12 Then tailleOptimale = 12
                If tailleOptimale < 8 Then tailleOptimale = 8
        End Select
    End If
    
    CalculerTailleOptimaleAvecWrap = tailleOptimale
End Function

' =====================================================
' SUB : Ajuster la taille de police selon la largeur de cellule - VERSION SÉCURISÉE
' =====================================================
Sub AjusterTaillePoliceSelonLargeur(rng As Range, largeurCellule As Integer)
    ' Cette fonction est maintenant un wrapper pour la version intelligente
    ' On analyse le contenu de la cellule de manière sécurisée
    Dim contenu As String
    Dim valeurCellule As Variant
    
    ' Récupération sécurisée du contenu
    On Error Resume Next
    valeurCellule = rng.Value
    If Err.Number <> 0 Or IsNull(valeurCellule) Or IsEmpty(valeurCellule) Then
        contenu = ""
        Err.Clear
    Else
        contenu = CStr(valeurCellule)
    End If
    On Error GoTo 0
    
    Call AjusterTaillePoliceIntelligente(rng, largeurCellule, contenu, False) ' False = numéros PDI
End Sub

' =====================================================
' SUB : Ajuster la taille de police pour les noms de voies - VERSION SÉCURISÉE
' =====================================================
Sub AjusterTaillePoliceVoiesSelonLargeur(rng As Range, largeurCellule As Integer)
    ' Cette fonction est maintenant un wrapper pour la version intelligente
    ' On analyse le contenu de la cellule de manière sécurisée
    Dim contenu As String
    Dim valeurCellule As Variant
    
    ' Récupération sécurisée du contenu
    On Error Resume Next
    valeurCellule = rng.Value
    If Err.Number <> 0 Or IsNull(valeurCellule) Or IsEmpty(valeurCellule) Then
        contenu = ""
        Err.Clear
    Else
        contenu = CStr(valeurCellule)
    End If
    On Error GoTo 0
    
    Call AjusterTaillePoliceIntelligente(rng, largeurCellule, contenu, True) ' True = noms de voies
End Sub

' =====================================================
' SUB : Appliquer un formatage différencié pour numéros et observations - SANS ÉCRASER LES TAILLES
' =====================================================
Sub AppliquerFormatageDifferencie(rng As Range, symbole As String, numAccumule As String, obsAccumulees As String)
    Dim longueurNumeroAvecSymbole As Integer
    Dim debutObservations As Integer
    
    ' Calculer la longueur de la partie numéro + symbole
    longueurNumeroAvecSymbole = Len(symbole & numAccumule)
    
    ' Vérifier qu'on a quelque chose à formater
    If longueurNumeroAvecSymbole = 0 Then Exit Sub
    
    ' Formatage avec gestion d'erreur complète
    On Error GoTo FormatageFallback
    
    ' Si pas d'observations, formater tout en gras
    If obsAccumulees = "" Then
        ' Tout le texte (symbole + numéro) en gras - SANS MODIFIER LA TAILLE
        rng.Characters(1, longueurNumeroAvecSymbole).Font.Bold = True
    Else
        ' Formater la partie numéro (symbole + numéro) : gras - SANS MODIFIER LA TAILLE
        rng.Characters(1, longueurNumeroAvecSymbole).Font.Bold = True
        
        ' Formater la partie observations (après le saut de ligne) : pas gras - SANS MODIFIER LA TAILLE
        debutObservations = longueurNumeroAvecSymbole + 2 ' +2 pour vbCrLf (saut de ligne)
        
        If Len(obsAccumulees) > 0 Then
            rng.Characters(debutObservations, Len(obsAccumulees)).Font.Bold = False
        End If
    End If
    
    On Error GoTo 0
    Exit Sub
    
FormatageFallback:
    ' En cas d'erreur, appliquer un formatage global simple - SANS MODIFIER LA TAILLE
    On Error Resume Next
    rng.Font.Bold = True
    On Error GoTo 0
    
End Sub

' =====================================================
' SUB MODIFIÉE : Ajouter les boutons avec macros intégrées - DISPOSITION VERTICALE COLONNE AC
' =====================================================
Sub AjouterBoutonsSeulement(wsFacade As Worksheet)
    Dim btn As Object
    Dim positionX As Double
    Dim espacement As Double
    Dim largeurBouton As Double
    Dim hauteurBouton As Double
    
    ' Supprimer les boutons existants s'ils existent
    Dim shp As Shape
    For Each shp In wsFacade.Shapes
        If shp.Type = msoFormControl Then shp.Delete
    Next shp
    
    ' Configuration de la disposition verticale en colonne AC
    positionX = wsFacade.Columns("AC").Left + 2  ' Position X en colonne AC avec petite marge
    largeurBouton = wsFacade.Columns("AC").Width + 80  ' Largeur adaptée à la colonne moins marges
    hauteurBouton = 25  ' Hauteur standard des boutons
    espacement = 20     ' Espacement vertical entre les boutons
    
    ' BOUTON 1 : Optimiser Affichage
    Set btn = wsFacade.Buttons.Add(positionX, 10, largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "1. Supprimer contenu voies uniques"
        .OnAction = "OptimiserAffichageFromButton"
        .Font.Bold = True
        .Font.Size = 9
    End With
    
    ' BOUTON 2 : Insérer Images
    Set btn = wsFacade.Buttons.Add(positionX, 10 + (espacement * 2), largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "2. Insérer Images voies uniques"
        .OnAction = "InsererImagesFromButton"
        .Font.Bold = True
        .Font.Size = 9
    End With
        
    ' BOUTON 3 : Simplifier Bornes
    Set btn = wsFacade.Buttons.Add(positionX, 10 + (espacement * 4), largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "3. Simplifier Bornes"
        .OnAction = "SimplificationBornesNumPDI"
        .Font.Bold = True
        .Font.Size = 9
    End With
    
     ' BOUTON 4 : Ajuster Polices Intelligentes
    Set btn = wsFacade.Buttons.Add(positionX, 10 + (espacement * 6), largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "4. Ajuster taille polices"
        .OnAction = "AjusterPolicesFromButton"
        .Font.Bold = True
        .Font.Size = 9
    End With
    
End Sub

' =====================================================
' NOUVELLES MACROS POUR LES BOUTONS
' =====================================================

Sub OptimiserAffichageFromButton()
    ' Macro appelée par le bouton "Optimiser Affichage"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur la bonne feuille
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit être utilisée sur une feuille façade", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant exécution
    If MsgBox("Voulez-vous optimiser l'affichage de la façade ?" & vbCrLf & _
              "Cette action va supprimer les numéros uniques pour simplifier la vue.", _
              vbQuestion + vbYesNo, "Optimiser Affichage") = vbYes Then
        
        ' Exécuter la macro d'optimisation
        Call OptimiserAffichageFacade
    End If
End Sub

Sub SimplifierBornesFromButton()
    ' Macro appelée par le bouton "Simplifier Bornes"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur la bonne feuille
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit être utilisée sur une feuille façade", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant exécution
    If MsgBox("Voulez-vous simplifier les bornes de numéros ?" & vbCrLf & _
              "Cette action va regrouper les numéros consécutifs en plages.", _
              vbQuestion + vbYesNo, "Simplifier Bornes") = vbYes Then
        
        ' Exécuter la macro de simplification des bornes
        Call SimplificationBornesNumPDIMultivoies
    End If
End Sub

Sub AjusterPolicesFromButton()
    ' Macro appelée par le bouton "Ajuster Polices"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur la bonne feuille
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit être utilisée sur une feuille façade", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant exécution
    If MsgBox("Voulez-vous ajuster automatiquement la taille des polices ?" & vbCrLf & _
              "Cette action va optimiser la lisibilité selon la taille des cellules.", _
              vbQuestion + vbYesNo, "Ajuster Polices") = vbYes Then
        
        ' Exécuter la macro d'ajustement des polices
        'Call AjusterTaillePolice
    End If
End Sub

Sub InsererImagesFromButton()
    ' Macro appelée par le bouton "Insérer Images"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur la bonne feuille
    If InStr(ws.Name, "Fac") = 0 Then
        MsgBox "Cette fonction doit être utilisée sur une feuille façade", vbExclamation
        Exit Sub
    End If
    
    ' Message d'information et confirmation
    If MsgBox("Voulez-vous insérer des images dans les cellules vides ?" & vbCrLf & _
              "Vous devrez sélectionner un fichier image à utiliser.", _
              vbQuestion + vbYesNo, "Insérer Images") = vbYes Then
        
        ' Exécuter la macro d'insertion d'images
        Call InsererImagesDansCellulesVides
    End If
End Sub

' =====================================================
' FONCTION CORRIGÉE : Vérifier si un caisson dépasse la limite
' =====================================================
Function CaissonDepasse(codeCaisson As String, maxParCaisson As Integer) As Boolean
    ' Extraire le numéro et la lettre du code caisson
    ' Format : "1A", "2B", etc.
    Dim numero As Integer
    Dim lettre As String
    
    If Len(codeCaisson) >= 2 Then
        numero = Val(Left(codeCaisson, Len(codeCaisson) - 1))
        lettre = Right(codeCaisson, 1)
        
        ' LOGIQUE CORRIGÉE : on dépasse si on est au-delà de [maxParCaisson]D
        ' Exemples avec maxParCaisson = 7 :
        ' - 1A à 7D : OK (dans la capacité)
        ' - 8D, 9D, etc. : DÉPASSE (hors capacité)
        ' - 1E, 2E, etc. : DÉPASSE (lettre après D)
        
        If lettre > "D" Then
            ' Toute lettre après D dépasse automatiquement
            CaissonDepasse = True
        ElseIf lettre = "D" And numero > maxParCaisson Then
            ' Pour la lettre D, on dépasse si le numéro > maxParCaisson
            CaissonDepasse = True
        Else
            ' Dans tous les autres cas, c'est dans la capacité
            CaissonDepasse = False
        End If
    Else
        CaissonDepasse = False
    End If
End Function

' =====================================================
' SUB AMÉLIORÉE : Mettre à jour la colonne H avec couleur
' =====================================================
Sub MettreAJourColonneHAvecCouleur(wsSource As Worksheet, dictCodes As Object, dictHorsCapacite As Object)
    Dim ligne As Long
    Dim cle As Variant
    
    ' Parcourir toutes les clés du dictionnaire (numéros de ligne)
    For Each cle In dictCodes.Keys
        ligne = CLng(cle)
        
        ' Mettre à jour la colonne H (colonne 8) avec le code calculé
        wsSource.Cells(ligne, 8).Value = dictCodes(cle)
        
        ' Si cette ligne est hors capacité, la colorer en rouge
        If dictHorsCapacite.Exists(ligne) Then
            With wsSource.Cells(ligne, 8)
                .Interior.Color = RGB(255, 0, 0) ' Fond rouge
                .Font.Color = RGB(255, 255, 255) ' Texte blanc
                .Font.Bold = True
            End With
        Else
            ' Réinitialiser le formatage pour les cases normales
            With wsSource.Cells(ligne, 8)
                .Interior.Pattern = xlNone ' Pas de couleur de fond
                .Font.Color = RGB(0, 0, 0) ' Texte noir
                .Font.Bold = False
            End With
        End If
    Next cle
End Sub

' =====================================================
' SUB : Mettre à jour les cellules vides dans la feuille source - MODIFIÉE POUR DERNIÈRE LIGNE PAR CAISSON
' =====================================================
Sub MettreAJourCellulesVides(wsSource As Worksheet, wsFacade As Worksheet, colonneMiseAJour As String)
    ' Utiliser la nouvelle logique de calcul par caisson
    Call RecalculerCellulesVidesParCaisson(wsSource)
End Sub

' =====================================================
' FONCTION : Abréger les types de voies
' =====================================================
Function AbregerTypeVoie(nomVoie As String) As String
    Dim result As String
    result = nomVoie
    
    ' Remplacer les types de voies par leurs abréviations
    ' Ordre important : les plus longs d'abord pour éviter les conflits
    result = Replace(result, "Chemin de Grande communication", "CHDG", , , vbTextCompare)
    result = Replace(result, "Chemin de Liaison", "CHDL", , , vbTextCompare)
    result = Replace(result, "Chemin de Petite transport", "CRPT", , , vbTextCompare)
    result = Replace(result, "Impasse en cul-de-sac", "IMP-CUL", , , vbTextCompare)
    result = Replace(result, "Prolongement", "PROL", , , vbTextCompare)
    result = Replace(result, "Boulevard", "BD", , , vbTextCompare)
    result = Replace(result, "Avenue", "AV", , , vbTextCompare)
    result = Replace(result, "Route", "RTE", , , vbTextCompare)
    result = Replace(result, "Impasse", "IMP", , , vbTextCompare)
    result = Replace(result, "Chemin", "CH", , , vbTextCompare)
    result = Replace(result, "Place", "PL", , , vbTextCompare)
    result = Replace(result, "Allée", "ALL", , , vbTextCompare)
    result = Replace(result, "Square", "SQ", , , vbTextCompare)
    result = Replace(result, "Voie", "V", , , vbTextCompare)
    result = Replace(result, "Quai", "QU", , , vbTextCompare)
    result = Replace(result, "Passage", "PSG", , , vbTextCompare)
    result = Replace(result, "Sentier", "SENT", , , vbTextCompare)
    result = Replace(result, "Traversée", "TR", , , vbTextCompare)
    result = Replace(result, "Lotissement", "LOT", , , vbTextCompare)
    result = Replace(result, "Résidence", "RES", , , vbTextCompare)
    result = Replace(result, "Cité", "CIT", , , vbTextCompare)
    result = Replace(result, "Hameau", "H", , , vbTextCompare)
    result = Replace(result, "Parc", "PARC", , , vbTextCompare)
    result = Replace(result, "Pâture", "PAT", , , vbTextCompare)
    result = Replace(result, "Petite rue", "PTE", , , vbTextCompare)
    result = Replace(result, "Galerie", "GAL", , , vbTextCompare)
    result = Replace(result, "Places", "PL", , , vbTextCompare)
    result = Replace(result, "Ruelle", "RLE", , , vbTextCompare)
    result = Replace(result, "Promenade", "PR", , , vbTextCompare)
    result = Replace(result, "Esplanade", "ESPL", , , vbTextCompare)
    result = Replace(result, "Pont", "PT", , , vbTextCompare)
    result = Replace(result, "Vallée", "VAL", , , vbTextCompare)
    result = Replace(result, "Val", "VAL", , , vbTextCompare)
    
    ' Gérer les cas avec "de", "du", "des", "de la"
    result = Replace(result, " de la ", " ", , , vbTextCompare)
    result = Replace(result, " du ", " ", , , vbTextCompare)
    result = Replace(result, " des ", " ", , , vbTextCompare)
    result = Replace(result, " de ", " ", , , vbTextCompare)
    result = Replace(result, " d'", " ", , , vbTextCompare)
    
    ' Nettoyer les espaces doubles
    Do While InStr(result, "  ") > 0
        result = Replace(result, "  ", " ")
    Loop
    
    AbregerTypeVoie = Trim(result)
End Function

' =====================================================
' SUB : Ajouter le code caisson en colonne AA
' =====================================================
Sub AjouterCodeCaisson(ws As Worksheet, ligne As Long, code As String)
    Dim rngCode As Range
    
    ' Fusionner les 2 lignes en colonne AA
    Set rngCode = ws.Range(ws.Cells(ligne, 27), ws.Cells(ligne + 1, 27))
    rngCode.Merge
    
    ' Ajouter le code
    With rngCode
        .NumberFormat = "@" ' Format texte
        .Value = code
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .Font.Bold = True
        .Font.Size = 12
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin ' Bordures simples
        
        ' Si c'est "HC", colorer en rouge
        If code = "HC" Then
            .Interior.Color = RGB(255, 0, 0) ' Fond rouge
            .Font.Color = RGB(255, 255, 255) ' Texte blanc
        Else
            .Interior.Pattern = xlNone ' Pas de couleur
            .Font.Color = RGB(0, 0, 0) ' Texte noir
        End If
    End With
End Sub

' =====================================================
' FONCTION : Conversion sécurisée en entier
' =====================================================
Function ConvertirEnEntier(valeur As Variant, valeurParDefaut As Integer) As Integer
    On Error Resume Next
    ConvertirEnEntier = CInt(valeur)
    If Err.Number <> 0 Then
        ConvertirEnEntier = valeurParDefaut
        Err.Clear
    End If
    On Error GoTo 0
End Function



' =====================================================
' GESTION DES COULEURS ÉTENDUES
' =====================================================

' Initialise une palette de couleurs étendues avec 150+ couleurs distinctes
Sub InitialiserPaletteCouleursEtendues(dictPalette As Object)
    Dim i As Integer
    i = 0
    
    ' SÉRIE 1: COULEURS VIVES ET CONTRASTÉES (20 couleurs)
    dictPalette.Add i, RGB(255, 87, 87):   i = i + 1  ' Rouge corail
    dictPalette.Add i, RGB(255, 183, 77):  i = i + 1  ' Orange doré
    dictPalette.Add i, RGB(255, 235, 59):  i = i + 1  ' Jaune vif
    dictPalette.Add i, RGB(139, 195, 74):  i = i + 1  ' Vert lime
    dictPalette.Add i, RGB(38, 166, 154):  i = i + 1  ' Vert émeraude
    dictPalette.Add i, RGB(41, 182, 246):  i = i + 1  ' Bleu cyan
    dictPalette.Add i, RGB(92, 107, 192):  i = i + 1  ' Indigo
    dictPalette.Add i, RGB(186, 104, 200): i = i + 1  ' Violet
    dictPalette.Add i, RGB(240, 98, 146):  i = i + 1  ' Rose fuchsia
    dictPalette.Add i, RGB(255, 138, 101): i = i + 1  ' Saumon
    dictPalette.Add i, RGB(78, 175, 79):   i = i + 1  ' Vert forêt
    dictPalette.Add i, RGB(3, 169, 244):   i = i + 1  ' Bleu ciel
    dictPalette.Add i, RGB(156, 39, 176):  i = i + 1  ' Pourpre
    dictPalette.Add i, RGB(255, 87, 34):   i = i + 1  ' Orange rouge
    dictPalette.Add i, RGB(205, 220, 57):  i = i + 1  ' Jaune vert
    dictPalette.Add i, RGB(0, 188, 212):   i = i + 1  ' Turquoise
    dictPalette.Add i, RGB(103, 58, 183):  i = i + 1  ' Violet profond
    dictPalette.Add i, RGB(233, 30, 99):   i = i + 1  ' Rose vif
    dictPalette.Add i, RGB(121, 85, 72):   i = i + 1  ' Brun
    dictPalette.Add i, RGB(84, 110, 122):  i = i + 1  ' Bleu gris
    
    ' SÉRIE 2: COULEURS PASTEL DISTINCTIVES (20 couleurs)
    dictPalette.Add i, RGB(255, 205, 210): i = i + 1  ' Rose pâle
    dictPalette.Add i, RGB(255, 224, 178): i = i + 1  ' Pêche
    dictPalette.Add i, RGB(255, 249, 196): i = i + 1  ' Jaune pastel
    dictPalette.Add i, RGB(220, 237, 200): i = i + 1  ' Vert menthe
    dictPalette.Add i, RGB(178, 223, 219): i = i + 1  ' Vert d'eau
    dictPalette.Add i, RGB(187, 222, 251): i = i + 1  ' Bleu clair
    dictPalette.Add i, RGB(209, 196, 233): i = i + 1  ' Lavande
    dictPalette.Add i, RGB(248, 187, 208): i = i + 1  ' Rose poudrée
    dictPalette.Add i, RGB(255, 204, 188): i = i + 1  ' Abricot
    dictPalette.Add i, RGB(200, 230, 201): i = i + 1  ' Vert tendre
    dictPalette.Add i, RGB(179, 229, 252): i = i + 1  ' Bleu poudrée
    dictPalette.Add i, RGB(225, 190, 231): i = i + 1  ' Mauve clair
    dictPalette.Add i, RGB(255, 171, 145): i = i + 1  ' Corail clair
    dictPalette.Add i, RGB(240, 244, 195): i = i + 1  ' Citron vert
    dictPalette.Add i, RGB(204, 255, 229): i = i + 1  ' Menthe glacée
    dictPalette.Add i, RGB(191, 239, 255): i = i + 1  ' Bleu glacé
    dictPalette.Add i, RGB(228, 187, 255): i = i + 1  ' Violet clair
    dictPalette.Add i, RGB(255, 194, 209): i = i + 1  ' Rose saumon
    dictPalette.Add i, RGB(215, 204, 200): i = i + 1  ' Beige rosé
    dictPalette.Add i, RGB(207, 216, 220): i = i + 1  ' Gris bleuté
    
    ' SÉRIE 3: COULEURS MOYENNES BIEN CONTRASTÉES (30 couleurs)
    dictPalette.Add i, RGB(244, 67, 54):   i = i + 1  ' Rouge Material
    dictPalette.Add i, RGB(233, 30, 99):   i = i + 1  ' Pink Material
    dictPalette.Add i, RGB(156, 39, 176):  i = i + 1  ' Purple Material
    dictPalette.Add i, RGB(103, 58, 183):  i = i + 1  ' Deep Purple
    dictPalette.Add i, RGB(63, 81, 181):   i = i + 1  ' Indigo Material
    dictPalette.Add i, RGB(33, 150, 243):  i = i + 1  ' Blue Material
    dictPalette.Add i, RGB(3, 169, 244):   i = i + 1  ' Light Blue
    dictPalette.Add i, RGB(0, 188, 212):   i = i + 1  ' Cyan Material
    dictPalette.Add i, RGB(0, 150, 136):   i = i + 1  ' Teal Material
    dictPalette.Add i, RGB(76, 175, 80):   i = i + 1  ' Green Material
    dictPalette.Add i, RGB(139, 195, 74):  i = i + 1  ' Light Green
    dictPalette.Add i, RGB(205, 220, 57):  i = i + 1  ' Lime Material
    dictPalette.Add i, RGB(255, 235, 59):  i = i + 1  ' Yellow Material
    dictPalette.Add i, RGB(255, 193, 7):   i = i + 1  ' Amber Material
    dictPalette.Add i, RGB(255, 152, 0):   i = i + 1  ' Orange Material
    dictPalette.Add i, RGB(255, 87, 34):   i = i + 1  ' Deep Orange
    dictPalette.Add i, RGB(121, 85, 72):   i = i + 1  ' Brown Material
    dictPalette.Add i, RGB(158, 158, 158): i = i + 1  ' Grey Material
    dictPalette.Add i, RGB(96, 125, 139):  i = i + 1  ' Blue Grey
    dictPalette.Add i, RGB(255, 112, 67):  i = i + 1  ' Orange vif
    dictPalette.Add i, RGB(174, 213, 129): i = i + 1  ' Vert clair vif
    dictPalette.Add i, RGB(100, 181, 246): i = i + 1  ' Bleu moyen
    dictPalette.Add i, RGB(149, 117, 205): i = i + 1  ' Violet moyen
    dictPalette.Add i, RGB(240, 113, 120): i = i + 1  ' Rose corail
    dictPalette.Add i, RGB(255, 183, 77):  i = i + 1  ' Orange doré
    dictPalette.Add i, RGB(129, 212, 250): i = i + 1  ' Bleu clair vif
    dictPalette.Add i, RGB(206, 147, 216): i = i + 1  ' Violet rosé
    dictPalette.Add i, RGB(255, 138, 128): i = i + 1  ' Rouge saumon
    dictPalette.Add i, RGB(185, 246, 202): i = i + 1  ' Vert menthe vif
    dictPalette.Add i, RGB(144, 202, 249): i = i + 1  ' Bleu pervenche
    
    ' SÉRIE 4: COULEURS FONCÉES CONTRASTÉES (30 couleurs)
    dictPalette.Add i, RGB(183, 28, 28):   i = i + 1  ' Rouge foncé
    dictPalette.Add i, RGB(136, 14, 79):   i = i + 1  ' Rose foncé
    dictPalette.Add i, RGB(74, 20, 140):   i = i + 1  ' Violet foncé
    dictPalette.Add i, RGB(49, 27, 146):   i = i + 1  ' Indigo foncé
    dictPalette.Add i, RGB(26, 35, 126):   i = i + 1  ' Bleu foncé
    dictPalette.Add i, RGB(13, 71, 161):   i = i + 1  ' Bleu profond
    dictPalette.Add i, RGB(1, 87, 155):    i = i + 1  ' Bleu clair foncé
    dictPalette.Add i, RGB(0, 96, 100):    i = i + 1  ' Cyan foncé
    dictPalette.Add i, RGB(0, 77, 64):     i = i + 1  ' Vert foncé
    dictPalette.Add i, RGB(27, 94, 32):    i = i + 1  ' Vert profond
    dictPalette.Add i, RGB(51, 105, 30):   i = i + 1  ' Vert olive
    dictPalette.Add i, RGB(130, 119, 23):  i = i + 1  ' Jaune olive
    dictPalette.Add i, RGB(245, 127, 23):  i = i + 1  ' Orange foncé
    dictPalette.Add i, RGB(191, 54, 12):   i = i + 1  ' Rouge orange
    dictPalette.Add i, RGB(62, 39, 35):    i = i + 1  ' Brun foncé
    dictPalette.Add i, RGB(69, 90, 100):   i = i + 1  ' Gris bleu foncé
    dictPalette.Add i, RGB(101, 31, 255):  i = i + 1  ' Violet électrique
    dictPalette.Add i, RGB(0, 230, 118):   i = i + 1  ' Vert néon
    dictPalette.Add i, RGB(255, 61, 0):    i = i + 1  ' Rouge orange vif
    dictPalette.Add i, RGB(196, 0, 140):   i = i + 1  ' Magenta foncé
    dictPalette.Add i, RGB(0, 145, 234):   i = i + 1  ' Bleu électrique
    dictPalette.Add i, RGB(67, 160, 71):   i = i + 1  ' Vert franc
    dictPalette.Add i, RGB(251, 140, 0):   i = i + 1  ' Orange amber
    dictPalette.Add i, RGB(124, 77, 255):  i = i + 1  ' Violet clair
    dictPalette.Add i, RGB(255, 23, 68):   i = i + 1  ' Rose vif
    dictPalette.Add i, RGB(0, 191, 255):   i = i + 1  ' Bleu ciel vif
    dictPalette.Add i, RGB(198, 255, 0):   i = i + 1  ' Vert lime vif
    dictPalette.Add i, RGB(255, 64, 129):  i = i + 1  ' Rose accent
    dictPalette.Add i, RGB(101, 187, 255): i = i + 1  ' Bleu accent
    dictPalette.Add i, RGB(178, 255, 89):  i = i + 1  ' Vert accent
    
    ' SÉRIE 5: COULEURS SPÉCIALES ET DISTINCTIVES (30 couleurs)
    dictPalette.Add i, RGB(132, 94, 194):  i = i + 1  ' Améthyste
    dictPalette.Add i, RGB(207, 106, 135): i = i + 1  ' Rose antique
    dictPalette.Add i, RGB(72, 133, 237):  i = i + 1  ' Bleu royal
    dictPalette.Add i, RGB(245, 166, 35):  i = i + 1  ' Miel
    dictPalette.Add i, RGB(126, 211, 33):  i = i + 1  ' Chartreuse
    dictPalette.Add i, RGB(202, 111, 30):  i = i + 1  ' Terre de Sienne
    dictPalette.Add i, RGB(21, 101, 192):  i = i + 1  ' Saphir
    dictPalette.Add i, RGB(162, 155, 254): i = i + 1  ' Pervenche
    dictPalette.Add i, RGB(255, 204, 0):   i = i + 1  ' Or
    dictPalette.Add i, RGB(0, 200, 83):    i = i + 1  ' Émeraude vif
    dictPalette.Add i, RGB(213, 0, 249):   i = i + 1  ' Magenta électrique
    dictPalette.Add i, RGB(0, 184, 169):   i = i + 1  ' Turquoise foncé
    dictPalette.Add i, RGB(255, 109, 0):   i = i + 1  ' Orange mandarine
    dictPalette.Add i, RGB(149, 69, 53):   i = i + 1  ' Acajou
    dictPalette.Add i, RGB(56, 142, 60):   i = i + 1  ' Vert sapin
    dictPalette.Add i, RGB(94, 53, 177):   i = i + 1  ' Violet byzantin
    dictPalette.Add i, RGB(239, 83, 80):   i = i + 1  ' Rouge tomate
    dictPalette.Add i, RGB(26, 188, 156):  i = i + 1  ' Turquoise clair
    dictPalette.Add i, RGB(255, 193, 7):   i = i + 1  ' Ambre
    dictPalette.Add i, RGB(142, 36, 170):  i = i + 1  ' Violet orchidée
    dictPalette.Add i, RGB(67, 56, 202):   i = i + 1  ' Indigo électrique
    dictPalette.Add i, RGB(46, 204, 113):  i = i + 1  ' Vert menthe électrique
    dictPalette.Add i, RGB(231, 76, 60):   i = i + 1  ' Rouge brique
    dictPalette.Add i, RGB(230, 126, 34):  i = i + 1  ' Carotte
    dictPalette.Add i, RGB(241, 196, 15):  i = i + 1  ' Tournesol
    dictPalette.Add i, RGB(155, 89, 182):  i = i + 1  ' Améthyste clair
    dictPalette.Add i, RGB(52, 152, 219):  i = i + 1  ' Bleu peter river
    dictPalette.Add i, RGB(22, 160, 133):  i = i + 1  ' Vert sea
    dictPalette.Add i, RGB(243, 156, 18):  i = i + 1  ' Orange soleil
    dictPalette.Add i, RGB(211, 84, 0):    i = i + 1  ' Orange foncé pumpkin
End Sub

' Obtient une couleur distincte pour une voie avec vérification d'adjacence (VERSION AMÉLIORÉE)
Function ObtenirCouleurDistinctePourVoieAvecAdjacence(nomVoie As String, paletteCouleurs As Object, dictCouleursExistantes As Object, colonne As Long, ws As Worksheet, ligne As Long) As Long
    Dim hashVoie As Long
    Dim i As Integer
    Dim indexCouleur As Integer
    Dim couleurCandidate As Long
    Dim couleurGauche As Long, couleurDroite As Long
    Dim tentatives As Integer
    Dim contraste As Double
    Dim contrastelimite As Double
    
    ' Seuil de contraste minimum (plus c'est élevé, plus les couleurs doivent être différentes)
    contrastelimite = 30000 ' Différence RGB minimum
    
    ' Calculer un hash basé sur le nom de la voie
    hashVoie = 0
    For i = 1 To Len(nomVoie)
        hashVoie = hashVoie + Asc(Mid(nomVoie, i, 1)) * i
    Next i
    
    ' Obtenir les couleurs des voies adjacentes
    couleurGauche = ObtenirCouleurVoieAdjacente(ws, ligne, colonne - 1)
    couleurDroite = ObtenirCouleurVoieAdjacente(ws, ligne, colonne + 1)
    
    ' Essayer de trouver une couleur avec suffisamment de contraste
    tentatives = 0
    Do
        ' Calculer l'index de couleur avec variation selon les tentatives
        indexCouleur = ((hashVoie + tentatives * 17) Mod paletteCouleurs.Count)
        If indexCouleur < 0 Then indexCouleur = indexCouleur + paletteCouleurs.Count
        
        couleurCandidate = paletteCouleurs(indexCouleur)
        
        ' Vérifier le contraste avec les couleurs adjacentes
        Dim contrasteBon As Boolean
        contrasteBon = True
        
        If couleurGauche <> xlNone And couleurGauche <> 0 Then
            contraste = CalculerContrasteRGB(couleurCandidate, couleurGauche)
            If contraste < contrastelimite Then contrasteBon = False
        End If
        
        If couleurDroite <> xlNone And couleurDroite <> 0 And contrasteBon Then
            contraste = CalculerContrasteRGB(couleurCandidate, couleurDroite)
            If contraste < contrastelimite Then contrasteBon = False
        End If
        
        ' Si la couleur a suffisamment de contraste, l'utiliser
        If contrasteBon Then
            ObtenirCouleurDistinctePourVoieAvecAdjacence = couleurCandidate
            Exit Function
        End If
        
        tentatives = tentatives + 1
        
        ' Limiter les tentatives pour éviter une boucle infinie
        If tentatives > 50 Then
            ' Utiliser une couleur de la série spéciale haute différenciation
            indexCouleur = (tentatives Mod 30) + 100 ' Utiliser la série 5 (couleurs spéciales)
            If indexCouleur >= paletteCouleurs.Count Then indexCouleur = paletteCouleurs.Count - 1
            ObtenirCouleurDistinctePourVoieAvecAdjacence = paletteCouleurs(indexCouleur)
            Exit Function
        End If
    Loop
End Function

' Fonction utilitaire pour obtenir la couleur d'une voie adjacente
Function ObtenirCouleurVoieAdjacente(ws As Worksheet, ligne As Long, colonne As Long) As Long
    On Error GoTo ErrorHandler
    
    ' Vérifier que la colonne est dans les limites
    If colonne < 1 Or colonne > ws.Columns.Count Then
        ObtenirCouleurVoieAdjacente = xlNone
        Exit Function
    End If
    
    ' Vérifier la cellule de voie (ligne + 1 pour la ligne des voies)
    Dim celluleVoie As Range
    Set celluleVoie = ws.Cells(ligne + 1, colonne)
    
    ' Si la cellule contient une voie (pas vide, pas numérique)
    If Not IsEmpty(celluleVoie.Value) And Not IsNumeric(celluleVoie.Value) Then
        ObtenirCouleurVoieAdjacente = celluleVoie.Interior.Color
    Else
        ObtenirCouleurVoieAdjacente = xlNone
    End If
    
    Exit Function
    
ErrorHandler:
    ObtenirCouleurVoieAdjacente = xlNone
End Function

' Calcule le contraste entre deux couleurs RGB
Function CalculerContrasteRGB(couleur1 As Long, couleur2 As Long) As Double
    Dim r1 As Integer, g1 As Integer, b1 As Integer
    Dim r2 As Integer, g2 As Integer, b2 As Integer
    
    ' Extraire les composantes RGB de la première couleur
    r1 = couleur1 Mod 256
    g1 = (couleur1 \ 256) Mod 256
    b1 = (couleur1 \ 65536) Mod 256
    
    ' Extraire les composantes RGB de la seconde couleur
    r2 = couleur2 Mod 256
    g2 = (couleur2 \ 256) Mod 256
    b2 = (couleur2 \ 65536) Mod 256
    
    ' Calculer la distance euclidienne dans l'espace RGB
    CalculerContrasteRGB = Sqr((r1 - r2) ^ 2 + (g1 - g2) ^ 2 + (b1 - b2) ^ 2)
End Function

' Version RGB de la fonction ObtenirCouleurTexte
Function ObtenirCouleurTexteRGB(couleurFondRGB As Long) As Long
    Dim r As Integer, g As Integer, b As Integer
    Dim luminosite As Double
    
    ' Extraire les composantes RGB
    r = couleurFondRGB Mod 256
    g = (couleurFondRGB \ 256) Mod 256
    b = (couleurFondRGB \ 65536) Mod 256
    
    ' Calculer la luminosité (formule standard)
    luminosite = (0.299 * r + 0.587 * g + 0.114 * b) / 255
    
    ' Si la couleur est sombre, texte blanc, sinon texte noir
    If luminosite < 0.5 Then
        ObtenirCouleurTexteRGB = RGB(255, 255, 255) ' Blanc
    Else
        ObtenirCouleurTexteRGB = RGB(0, 0, 0) ' Noir
    End If
End Function

' =====================================================
' FONCTIONS DE DIAGNOSTIC ET TEST
' =====================================================

' Fonction de diagnostic pour afficher les couleurs attribuées
Sub AfficherDiagnosticCouleurs()
    Dim ws As Worksheet
    Dim i As Long
    Dim rapport As String
    Dim cellule As Range
    Dim nomVoie As String
    Dim couleur As Long
    Dim voiesTraitees As Object
    
    Set ws = ActiveSheet
    Set voiesTraitees = CreateObject("Scripting.Dictionary")
    
    If ws Is Nothing Then
        MsgBox "Aucune feuille active détectée.", vbExclamation
        Exit Sub
    End If
    
    rapport = "DIAGNOSTIC DES COULEURS ATTRIBUÉES" & vbCrLf & vbCrLf
    
    ' Parcourir les cellules de voies (lignes paires)
    For Each cellule In ws.usedRange
        If cellule.Row Mod 2 = 0 And Not IsEmpty(cellule.Value) Then ' Lignes paires (voies)
            nomVoie = Trim(CStr(cellule.Value))
            
            If nomVoie <> "" And Not IsNumeric(nomVoie) And Not voiesTraitees.Exists(nomVoie) Then
                couleur = cellule.Interior.Color
                
                If couleur <> xlNone And couleur <> RGB(255, 255, 255) Then
                    rapport = rapport & "Voie: " & nomVoie & vbCrLf
                    rapport = rapport & "  Couleur RGB: " & couleur & vbCrLf
                    rapport = rapport & "  Cellule: " & cellule.Address & vbCrLf & vbCrLf
                    
                    voiesTraitees.Add nomVoie, True
                End If
            End If
        End If
    Next cellule
    
    rapport = rapport & "Total de voies colorées: " & voiesTraitees.Count
    
    MsgBox rapport, vbInformation, "Diagnostic Couleurs"
End Sub

' =====================================================
' MACROS UTILITAIRES COMPLÉMENTAIRES
' =====================================================

' MACRO UTILITAIRE : Ajuster paramètres d'impression
Sub AjusterParametresImpression()
    ' Fonction utilitaire pour optimiser l'impression de la façade
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Configuration de l'impression
    With ws.PageSetup
        .Orientation = xlLandscape
        .FitToPagesWide = 1
        .FitToPagesTall = False
        .CenterHorizontally = True
        .CenterVertically = False
        .PrintArea = "A1:AA" & ws.usedRange.Rows.Count
        .LeftMargin = Application.InchesToPoints(0.25)
        .RightMargin = Application.InchesToPoints(0.25)
        .TopMargin = Application.InchesToPoints(0.25)
        .BottomMargin = Application.InchesToPoints(0.25)
        .HeaderMargin = Application.InchesToPoints(0.1)
        .FooterMargin = Application.InchesToPoints(0.1)
    End With
End Sub

' FONCTION UTILITAIRE : Obtenir le nom de l'onglet actif
Sub NomOngletActif()
    ' Fonction utilitaire utilisée par les autres macros
    Dim nomOnglet As String
    nomOnglet = ActiveSheet.Name
End Sub

' POINT D'ENTRÉE POUR L'IMPORT BDC
Sub LancerImportBDC()
    MsgBox "La fonctionnalité d'import BDC n'est pas définie dans le code fourni.", vbInformation
End Sub

' =====================================================
' MACROS DE TEST ET VÉRIFICATION
' =====================================================

' MACRO DE TEST : Vérifier la logique de dépassement
Sub TesterLogiquleDepassement()
    Dim ws As Worksheet
    Dim maxPar As Integer
    Dim msg As String
    
    Set ws = ActiveSheet
    maxPar = Val(ws.Range("C1").Value)
    If maxPar <= 0 Then maxPar = 4
    
    msg = "TEST DE LA LOGIQUE DE DÉPASSEMENT" & vbCrLf & vbCrLf
    msg = msg & "Valeur max par caisson (C1 de '" & ws.Name & "') : " & maxPar & vbCrLf & vbCrLf
    msg = msg & "EXEMPLES DE TESTS :" & vbCrLf
    
    ' Tester quelques codes
    msg = msg & "1A : " & IIf(CaissonDepasse("1A", maxPar), "DÉPASSE", "OK") & vbCrLf
    msg = msg & maxPar & "D : " & IIf(CaissonDepasse(maxPar & "D", maxPar), "DÉPASSE", "OK") & vbCrLf
    msg = msg & (maxPar + 1) & "D : " & IIf(CaissonDepasse((maxPar + 1) & "D", maxPar), "DÉPASSE", "OK") & vbCrLf
    msg = msg & "1E : " & IIf(CaissonDepasse("1E", maxPar), "DÉPASSE", "OK") & vbCrLf & vbCrLf
    
    msg = msg & "LIMITE : Tout au-delà de " & maxPar & "D devrait être en ROUGE avec HC" & vbCrLf
    msg = msg & "IMPORTANT : Une fois dépassé, même si ça repart à 1A, ça reste ROUGE !"
    
    MsgBox msg, vbInformation, "Test logique dépassement"
End Sub

' MACRO DE TEST : Vérifier la structure des données
Sub VerifierStructureDonnees()
    Dim ws As Worksheet
    Dim msg As String
    
    Set ws = ActiveSheet
    
    msg = "VÉRIFICATION DE LA STRUCTURE DES DONNÉES SUR '" & ws.Name & "'" & vbCrLf & vbCrLf
    msg = msg & "Valeur max par caisson (C1) : " & ws.Range("C1").Value & vbCrLf & vbCrLf
    msg = msg & "Exemple de la ligne 7 :" & vbCrLf
    msg = msg & "- Colonne A (N°) : " & ws.Cells(7, 1).Text & vbCrLf
    msg = msg & "- Colonne B (Nom voie) : " & ws.Cells(7, 2).Text & vbCrLf
    msg = msg & "- Colonne D (Observations) : " & ws.Cells(7, 4).Text & vbCrLf
    msg = msg & "- Colonne F (Type PDI) : " & ws.Cells(7, 6).Text & vbCrLf
    msg = msg & "- Colonne G (Largeur) : " & ws.Cells(7, 7).Text & vbCrLf
    msg = msg & "- Colonne V (Valeur B) : " & ws.Cells(7, 22).Text & vbCrLf & vbCrLf
    
    msg = msg & "RÉSULTAT ATTENDU :" & vbCrLf
    msg = msg & "Cellule du HAUT : " & ws.Cells(7, 1).Text & " - " & ws.Cells(7, 4).Text & vbCrLf
    msg = msg & "Cellule du BAS : " & ws.Cells(7, 2).Text
    
    MsgBox msg, vbInformation, "Structure des données"
End Sub

' =====================================================
' FONCTION UTILITAIRE : Vérifier si tous les PDI d'un bloc sont batterie/rattachés
' =====================================================
Function TousLesPDISontBatterieOuRattaches(wsSource As Worksheet, ligneDebutBloc As Long, ligneFin As Long) As Boolean
    Dim i As Long
    Dim typePDI As String
    
    ' Parcourir toutes les lignes du bloc (ligne principale + lignes accumulées)
    For i = ligneDebutBloc To ligneFin
        typePDI = UCase(Trim(CStr(wsSource.Cells(i, 6).Text))) ' Colonne F = 6
        
        ' Vérifier si le type PDI est autorisé
        If Not EstPDIBatterieOuRattache(typePDI) Then
            TousLesPDISontBatterieOuRattaches = False
            Exit Function
        End If
    Next i
    
    ' Si on arrive ici, tous les PDI du bloc sont autorisés
    TousLesPDISontBatterieOuRattaches = True
End Function

' =====================================================
' FONCTION UTILITAIRE : Vérifier si un PDI est batterie ou rattaché
' =====================================================
Function EstPDIBatterieOuRattache(typePDI As String) As Boolean
    Dim typeClean As String
    
    ' Nettoyer le type (enlever espaces en trop, mettre en majuscules)
    typeClean = UCase(Trim(typePDI))
    
    ' Nettoyer les espaces multiples
    Do While InStr(typeClean, "  ") > 0
        typeClean = Replace(typeClean, "  ", " ")
    Loop
    
    ' Vérifier si c'est un type autorisé
    Select Case typeClean
        Case "BAT C", "BAT P", "RATTACHÉ C", "RATTACHE C", "RATTACHÉ P", "RATTACHE P"
            EstPDIBatterieOuRattache = True
        Case Else
            EstPDIBatterieOuRattache = False
    End Select
End Function

' =====================================================
' MODIFICATION DE LA MACRO PRINCIPALE - PARTIE CONCERNÉE
' À remplacer dans la macro GenererFacadePDI() dans le document main
' =====================================================

' Dans la macro GenererFacadePDI(), remplacer cette section :
' (Rechercher la partie qui commence par "' Construire le texte avec symbole si nécessaire")

            

