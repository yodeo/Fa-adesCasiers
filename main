Sub GenererFacadePDI()
    '=====================================================
    ' MACRO : Génération automatique d'une façade de casiers PDI
    ' Source : Onglet "Accueil" (données à partir de la ligne 7)
    ' Destination : Nouvelle feuille "Facade_PDI"
    '=====================================================
    
    Dim wsSource As Worksheet, wsDest As Worksheet
    Dim derniereLigne As Long, i As Long
    Dim numPDI As String, observations As String, nomVoie As String
    Dim largeurPDI As Integer
    Dim ligneActuelle As Long, colonneActuelle As Long
    Dim rngHaut As Range, rngBas As Range, rngCaisson As Range
    Dim valeurLargeur As Variant
    Dim dictCouleurs As Object
    Dim couleurActuelle As Long
    Dim indexCouleur As Integer
    
    ' Variables pour la gestion des caissons
    Dim maxParCaisson As Integer
    Dim compteurDansCaisson As Integer
    Dim numeroCaisson As Integer
    Dim lettreCaisson As String
    Dim codeCaisson As String
    Dim horsCapacitePermanent As Boolean ' Variable pour tracker le dépassement permanent
    
    ' Variables pour l'accumulation
    Dim blocEnCours As Boolean
    Dim numAccumule As String
    Dim obsAccumulees As String
    Dim voieAccumulee As String
    Dim largeurBloc As Integer
    
    ' Variables pour la mise à jour des codes caisson en temps réel
    Dim dictMiseAJourCodes As Object
    Dim dictLignesHorsCapacite As Object ' Pour stocker les lignes qui dépassent
    Dim ligneSourceActuelle As Long
    
    ' Désactiver les mises à jour écran pour améliorer les performances
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    ' NETTOYER LE MENU CONTEXTUEL AVANT DE COMMENCER
    Call SupprimerOptionMenuContextuel
    
    ' Créer un dictionnaire pour gérer les couleurs par nom de voie
    Set dictCouleurs = CreateObject("Scripting.Dictionary")
    indexCouleur = 3
    
    ' Créer un dictionnaire pour stocker les codes caisson à mettre à jour
    Set dictMiseAJourCodes = CreateObject("Scripting.Dictionary")
    
    ' Créer un dictionnaire pour stocker les lignes hors capacité
    Set dictLignesHorsCapacite = CreateObject("Scripting.Dictionary")
    
    ' Définir la feuille source
    Set wsSource = ThisWorkbook.Sheets("Accueil")
    
    ' Récupérer la valeur max par caisson depuis C1
    maxParCaisson = val(wsSource.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4 ' Valeur par défaut si C1 est vide ou invalide
    
    ' Initialiser les compteurs de caisson
    compteurDansCaisson = 1  ' Commence à 1, pas 0
    numeroCaisson = 1
    lettreCaisson = "A"
    horsCapacitePermanent = False ' Pas encore en dépassement
    
    ' Supprimer la feuille destination si elle existe déjà
    On Error Resume Next
    ThisWorkbook.Sheets("Facade_PDI").Delete
    On Error GoTo 0
    
    ' Créer la nouvelle feuille destination
    Set wsDest = ThisWorkbook.Sheets.Add(After:=wsSource)
    wsDest.Name = "Facade_PDI"
    
    ' Configurer les largeurs de colonnes
    wsDest.Columns("A:B").ColumnWidth = 5.57
    wsDest.Columns("Y:Z").ColumnWidth = 5.57
    wsDest.Columns("AA").ColumnWidth = 3.29
    wsDest.Columns("C:X").ColumnWidth = 4.29
    
    ' Trouver la dernière ligne avec des données
    derniereLigne = wsSource.Cells(wsSource.Rows.Count, "A").End(xlUp).Row
    
    ' Initialiser les positions de départ
    ligneActuelle = 1
    colonneActuelle = 1
    blocEnCours = False
    
    ' PARCOURIR LES DONNÉES À PARTIR DE LA LIGNE 7
    i = 7
    Do While i <= derniereLigne
        ' Lire les données de la ligne actuelle
        numPDI = CStr(wsSource.Cells(i, 1).Text)
        nomVoie = CStr(wsSource.Cells(i, 2).Text)
        observations = CStr(wsSource.Cells(i, 4).Text)
        valeurLargeur = wsSource.Cells(i, 7).Value
        largeurPDI = ConvertirEnEntier(valeurLargeur, 0)
        
        ' Lire la valeur de la colonne V pour le fond jaune
        Dim valeurColV As String
        valeurColV = CStr(wsSource.Cells(i, 22).Text) ' Colonne V = 22
        
        ' Lire le type PDI (colonne F)
        Dim typePDI As String
        typePDI = CStr(wsSource.Cells(i, 6).Text) ' Colonne F = 6
        
        ' Si on a une largeur > 0, c'est le début d'un nouveau bloc
        If largeurPDI > 0 Then
            ' Stocker la ligne source de début pour ce bloc
            ligneSourceActuelle = i
            
            ' Initialiser l'accumulation pour ce bloc
            numAccumule = numPDI
            obsAccumulees = observations
            voieAccumulee = nomVoie
            largeurBloc = largeurPDI
            
            ' Variable pour savoir si c'est un bloc multi-voies
            Dim estMultiVoies As Boolean
            estMultiVoies = False
            
            ' Regarder les lignes suivantes pour accumulation
            Dim j As Long
            j = i + 1
            Do While j <= derniereLigne
                Dim largeurSuivante As Integer
                largeurSuivante = ConvertirEnEntier(wsSource.Cells(j, 7).Value, 0)
                
                ' Si largeur = 0, accumuler
                If largeurSuivante = 0 Then
                    Dim numSuivant As String, voieSuivante As String, obsSuivante As String
                    numSuivant = CStr(wsSource.Cells(j, 1).Text)
                    voieSuivante = CStr(wsSource.Cells(j, 2).Text)
                    obsSuivante = CStr(wsSource.Cells(j, 4).Text)
                    
                    ' Déterminer le séparateur pour les numéros
                    If voieSuivante <> voieAccumulee And voieSuivante <> "" Then
                        ' Voie différente : slash
                        numAccumule = numAccumule & " / " & numSuivant
                        estMultiVoies = True
                        ' Ajouter la voie si différente
                        If InStr(voieAccumulee, voieSuivante) = 0 Then
                            voieAccumulee = voieAccumulee & " / " & voieSuivante
                        End If
                    Else
                        ' Même voie : tiret
                        numAccumule = numAccumule & "-" & numSuivant
                    End If
                    
                    ' Accumuler les observations
                    If obsSuivante <> "" Then
                        If obsAccumulees = "" Then
                            obsAccumulees = obsSuivante
                        Else
                            obsAccumulees = obsAccumulees & " / " & obsSuivante
                        End If
                    End If
                    
                    ' Vérifier aussi la colonne V pour les lignes accumulées
                    If wsSource.Cells(j, 22).Text = "B" Then
                        valeurColV = "B"
                    End If
                    
                    ' Vérifier aussi le type PDI pour les lignes accumulées
                    If wsSource.Cells(j, 6).Text = "Bat P" Or wsSource.Cells(j, 6).Text = "Bat C" Then
                        typePDI = wsSource.Cells(j, 6).Text
                    End If
                    
                    j = j + 1
                Else
                    ' On a trouvé une largeur > 0, on arrête l'accumulation
                    Exit Do
                End If
            Loop
            
            ' Mettre à jour i pour sauter les lignes accumulées
            i = j - 1
            
            ' CRÉER LE BLOC PDI
            ' Vérifier la validité de la largeur
            If largeurBloc < 1 Then largeurBloc = 1
            If largeurBloc > 26 Then largeurBloc = 26
            
            ' Vérifier si on dépasse la colonne Z (26)
            If colonneActuelle + largeurBloc - 1 > 26 Then
                ' Ajouter le code caisson avant de passer à la ligne
                If colonneActuelle > 1 Then
                    ' Vérifier si le caisson actuel dépasse la capacité
                    Dim codeActuel As String
                    codeActuel = numeroCaisson & lettreCaisson
                    If horsCapacitePermanent Or CaissonDepasse(codeActuel, maxParCaisson) Then
                        Call AjouterCodeCaisson(wsDest, ligneActuelle, "HC")
                    Else
                        Call AjouterCodeCaisson(wsDest, ligneActuelle, codeActuel)
                    End If
                End If
                
                ligneActuelle = ligneActuelle + 2
                colonneActuelle = 1
                
                ' Incrémenter le compteur de caisson selon la nouvelle logique
                numeroCaisson = numeroCaisson + 1
                
                ' Si on dépasse maxParCaisson, on passe à la lettre suivante
                If numeroCaisson > maxParCaisson Then
                    numeroCaisson = 1
                    ' Passer à la lettre suivante
                    If lettreCaisson = "D" Then
                        ' Si on dépasse D, on est maintenant hors capacité de façon permanente
                        horsCapacitePermanent = True
                        ' On recommence à A mais on reste hors capacité
                        lettreCaisson = "A"
                    Else
                        lettreCaisson = Chr(Asc(lettreCaisson) + 1)
                        ' Vérifier si on vient d'atteindre le dépassement
                        If lettreCaisson > "D" And Not horsCapacitePermanent Then
                            horsCapacitePermanent = True
                            lettreCaisson = "A" ' Redémarre mais reste hors capacité
                            numeroCaisson = 1
                        End If
                    End If
                End If
            End If
            
            ' Calculer le code caisson complet pour ce PDI
            Dim codeCompletCaisson As String
            Dim numeroPosition As String
            Dim codeBaseCaisson As String
            
            ' Code de base du caisson (ex: "1A", "2B", etc.)
            codeBaseCaisson = numeroCaisson & lettreCaisson
            
            ' Vérifier si on dépasse la limite pour le fond rouge
            Dim fondRouge As Boolean
            fondRouge = horsCapacitePermanent Or CaissonDepasse(codeBaseCaisson, maxParCaisson)
            
            ' Calculer le numéro de position (format 01, 02, etc.)
            numeroPosition = Format(colonneActuelle, "00")
            codeCompletCaisson = codeBaseCaisson & " " & numeroPosition
            
            ' Stocker le code pour toutes les lignes de ce bloc (ligne principale + lignes accumulées)
            For k = ligneSourceActuelle To j - 1
                dictMiseAJourCodes.Add k, codeCompletCaisson
                ' Si c'est hors capacité, l'ajouter au dictionnaire des lignes à colorer
                If fondRouge Then
                    dictLignesHorsCapacite.Add k, True
                End If
            Next k
            
            ' Créer la cellule du haut (N° + Observations) - AVEC FORMATAGE DIFFÉRENCIÉ
            Set rngHaut = wsDest.Range(wsDest.Cells(ligneActuelle, colonneActuelle), _
                                       wsDest.Cells(ligneActuelle, colonneActuelle + largeurBloc - 1))
            rngHaut.Merge
            
            With rngHaut
                .NumberFormat = "@"
                
                ' Construire le texte avec symbole si nécessaire (SANS cercle blanc)
                Dim texteComplet As String
                Dim symbole As String
                symbole = ""
                
                
               ' Ajouter un symbole pour Bat P ou Bat C SEULEMENT
                If typePDI = "Bat P" Then
                    symbole = ChrW(&H25B2) & " " ' Triangle Unicode
                ElseIf typePDI = "Bat C" Then
                    symbole = ChrW(&H25B2) & " " ' Triangle Unicode
                End If

                
                ' Construction du texte avec formatage différencié et saut de ligne
                If obsAccumulees <> "" Then
                    ' Format : [Symbole] Numéro + SAUT DE LIGNE + Observations
                    texteComplet = symbole & numAccumule & vbCrLf & obsAccumulees
                Else
                    ' Format : [Symbole] Numéro seul
                    texteComplet = symbole & numAccumule
                End If
                
                .Value = texteComplet
                .HorizontalAlignment = xlCenter
                .VerticalAlignment = xlCenter
                .WrapText = True
                
                ' Bordures : toujours fines
                .Borders.LineStyle = xlContinuous
                .Borders.Weight = xlThin
                
                ' Priorité : rouge si dépasse > jaune si colonne V = "B" > pas de couleur
                If fondRouge Then
                    .Interior.Color = RGB(255, 0, 0) ' Rouge (priorité 1)
                    .Font.Color = RGB(255, 255, 255) ' Texte blanc sur fond rouge
                ElseIf valeurColV = "B" Then
                    .Interior.Color = RGB(255, 255, 0) ' Jaune (priorité 2)
                    .Font.Color = RGB(0, 0, 0) ' Texte noir sur fond jaune
                Else
                    .Interior.pattern = xlNone ' Pas de couleur
                End If
            End With
            
            ' APPLIQUER LE FORMATAGE DIFFÉRENCIÉ POUR NUMÉROS VS OBSERVATIONS
            Call AppliquerFormatageDifferencie(rngHaut, symbole, numAccumule, obsAccumulees)
            
            ' Créer la cellule du bas (Nom de la voie) - AVEC LE CERCLE BLANC SI MULTI-VOIES
            Set rngBas = wsDest.Range(wsDest.Cells(ligneActuelle + 1, colonneActuelle), _
                                      wsDest.Cells(ligneActuelle + 1, colonneActuelle + largeurBloc - 1))
            rngBas.Merge
            
            ' Appliquer les abréviations au nom de voie
            Dim voieAbregee As String
            voieAbregee = AbregerTypeVoie(voieAccumulee)
            
            ' Construire le texte de la voie avec cercle blanc si multi-voies
            Dim texteVoie As String
            If estMultiVoies Then
                texteVoie = ChrW(&H25CB) & " " & voieAbregee ' Cercle blanc + nom de voie
            Else
                texteVoie = voieAbregee ' Nom de voie seul
            End If
            
            With rngBas
                .NumberFormat = "@"
                .Value = texteVoie ' Utiliser le texte avec ou sans cercle
            End With
            
            ' Gérer la couleur pour les voies
            If voieAccumulee <> "" Then
                ' Pour les voies multiples, utiliser la couleur de la première voie
                Dim premiereVoie As String
                Dim posSlash As Integer
                posSlash = InStr(voieAccumulee, " / ")
                If posSlash > 0 Then
                    premiereVoie = Left(voieAccumulee, posSlash - 1)
                Else
                    premiereVoie = voieAccumulee
                End If
                
                If Not dictCouleurs.Exists(premiereVoie) Then
                    dictCouleurs.Add premiereVoie, indexCouleur
                    indexCouleur = indexCouleur + 1
                    If indexCouleur > 56 Then indexCouleur = 3
                    If indexCouleur = 2 Or indexCouleur = 15 Then indexCouleur = indexCouleur + 1
                End If
                couleurActuelle = dictCouleurs(premiereVoie)
            Else
                couleurActuelle = xlNone
            End If
            
            With rngBas
                .HorizontalAlignment = xlCenter
                .VerticalAlignment = xlCenter
                .Font.Bold = True
                .WrapText = True
                
                ' Souligner le texte si multi-voies
                If estMultiVoies Then
                    .Font.Underline = xlUnderlineStyleSingle
                End If
                
                ' Bordures : toujours fines
                .Borders.LineStyle = xlContinuous
                .Borders.Weight = xlThin
                
                If couleurActuelle <> xlNone Then
                    ' Priorité : rouge si dépasse > couleur normale
                    If fondRouge Then
                        .Interior.Color = RGB(255, 0, 0) ' Rouge (priorité 1)
                        .Font.Color = RGB(255, 255, 255) ' Texte blanc sur fond rouge
                    Else
                        .Interior.ColorIndex = couleurActuelle
                        .Font.Color = ObtenirCouleurTexte(couleurActuelle)
                    End If
                Else
                    ' Même si pas de couleur de voie, appliquer le rouge si dépasse
                    If fondRouge Then
                        .Interior.Color = RGB(255, 0, 0) ' Rouge
                        .Font.Color = RGB(255, 255, 255) ' Texte blanc
                    End If
                End If
            End With
            
            ' Ajuster les hauteurs de lignes - CONSERVÉES COMME AVANT
            wsDest.Rows(ligneActuelle).RowHeight = 48.75
            wsDest.Rows(ligneActuelle + 1).RowHeight = 39
            
            ' AJUSTER LA TAILLE DE POLICE SELON LA LARGEUR DE LA CELLULE
            Call AjusterTaillePoliceSelonLargeur(rngHaut, largeurBloc)        ' Échelle numéros PDI
            Call AjusterTaillePoliceVoiesSelonLargeur(rngBas, largeurBloc)    ' Échelle noms de voies
            
            ' Avancer à la position suivante
            colonneActuelle = colonneActuelle + largeurBloc
        End If
        
        i = i + 1
    Loop
    
    ' Ajouter le code caisson pour la dernière ligne si nécessaire
    If colonneActuelle > 1 Then
        Dim codeFinal As String
        codeFinal = numeroCaisson & lettreCaisson
        If horsCapacitePermanent Or CaissonDepasse(codeFinal, maxParCaisson) Then
            Call AjouterCodeCaisson(wsDest, ligneActuelle, "HC")
        Else
            Call AjouterCodeCaisson(wsDest, ligneActuelle, codeFinal)
        End If
    End If
    
    ' METTRE À JOUR LA COLONNE H AVEC LES CODES CALCULÉS ET COLORER LES LIGNES HORS CAPACITÉ
    Call MettreAJourColonneHAvecCouleur(wsSource, dictMiseAJourCodes, dictLignesHorsCapacite)
    
    ' Fusionner les cellules adjacentes avec le même nom de voie
    Call FusionnerVoiesAdjacentes(wsDest)
    
    ' Mettre à jour les cellules vides dans la feuille Accueil
    ' Utiliser la colonne W pour stocker le nombre de cellules vides
    Call MettreAJourCellulesVides(wsSource, wsDest, "W")
    
    ' AJOUTER LES BOUTONS ET MENU CONTEXTUEL À LA FEUILLE FACADE_PDI
    Call AjouterBoutonsSeulement(wsDest)
    Call AjouterCodeMenuContextuel(wsDest)
    
    ' AJOUTER LE MENU CONTEXTUEL À LA FEUILLE ACCUEIL (navigation inverse)
    Call AjouterCodeMenuContextuelAccueil(wsSource)
    
    ' Masquer le quadrillage
    With wsDest
        ActiveWindow.DisplayGridlines = False
    End With
    
    ' Configuration finale de la feuille
    With wsDest.PageSetup
        .Orientation = xlLandscape
        .FitToPagesWide = 1
        .FitToPagesTall = False
        .CenterHorizontally = True
    End With
    
    ' Réactiver les mises à jour
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
    
    ' Message de confirmation
    MsgBox "La façade PDI a été générée avec succès !" & vbCrLf & _
           "Nombre de lignes traitées : " & (derniereLigne - 6), _
           vbInformation, "Génération terminée"
    
    wsDest.Activate
    
End Sub

' =====================================================
' SUB : Gérer les changements en temps réel de la colonne G - CALCUL PAR CAISSON
' =====================================================
Sub GererChangementColonneG(Target As Range)
    Dim wsAccueil As Worksheet
    
    ' Vérifier si le changement concerne la colonne G (largeur) et ligne >= 7
    If Target.Column <> 7 Or Target.Row < 7 Then Exit Sub
    
    Set wsAccueil = ThisWorkbook.Sheets("Accueil")
    
    ' Désactiver les événements pour éviter les boucles
    Application.EnableEvents = False
    
    ' Recalculer les cellules vides pour tous les caissons
    Call RecalculerCellulesVidesParCaisson(wsAccueil)
    
    ' Réactiver les événements
    Application.EnableEvents = True
    
End Sub

' =====================================================
' SUB : Recalculer les cellules vides par caisson
' =====================================================
Sub RecalculerCellulesVidesParCaisson(ws As Worksheet)
    Dim maxParCaisson As Integer
    Dim derniereLigne As Long
    Dim i As Long
    Dim largeurActuelle As Integer
    Dim colonneVirtuelle As Integer
    Dim ligneVirtuelle As Integer
    Dim numeroCaisson As Integer
    Dim lettreCaisson As String
    Dim horsCapacitePermanent As Boolean
    Dim dictCaissonsLignes As Object ' Pour stocker la dernière ligne de chaque caisson
    Dim dictCaissonsVides As Object ' Pour stocker le nombre de cellules vides par caisson
    Dim codeCaisson As String
    Dim ligneDebutCaisson As Long
    
    ' Récupérer la valeur max par caisson
    maxParCaisson = val(ws.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4
    
    ' Créer les dictionnaires
    Set dictCaissonsLignes = CreateObject("Scripting.Dictionary")
    Set dictCaissonsVides = CreateObject("Scripting.Dictionary")
    
    ' Initialiser les compteurs
    colonneVirtuelle = 1
    numeroCaisson = 1
    lettreCaisson = "A"
    horsCapacitePermanent = False
    derniereLigne = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    ligneDebutCaisson = 7
    
    ' Effacer d'abord toute la colonne W
    ws.Range("W7:W" & derniereLigne).ClearContents
    
    ' Parcourir toutes les lignes pour simuler la disposition
    For i = 7 To derniereLigne
        largeurActuelle = ConvertirEnEntier(ws.Cells(i, 7).Value, 0)
        
        ' Si on a une largeur > 0, c'est un bloc PDI
        If largeurActuelle > 0 Then
            ' Vérifier si on dépasse la colonne Z (26)
            If colonneVirtuelle + largeurActuelle - 1 > 26 Then
                ' Finaliser le caisson précédent
                codeCaisson = numeroCaisson & lettreCaisson
                If Not horsCapacitePermanent And Not CaissonDepasse(codeCaisson, maxParCaisson) Then
                    ' Calculer les cellules vides du caisson précédent
                    Dim cellulesVides As Integer
                    cellulesVides = 26 - colonneVirtuelle + 1
                    
                    ' Stocker dans le dictionnaire avec la dernière ligne du caisson
                    If ligneDebutCaisson > 0 Then
                        dictCaissonsVides.Add codeCaisson, cellulesVides
                        dictCaissonsLignes.Add codeCaisson, i - 1 ' Ligne précédente = dernière du caisson
                    End If
                End If
                
                ' Passer au caisson suivant
                colonneVirtuelle = 1
                numeroCaisson = numeroCaisson + 1
                ligneDebutCaisson = i
                
                ' Gérer le passage à la lettre suivante
                If numeroCaisson > maxParCaisson Then
                    numeroCaisson = 1
                    If lettreCaisson = "D" Then
                        horsCapacitePermanent = True
                        lettreCaisson = "A"
                    Else
                        lettreCaisson = Chr(Asc(lettreCaisson) + 1)
                        If lettreCaisson > "D" And Not horsCapacitePermanent Then
                            horsCapacitePermanent = True
                            lettreCaisson = "A"
                            numeroCaisson = 1
                        End If
                    End If
                End If
            End If
            
            ' Avancer la position virtuelle
            colonneVirtuelle = colonneVirtuelle + largeurActuelle
        End If
    Next i
    
    ' Finaliser le dernier caisson
    codeCaisson = numeroCaisson & lettreCaisson
    If Not horsCapacitePermanent And Not CaissonDepasse(codeCaisson, maxParCaisson) Then
        If colonneVirtuelle <= 26 Then
            cellulesVides = 26 - colonneVirtuelle + 1
            dictCaissonsVides.Add codeCaisson, cellulesVides
            dictCaissonsLignes.Add codeCaisson, derniereLigne
        End If
    End If
    
    ' Maintenant, écrire les valeurs dans la colonne W seulement sur les dernières lignes de chaque caisson
    Dim cle As Variant
    For Each cle In dictCaissonsLignes.Keys
        Dim ligneCible As Long
        ligneCible = dictCaissonsLignes(cle)
        ws.Cells(ligneCible, 23).Value = dictCaissonsVides(cle) ' Colonne W = 23
    Next cle
    
End Sub

' =====================================================
' FONCTION : Calculer les espaces vides pour une ligne spécifique - SUPPRIMÉE
' =====================================================
' SUB : Ajuster la taille de police intelligemment selon contenu et largeur
' =====================================================
Sub AjusterTaillePoliceIntelligente(rng As Range, largeurCellule As Integer, contenu As String, estVoie As Boolean)
    Dim tailleOptimale As Integer
    Dim tailleMax As Integer
    Dim tailleMin As Integer
    Dim longueurMaxLigne As Integer
    Dim nbLignesEstimees As Integer
    
    ' Définir les limites de taille selon le type de contenu
    If estVoie Then
        ' Pour les noms de voies : plus de liberté
        tailleMin = 6
        tailleMax = 28
    Else
        ' Pour les numéros PDI : plus conservateur
        tailleMin = 6
        tailleMax = 16
    End If
    
    ' Analyser le contenu et estimer la répartition des lignes
    Call AnalyserContenuAvecWrapText(contenu, largeurCellule, longueurMaxLigne, nbLignesEstimees)
    
    ' Calculer la taille optimale basée sur l'espace disponible
    tailleOptimale = CalculerTailleOptimaleAvecWrap(largeurCellule, longueurMaxLigne, nbLignesEstimees, estVoie)
    
    ' Appliquer les limites
    If tailleOptimale < tailleMin Then tailleOptimale = tailleMin
    If tailleOptimale > tailleMax Then tailleOptimale = tailleMax
    
    ' Appliquer la taille
    With rng.Font
        .Size = tailleOptimale
    End With
End Sub

' =====================================================
' SUB : Analyser le contenu en tenant compte du WrapText - VERSION CONSERVATRICE
' =====================================================
Sub AnalyserContenuAvecWrapText(contenu As String, largeurCellule As Integer, ByRef longueurMaxLigne As Integer, ByRef nbLignesEstimees As Integer)
    Dim lignesExplicites As Variant
    Dim i As Integer, j As Integer
    Dim ligneActuelle As String
    Dim mots As Variant
    Dim longueurLigneActuelle As Integer
    Dim capaciteParLigne As Integer
    Dim lignesFinales As Collection
    
    ' Estimer la capacité de caractères par ligne selon la largeur - PLUS CONSERVATEUR
    ' Réduction significative pour éviter tout débordement
    Select Case largeurCellule
        Case 1
            capaciteParLigne = 5   ' Très conservateur pour 1 colonne
        Case 2
            capaciteParLigne = 10  ' Conservateur pour 2 colonnes
        Case 3
            capaciteParLigne = 16  ' 3 colonnes
        Case 4
            capaciteParLigne = 22  ' 4 colonnes
        Case 5
            capaciteParLigne = 28  ' 5 colonnes
        Case Else
            capaciteParLigne = largeurCellule * 6  ' Formule conservatrice
    End Select
    
    Set lignesFinales = New Collection
    longueurMaxLigne = 0
    
    ' Si le contenu est vide, valeurs par défaut
    If Len(contenu) = 0 Then
        longueurMaxLigne = 1
        nbLignesEstimees = 1
        Exit Sub
    End If
    
    ' Séparer d'abord par les sauts de ligne explicites (vbCrLf)
    If InStr(contenu, vbCrLf) > 0 Then
        lignesExplicites = Split(contenu, vbCrLf)
    Else
        ReDim lignesExplicites(0)
        lignesExplicites(0) = contenu
    End If
    
    ' Pour chaque ligne explicite, analyser le wrap automatique
    For i = 0 To UBound(lignesExplicites)
        ligneActuelle = Trim(lignesExplicites(i))
        
        ' Si la ligne est courte, pas de wrap nécessaire
        If Len(ligneActuelle) <= capaciteParLigne Then
            lignesFinales.Add ligneActuelle
            If Len(ligneActuelle) > longueurMaxLigne Then
                longueurMaxLigne = Len(ligneActuelle)
            End If
        Else
            ' La ligne est trop longue, simuler le wrap par mots
            mots = Split(ligneActuelle, " ")
            Dim ligneEnCours As String
            ligneEnCours = ""
            
            For j = 0 To UBound(mots)
                ' Tester si on peut ajouter le mot suivant
                Dim ligneTest As String
                If ligneEnCours = "" Then
                    ligneTest = mots(j)
                Else
                    ligneTest = ligneEnCours & " " & mots(j)
                End If
                
                ' Si ça rentre encore, continuer
                If Len(ligneTest) <= capaciteParLigne Then
                    ligneEnCours = ligneTest
                Else
                    ' Finir la ligne actuelle et commencer une nouvelle
                    If ligneEnCours <> "" Then
                        lignesFinales.Add ligneEnCours
                        If Len(ligneEnCours) > longueurMaxLigne Then
                            longueurMaxLigne = Len(ligneEnCours)
                        End If
                    End If
                    ligneEnCours = mots(j)
                End If
            Next j
            
            ' Ajouter la dernière ligne en cours
            If ligneEnCours <> "" Then
                lignesFinales.Add ligneEnCours
                If Len(ligneEnCours) > longueurMaxLigne Then
                    longueurMaxLigne = Len(ligneEnCours)
                End If
            End If
        End If
    Next i
    
    ' Résultats finaux
    nbLignesEstimees = lignesFinales.Count
    If longueurMaxLigne = 0 Then longueurMaxLigne = 1
    
End Sub

' =====================================================
' FONCTION : Calculer la taille optimale avec WrapText - VERSION SÉCURISÉE
' =====================================================
Function CalculerTailleOptimaleAvecWrap(largeurCellule As Integer, longueurMaxLigne As Integer, nbLignesEstimees As Integer, estVoie As Boolean) As Integer
    Dim espaceHorizontal As Double
    Dim espaceVertical As Double
    Dim tailleParLargeur As Integer
    Dim tailleParHauteur As Integer
    Dim tailleOptimale As Integer
    Dim margeSecurite As Double
    
    ' Marges de sécurité pour éviter tout débordement
    margeSecurite = 0.7  ' Utiliser seulement 70% de l'espace estimé
    
    ' Estimer l'espace horizontal disponible - PLUS CONSERVATEUR
    espaceHorizontal = largeurCellule * 20 * margeSecurite ' Réduit de 25 à 20 pixels
    
    ' Estimer l'espace vertical disponible - PLUS CONSERVATEUR
    If estVoie Then
        espaceVertical = 35 * margeSecurite ' Réduit de 39 à 35
    Else
        espaceVertical = 43 * margeSecurite ' Réduit de 48.75 à 43
    End If
    
    ' Calculer la taille optimale selon la largeur (contrainte horizontale)
    If longueurMaxLigne > 0 Then
        tailleParLargeur = Int(espaceHorizontal / (longueurMaxLigne * 1.6)) ' Augmenté de 1.3 à 1.6
    Else
        tailleParLargeur = 8
    End If
    
    ' Calculer la taille optimale selon la hauteur (contrainte verticale)
    If nbLignesEstimees > 0 Then
        tailleParHauteur = Int(espaceVertical / (nbLignesEstimees * 1.8)) ' Augmenté de 1.4 à 1.8
    Else
        tailleParHauteur = 8
    End If
    
    ' Prendre la contrainte la plus restrictive
    tailleOptimale = Application.WorksheetFunction.Min(tailleParLargeur, tailleParHauteur)
    
    ' Limites absolues de sécurité
    If estVoie Then
        ' Pour les voies : limites plus strictes
        Select Case largeurCellule
            Case 1
                If tailleOptimale > 7 Then tailleOptimale = 7   ' Max très bas pour 1 col
                If tailleOptimale < 6 Then tailleOptimale = 6
            Case 2
                If tailleOptimale > 9 Then tailleOptimale = 9   ' Max bas pour 2 col
                If tailleOptimale < 7 Then tailleOptimale = 7
            Case 3
                If tailleOptimale > 11 Then tailleOptimale = 11
                If tailleOptimale < 8 Then tailleOptimale = 8
            Case 4
                If tailleOptimale > 13 Then tailleOptimale = 13
                If tailleOptimale < 9 Then tailleOptimale = 9
            Case Else
                If tailleOptimale > 16 Then tailleOptimale = 16
                If tailleOptimale < 10 Then tailleOptimale = 10
        End Select
    Else
        ' Pour les numéros : encore plus conservateur
        Select Case largeurCellule
            Case 1
                If tailleOptimale > 6 Then tailleOptimale = 6   ' Max très bas
                If tailleOptimale < 6 Then tailleOptimale = 6
            Case 2
                If tailleOptimale > 8 Then tailleOptimale = 8
                If tailleOptimale < 6 Then tailleOptimale = 6
            Case 3
                If tailleOptimale > 10 Then tailleOptimale = 10
                If tailleOptimale < 7 Then tailleOptimale = 7
            Case Else
                If tailleOptimale > 12 Then tailleOptimale = 12
                If tailleOptimale < 8 Then tailleOptimale = 8
        End Select
    End If
    
    CalculerTailleOptimaleAvecWrap = tailleOptimale
End Function

' =====================================================
' SUB : Ajuster la taille de police selon la largeur de cellule - VERSION SÉCURISÉE
' =====================================================
Sub AjusterTaillePoliceSelonLargeur(rng As Range, largeurCellule As Integer)
    ' Cette fonction est maintenant un wrapper pour la version intelligente
    ' On analyse le contenu de la cellule de manière sécurisée
    Dim contenu As String
    Dim valeurCellule As Variant
    
    ' Récupération sécurisée du contenu
    On Error Resume Next
    valeurCellule = rng.Value
    If Err.Number <> 0 Or IsNull(valeurCellule) Or IsEmpty(valeurCellule) Then
        contenu = ""
        Err.Clear
    Else
        contenu = CStr(valeurCellule)
    End If
    On Error GoTo 0
    
    Call AjusterTaillePoliceIntelligente(rng, largeurCellule, contenu, False) ' False = numéros PDI
End Sub

' =====================================================
' SUB : Ajuster la taille de police pour les noms de voies - VERSION SÉCURISÉE
' =====================================================
Sub AjusterTaillePoliceVoiesSelonLargeur(rng As Range, largeurCellule As Integer)
    ' Cette fonction est maintenant un wrapper pour la version intelligente
    ' On analyse le contenu de la cellule de manière sécurisée
    Dim contenu As String
    Dim valeurCellule As Variant
    
    ' Récupération sécurisée du contenu
    On Error Resume Next
    valeurCellule = rng.Value
    If Err.Number <> 0 Or IsNull(valeurCellule) Or IsEmpty(valeurCellule) Then
        contenu = ""
        Err.Clear
    Else
        contenu = CStr(valeurCellule)
    End If
    On Error GoTo 0
    
    Call AjusterTaillePoliceIntelligente(rng, largeurCellule, contenu, True) ' True = noms de voies
End Sub

' =====================================================
' SUB : Appliquer un formatage différencié pour numéros et observations - SANS ÉCRASER LES TAILLES
' =====================================================
Sub AppliquerFormatageDifferencie(rng As Range, symbole As String, numAccumule As String, obsAccumulees As String)
    Dim longueurNumeroAvecSymbole As Integer
    Dim debutObservations As Integer
    
    ' Calculer la longueur de la partie numéro + symbole
    longueurNumeroAvecSymbole = Len(symbole & numAccumule)
    
    ' Vérifier qu'on a quelque chose à formater
    If longueurNumeroAvecSymbole = 0 Then Exit Sub
    
    ' Formatage avec gestion d'erreur complète
    On Error GoTo FormatageFallback
    
    ' Si pas d'observations, formater tout en gras
    If obsAccumulees = "" Then
        ' Tout le texte (symbole + numéro) en gras - SANS MODIFIER LA TAILLE
        rng.Characters(1, longueurNumeroAvecSymbole).Font.Bold = True
    Else
        ' Formater la partie numéro (symbole + numéro) : gras - SANS MODIFIER LA TAILLE
        rng.Characters(1, longueurNumeroAvecSymbole).Font.Bold = True
        
        ' Formater la partie observations (après le saut de ligne) : pas gras - SANS MODIFIER LA TAILLE
        debutObservations = longueurNumeroAvecSymbole + 2 ' +2 pour vbCrLf (saut de ligne)
        
        If Len(obsAccumulees) > 0 Then
            rng.Characters(debutObservations, Len(obsAccumulees)).Font.Bold = False
        End If
    End If
    
    On Error GoTo 0
    Exit Sub
    
FormatageFallback:
    ' En cas d'erreur, appliquer un formatage global simple - SANS MODIFIER LA TAILLE
    On Error Resume Next
    rng.Font.Bold = True
    On Error GoTo 0
    
End Sub

' =====================================================
' SUB : Ajouter le code VBA dans la feuille Accueil pour navigation inverse
' =====================================================
Sub AjouterCodeMenuContextuelAccueil(wsAccueil As Worksheet)
    Dim codeModule As Object
    Dim codeVBA As String
    
    ' Tenter d'accéder au module de code de la feuille Accueil
    On Error GoTo ErreurAccesVBAAccueil
    
    Set codeModule = ThisWorkbook.VBProject.VBComponents(wsAccueil.CodeName).codeModule
    
    ' Supprimer tout le code existant pour éviter les conflits
    If codeModule.CountOfLines > 0 Then
        codeModule.DeleteLines 1, codeModule.CountOfLines
    End If
    
    ' Code VBA à ajouter dans la feuille Accueil (version propre)
    codeVBA = "Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)" & vbCrLf
    codeVBA = codeVBA & "    ' Navigation vers façade PDI" & vbCrLf
    codeVBA = codeVBA & "    Call AjouterOptionMenuContextuelAccueil(Target)" & vbCrLf
    codeVBA = codeVBA & "End Sub" & vbCrLf & vbCrLf
    
    codeVBA = codeVBA & "Private Sub Worksheet_Change(ByVal Target As Range)" & vbCrLf
    codeVBA = codeVBA & "    ' Mise à jour en temps réel de la colonne W si modification en colonne G" & vbCrLf
    codeVBA = codeVBA & "    Call GererChangementColonneG(Target)" & vbCrLf
    codeVBA = codeVBA & "End Sub" & vbCrLf & vbCrLf
    
    codeVBA = codeVBA & "Private Sub Worksheet_Deactivate()" & vbCrLf
    codeVBA = codeVBA & "    Call SupprimerOptionMenuContextuel" & vbCrLf
    codeVBA = codeVBA & "End Sub" & vbCrLf & vbCrLf
    
    codeVBA = codeVBA & "Private Sub Worksheet_Activate()" & vbCrLf
    codeVBA = codeVBA & "    Call SupprimerOptionMenuContextuel" & vbCrLf
    codeVBA = codeVBA & "End Sub"
    
    ' Insérer le code proprement
    codeModule.InsertLines 1, codeVBA
    
    Exit Sub
    
ErreurAccesVBAAccueil:
    ' Si erreur, ne rien faire (navigation inverse non disponible)
End Sub

' =====================================================
' SUB : Ajouter option menu contextuel dans Accueil
' =====================================================
Sub AjouterOptionMenuContextuelAccueil(Target As Range)
    Dim menuContextuel As CommandBar
    Dim nouvelleOption As CommandBarButton
    
    ' Supprimer l'option existante
    Call SupprimerOptionMenuContextuel
    
    ' Vérifier qu'on est dans la zone des données (ligne 7+, colonne A-H)
    If Target.Row < 7 Or Target.Column > 8 Then
        Exit Sub
    End If
    
    ' Vérifier qu'il y a un code caisson en colonne H
    If Target.Worksheet.Cells(Target.Row, 8).Value = "" Then
        Exit Sub
    End If
    
    ' Accéder au menu contextuel
    Set menuContextuel = Application.CommandBars("Cell")
    
    ' Ajouter l'option
    Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, before:=1)
    With nouvelleOption
        .Caption = "Naviguer vers case Façade"
        .OnAction = "NaviguerVersFacadeDepuisAccueil"
        .Tag = "NavigationPDI"
        .FaceId = 1695
    End With
End Sub

' =====================================================
' SUB : Navigation Accueil vers Facade
' =====================================================
Sub NaviguerVersFacadeDepuisAccueil()
    Dim wsAccueil As Worksheet
    Dim wsFacade As Worksheet
    Dim celluleCible As Range
    Dim codePosition As String
    Dim ligneAccueil As Long
    
    Set wsAccueil = ActiveSheet
    Set celluleCible = Selection
    ligneAccueil = celluleCible.Row
    
    ' Vérifier qu'on est sur Accueil
    If wsAccueil.Name <> "Accueil" Then Exit Sub
    
    ' Lire le code en colonne H
    codePosition = wsAccueil.Cells(ligneAccueil, 8).Value
    If codePosition = "" Then Exit Sub
    
    ' Vérifier que la feuille Facade_PDI existe
    On Error GoTo FacadeInexistante
    Set wsFacade = ThisWorkbook.Sheets("Facade_PDI")
    On Error GoTo 0
    
    ' Extraire les informations du code (ex: "2A 15")
    Dim partieCode As String, partiePosition As String
    Dim posEspace As Integer
    posEspace = InStr(codePosition, " ")
    If posEspace = 0 Then Exit Sub
    
    partieCode = Left(codePosition, posEspace - 1) ' "2A"
    partiePosition = Right(codePosition, Len(codePosition) - posEspace) ' "15"
    
    ' Extraire numéro et lettre du code caisson
    Dim numeroCaisson As Integer, lettreCaisson As String
    numeroCaisson = val(Left(partieCode, Len(partieCode) - 1))
    lettreCaisson = Right(partieCode, 1)
    
    ' Calculer la ligne de la façade
    Dim maxParCaisson As Integer
    maxParCaisson = val(wsAccueil.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4
    
    Dim lettreIndex As Integer
    lettreIndex = Asc(lettreCaisson) - Asc("A") ' A=0, B=1, C=2, D=3
    
    Dim indiceLigne As Integer
    indiceLigne = (lettreIndex * maxParCaisson) + numeroCaisson
    
    Dim ligneFacade As Integer
    ligneFacade = (indiceLigne * 2) - 1 ' Ligne du haut du caisson
    
    ' Colonne de la façade
    Dim colonneFacade As Integer
    colonneFacade = val(partiePosition)
    
    ' Naviguer vers la façade
    wsFacade.Activate
    wsFacade.Cells(ligneFacade, colonneFacade).Select
    
    Exit Sub
    
FacadeInexistante:
    ' La feuille n'existe pas, ne rien faire
End Sub


' =====================================================
' SUB MODIFIÉE : Ajouter les boutons avec macros intégrées - DISPOSITION VERTICALE COLONNE AC
' =====================================================
Sub AjouterBoutonsSeulement(wsFacade As Worksheet)
    Dim btn As Object
    Dim positionX As Double
    Dim espacement As Double
    Dim largeurBouton As Double
    Dim hauteurBouton As Double
    
    ' Supprimer les boutons existants s'ils existent
    Dim shp As Shape
    For Each shp In wsFacade.Shapes
        If shp.Type = msoFormControl Then shp.Delete
    Next shp
    
    ' Configuration de la disposition verticale en colonne AC
    positionX = wsFacade.Columns("AC").Left + 2  ' Position X en colonne AC avec petite marge
    largeurBouton = wsFacade.Columns("AC").Width + 80  ' Largeur adaptée à la colonne moins marges
    hauteurBouton = 25  ' Hauteur standard des boutons
    espacement = 20     ' Espacement vertical entre les boutons
    
    ' BOUTON 1 : Optimiser Affichage
    Set btn = wsFacade.Buttons.Add(positionX, 10, largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "1. Supprimer contenu voies uniques"
        .OnAction = "OptimiserAffichageFromButton"
        .Font.Bold = True
        .Font.Size = 9
    End With
    
    ' BOUTON 2 : Insérer Images
    Set btn = wsFacade.Buttons.Add(positionX, 10 + (espacement * 2), largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "2. Insérer Images voies uniques"
        .OnAction = "InsererImagesFromButton"
        .Font.Bold = True
        .Font.Size = 9
    End With
        
    ' BOUTON 3 : Simplifier Bornes
    Set btn = wsFacade.Buttons.Add(positionX, 10 + (espacement * 4), largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "3. Simplifier Bornes"
        .OnAction = "SimplifierBornesFromButton"
        .Font.Bold = True
        .Font.Size = 9
    End With
    
     ' BOUTON 4 : Ajuster Polices Intelligentes
    Set btn = wsFacade.Buttons.Add(positionX, 10 + (espacement * 6), largeurBouton, hauteurBouton)
    With btn
        .Characters.Text = "4. Ajuster taille polices"
        .OnAction = "AjusterPolicesFromButton"
        .Font.Bold = True
        .Font.Size = 9
    End With
    
End Sub

' =====================================================
' NOUVELLES MACROS POUR LES BOUTONS
' =====================================================

Sub OptimiserAffichageFromButton()
    ' Macro appelée par le bouton "Optimiser Affichage"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur la bonne feuille
    If ws.Name <> "Facade_PDI" Then
        MsgBox "Cette fonction doit être utilisée sur la feuille Facade_PDI", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant exécution
    If MsgBox("Voulez-vous optimiser l'affichage de la façade ?" & vbCrLf & _
              "Cette action va supprimer les numéros uniques pour simplifier la vue.", _
              vbQuestion + vbYesNo, "Optimiser Affichage") = vbYes Then
        
        ' Exécuter la macro d'optimisation
        Call OptimiserAffichageFacade
    End If
End Sub

Sub SimplifierBornesFromButton()
    ' Macro appelée par le bouton "Simplifier Bornes"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur la bonne feuille
    If ws.Name <> "Facade_PDI" Then
        MsgBox "Cette fonction doit être utilisée sur la feuille Facade_PDI", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant exécution
    If MsgBox("Voulez-vous simplifier les bornes de numéros ?" & vbCrLf & _
              "Cette action va regrouper les numéros consécutifs en plages.", _
              vbQuestion + vbYesNo, "Simplifier Bornes") = vbYes Then
        
        ' Exécuter la macro de simplification des bornes
        Call SimplificationBornesNumPDI
    End If
End Sub

Sub AjusterPolicesFromButton()
    ' Macro appelée par le bouton "Ajuster Polices"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur la bonne feuille
    If ws.Name <> "Facade_PDI" Then
        MsgBox "Cette fonction doit être utilisée sur la feuille Facade_PDI", vbExclamation
        Exit Sub
    End If
    
    ' Confirmation avant exécution
    If MsgBox("Voulez-vous ajuster automatiquement la taille des polices ?" & vbCrLf & _
              "Cette action va optimiser la lisibilité selon la taille des cellules.", _
              vbQuestion + vbYesNo, "Ajuster Polices") = vbYes Then
        
        ' Exécuter la macro d'ajustement des polices
        Call AjusterTaillePoliceFacade
    End If
End Sub

Sub InsererImagesFromButton()
    ' Macro appelée par le bouton "Insérer Images"
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Vérifier qu'on est sur la bonne feuille
    If ws.Name <> "Facade_PDI" Then
        MsgBox "Cette fonction doit être utilisée sur la feuille Facade_PDI", vbExclamation
        Exit Sub
    End If
    
    ' Message d'information et confirmation
    If MsgBox("Voulez-vous insérer des images dans les cellules vides ?" & vbCrLf & _
              "Vous devrez sélectionner un fichier image à utiliser.", _
              vbQuestion + vbYesNo, "Insérer Images") = vbYes Then
        
        ' Exécuter la macro d'insertion d'images
        Call InsererImagesDansCellulesVides
    End If
End Sub


' =====================================================
' MACRO UTILITAIRE : Ajuster paramètres d'impression
' =====================================================
Sub AjusterParametresImpression()
    ' Fonction utilitaire pour optimiser l'impression de la façade
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Configuration de l'impression
    With ws.PageSetup
        .Orientation = xlLandscape
        .FitToPagesWide = 1
        .FitToPagesTall = False
        .CenterHorizontally = True
        .CenterVertically = False
        .PrintArea = "A1:AA" & ws.UsedRange.Rows.Count
        .LeftMargin = Application.InchesToPoints(0.25)
        .RightMargin = Application.InchesToPoints(0.25)
        .TopMargin = Application.InchesToPoints(0.25)
        .BottomMargin = Application.InchesToPoints(0.25)
        .HeaderMargin = Application.InchesToPoints(0.1)
        .FooterMargin = Application.InchesToPoints(0.1)
    End With
End Sub

' =====================================================
' FONCTION UTILITAIRE : Obtenir le nom de l'onglet actif
' =====================================================
Sub NomOngletActif()
    ' Fonction utilitaire utilisée par les autres macros
    ' (Cette fonction semble être une dépendance des macros importées)
    Dim nomOnglet As String
    nomOnglet = ActiveSheet.Name
    ' Vous pouvez ajouter ici du code si nécessaire
End Sub

' =====================================================
' MACRO AVANCÉE : Menu contextuel intelligent
' =====================================================
Sub AjouterMenuContextuelAvance(ws As Worksheet)
    ' Version avancée du menu contextuel avec plus d'options
    Dim codeModule As Object
    Dim codeVBA As String
    
    On Error GoTo ErreurAccesVBA
    
    Set codeModule = ThisWorkbook.VBProject.VBComponents(ws.CodeName).codeModule
    
    ' Supprimer l'ancien code s'il existe
    If codeModule.CountOfLines > 0 Then
        codeModule.DeleteLines 1, codeModule.CountOfLines
    End If
    
    ' Code VBA avancé pour le menu contextuel
    codeVBA = "Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)" & vbCrLf
    codeVBA = codeVBA & "    Call AjouterMenuContextuelIntelligent(Target)" & vbCrLf
    codeVBA = codeVBA & "End Sub" & vbCrLf & vbCrLf
    
    codeVBA = codeVBA & "Private Sub Worksheet_Deactivate()" & vbCrLf
    codeVBA = codeVBA & "    Call SupprimerOptionMenuContextuel" & vbCrLf
    codeVBA = codeVBA & "End Sub" & vbCrLf & vbCrLf
    
    codeVBA = codeVBA & "Private Sub Worksheet_Activate()" & vbCrLf
    codeVBA = codeVBA & "    Call SupprimerOptionMenuContextuel" & vbCrLf
    codeVBA = codeVBA & "End Sub"
    
    ' Insérer le code
    codeModule.InsertLines 1, codeVBA
    
    Exit Sub
    
ErreurAccesVBA:
    ' Si erreur d'accès VBA, ne rien faire
End Sub

' =====================================================
' MENU CONTEXTUEL INTELLIGENT
' =====================================================
Sub AjouterMenuContextuelIntelligent(Target As Range)
    Dim menuContextuel As CommandBar
    Dim nouvelleOption As CommandBarButton
    
    ' Supprimer les options existantes
    Call SupprimerOptionMenuContextuel
    
    ' Vérifier la zone cliquée
    If Target.Column = 27 Then Exit Sub ' Colonne des codes caisson
    
    Set menuContextuel = Application.CommandBars("Cell")
    
    ' Option principale de navigation
    Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, before:=1)
    With nouvelleOption
        .Caption = "Naviguer vers ligne Accueil"
        .OnAction = "NaviguerDepuisMenuContextuel"
        .Tag = "NavigationPDI"
        .FaceId = 1695
    End With
    
    ' Séparateur
    menuContextuel.Controls.Add Type:=msoControlButton, before:=2
    menuContextuel.Controls(2).BeginGroup = True
    
    ' Options d'optimisation si cellule non vide
    If Not IsEmpty(Target.Value) Then
        Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, before:=3)
        With nouvelleOption
            .Caption = "? Optimiser cette zone"
            .OnAction = "OptimiserZoneSelectionnee"
            .Tag = "NavigationPDI"
        End With
    End If
    
    ' Option pour cellules vides
    If IsEmpty(Target.Value) Then
        Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, before:=3)
        With nouvelleOption
            .Caption = "Insérer image ici"
            .OnAction = "InsererImageCellule"
            .Tag = "NavigationPDI"
        End With
    End If
End Sub

' =====================================================
' MACROS POUR LES OPTIONS DU MENU CONTEXTUEL
' =====================================================
Sub OptimiserZoneSelectionnee()
    ' Optimise la zone autour de la cellule sélectionnée
    Dim cellule As Range
    Set cellule = Selection
    
    MsgBox "Optimisation de la zone autour de " & cellule.Address, vbInformation
    ' Ici vous pouvez ajouter la logique d'optimisation locale
End Sub

Sub InsererImageCellule()
    ' Insère une image dans la cellule sélectionnée uniquement
    Dim cellule As Range
    Set cellule = Selection
    
    If IsEmpty(cellule.Value) Then
        MsgBox "Insertion d'image dans " & cellule.Address, vbInformation
        ' Appel à une version modifiée d'insertion d'image pour une seule cellule
    Else
        MsgBox "Cette cellule n'est pas vide", vbExclamation
    End If
End Sub


' =====================================================
' SUB : Ajouter automatiquement le code du menu contextuel
' =====================================================
Sub AjouterCodeMenuContextuel(wsFacade As Worksheet)
    Dim codeModule As Object
    Dim codeVBA As String
    
    ' Tenter d'accéder au module de code de la feuille
    On Error GoTo ErreurAccesVBA
    
    Set codeModule = ThisWorkbook.VBProject.VBComponents(wsFacade.CodeName).codeModule
    
    ' Supprimer l'ancien code s'il existe
    If codeModule.CountOfLines > 0 Then
        codeModule.DeleteLines 1, codeModule.CountOfLines
    End If
    
    ' Code VBA à insérer dans la feuille Facade_PDI
    codeVBA = "Private Sub Worksheet_BeforeRightClick(ByVal Target As Range, Cancel As Boolean)" & vbCrLf
    codeVBA = codeVBA & "    ' Ajouter une option au menu contextuel" & vbCrLf
    codeVBA = codeVBA & "    Call AjouterOptionMenuContextuel(Target)" & vbCrLf
    codeVBA = codeVBA & "End Sub" & vbCrLf & vbCrLf
    
    codeVBA = codeVBA & "Private Sub Worksheet_Deactivate()" & vbCrLf
    codeVBA = codeVBA & "    ' Nettoyer le menu contextuel quand on quitte la feuille" & vbCrLf
    codeVBA = codeVBA & "    Call SupprimerOptionMenuContextuel" & vbCrLf
    codeVBA = codeVBA & "End Sub" & vbCrLf & vbCrLf
    
    codeVBA = codeVBA & "Private Sub Worksheet_Activate()" & vbCrLf
    codeVBA = codeVBA & "    ' Nettoyer le menu contextuel au cas où" & vbCrLf
    codeVBA = codeVBA & "    Call SupprimerOptionMenuContextuel" & vbCrLf
    codeVBA = codeVBA & "End Sub"
    
    ' Insérer le code dans le module de la feuille
    codeModule.InsertLines 1, codeVBA
    
    Exit Sub
    
ErreurAccesVBA:
    ' Si l'accès VBA est bloqué, ne rien afficher (message supprimé)
End Sub

' =====================================================
' SUB : Ajouter une option au menu contextuel Excel
' =====================================================
Sub AjouterOptionMenuContextuel(Target As Range)
    Dim menuContextuel As CommandBar
    Dim nouvelleOption As CommandBarButton
    
    ' Supprimer l'option existante si elle existe déjà
    Call SupprimerOptionMenuContextuel
    
    ' Vérifier qu'on est dans une zone valide de la façade
    ' Exclure seulement la colonne AA (codes caisson)
    ' Les boutons sont positionnés différemment et ne gênent pas les cases PDI
    If Target.Column = 27 Then
        Exit Sub ' Ne pas ajouter l'option dans la colonne des codes caisson
    End If
    
    ' Accéder au menu contextuel des cellules
    Set menuContextuel = Application.CommandBars("Cell")
    
    ' Ajouter une nouvelle option au début du menu
    Set nouvelleOption = menuContextuel.Controls.Add(Type:=msoControlButton, before:=1)
    With nouvelleOption
        .Caption = "Naviguer vers ligne Accueil"
        .OnAction = "NaviguerDepuisMenuContextuel"
        .Tag = "NavigationPDI"
        .FaceId = 1695 ' Icône de navigation
    End With
End Sub

' =====================================================
' SUB : Supprimer l'option du menu contextuel - VERSION AMÉLIORÉE
' =====================================================
Sub SupprimerOptionMenuContextuel()
    Dim ctrl As CommandBarControl
    Dim menuContextuel As CommandBar
    Dim i As Integer
    
    On Error Resume Next
    Set menuContextuel = Application.CommandBars("Cell")
    
    ' NOUVELLE APPROCHE : Supprimer en partant de la fin pour éviter les décalages d'index
    For i = menuContextuel.Controls.Count To 1 Step -1
        Set ctrl = menuContextuel.Controls(i)
        ' Supprimer si c'est notre contrôle OU si c'est un contrôle vide/corrompu
        If ctrl.Tag = "NavigationPDI" Or ctrl.Caption = "" Or ctrl.Caption Like "*Naviguer*" Then
            ctrl.Delete
        End If
    Next i
    
    On Error GoTo 0
End Sub

' =====================================================
' SUB : Navigation depuis le menu contextuel
' =====================================================
Sub NaviguerDepuisMenuContextuel()
    Dim celluleCible As Range
    Dim wsAccueil As Worksheet
    Dim wsFacade As Worksheet
    
    Set wsFacade = ActiveSheet
    Set wsAccueil = ThisWorkbook.Sheets("Accueil")
    Set celluleCible = Selection
    
    ' Vérifier qu'on est bien sur la feuille Facade_PDI
    If wsFacade.Name <> "Facade_PDI" Then
        Exit Sub
    End If
    
    ' Calculer la position
    Dim celluleReference As Range
    Set celluleReference = celluleCible.Cells(1, 1)
    
    Dim ligneFacade As Long, colonneFacade As Long
    ligneFacade = celluleReference.Row
    colonneFacade = celluleReference.Column
    
    ' Ajuster pour ligne du haut
    If ligneFacade Mod 2 = 0 Then ligneFacade = ligneFacade - 1
    
    ' Pour cellules fusionnées
    On Error Resume Next
    If celluleReference.MergeCells Then
        colonneFacade = celluleReference.MergeArea.Column
    End If
    On Error GoTo 0
    
    ' Calculer le code
    Dim maxParCaisson As Integer
    maxParCaisson = val(wsAccueil.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4
    
    Dim indiceLigne As Integer
    indiceLigne = (ligneFacade + 1) / 2
    Dim numeroCaissonCalcule As Integer
    numeroCaissonCalcule = ((indiceLigne - 1) Mod (maxParCaisson * 4)) Mod maxParCaisson + 1
    Dim lettreIndex As Integer
    lettreIndex = ((indiceLigne - 1) \ maxParCaisson) Mod 4
    Dim lettreCaissonCalculee As String
    lettreCaissonCalculee = Chr(Asc("A") + lettreIndex)
    
    Dim codePosition As String
    codePosition = numeroCaissonCalcule & lettreCaissonCalculee & " " & Format(colonneFacade, "00")
    
    ' Chercher et naviguer
    Dim ligneAccueil As Long
    Dim derniereLigne As Long
    derniereLigne = wsAccueil.Cells(wsAccueil.Rows.Count, "A").End(xlUp).Row
    
    For ligneAccueil = 7 To derniereLigne
        If wsAccueil.Cells(ligneAccueil, 8).Value = codePosition Then
            ' Naviguer vers cette ligne
            wsAccueil.Activate
            wsAccueil.Cells(ligneAccueil, 1).Select
            Exit Sub
        End If
    Next ligneAccueil
    
    ' Si pas trouvé, ne rien faire (pas de message)
End Sub

' =====================================================
' SUB : Fonctions pour les boutons (dans module standard)
' =====================================================
Sub RegénérerFaçadeFromButton()
    Call GenererFacadePDI
End Sub

Sub RetourAccueilFromButton()
    ThisWorkbook.Sheets("Accueil").Activate
End Sub

Sub NavigationManuelle()
    ' Navigation manuelle basée sur la cellule sélectionnée
    Dim celluleCible As Range
    Dim wsAccueil As Worksheet
    Dim wsFacade As Worksheet
    Dim ligneAccueil As Long
    Dim codePosition As String
    Dim numeroPosition As String
    Dim ligneFacade As Long
    Dim colonneFacade As Long
    
    Set wsFacade = ActiveSheet
    Set wsAccueil = ThisWorkbook.Sheets("Accueil")
    Set celluleCible = Selection
    
    ' Vérifier qu'on est bien sur la feuille Facade_PDI
    If wsFacade.Name <> "Facade_PDI" Then
        MsgBox "Veuillez d'abord sélectionner une cellule sur la feuille Facade_PDI", vbExclamation
        Exit Sub
    End If
    
    ' NOUVELLE LOGIQUE SÉCURISÉE : Gérer les cellules fusionnées
    Dim celluleReference As Range
    
    ' Prendre la première cellule de la sélection (gère automatiquement fusionné ou normal)
    Set celluleReference = celluleCible.Cells(1, 1)
    
    ' Ignorer si on clique sur la colonne AA (codes caisson)
    If celluleReference.Column = 27 Then
        MsgBox "Veuillez sélectionner une case de PDI dans la façade (colonnes A à Z)", vbExclamation
        Exit Sub
    End If
    
    ' Déterminer la ligne et colonne de la façade (basé sur la cellule de référence)
    ligneFacade = celluleReference.Row
    colonneFacade = celluleReference.Column
    
    ' Ajuster pour prendre la ligne du haut si on clique sur la ligne du bas
    If ligneFacade Mod 2 = 0 Then ligneFacade = ligneFacade - 1
    
    ' Pour les cellules fusionnées, chercher la vraie colonne de début
    On Error Resume Next
    If celluleReference.MergeCells Then
        colonneFacade = celluleReference.MergeArea.Column
    End If
    On Error GoTo 0
    
    ' Calculer le code caisson et position
    Dim maxParCaisson As Integer
    maxParCaisson = val(wsAccueil.Range("C1").Value)
    If maxParCaisson <= 0 Then maxParCaisson = 4
    
    ' Calcul du numéro de caisson basé sur la ligne de la façade
    Dim numeroCaissonCalcule As Integer
    Dim lettreCaissonCalculee As String
    Dim indiceLigne As Integer
    
    indiceLigne = (ligneFacade + 1) / 2 ' 1, 2, 3...
    numeroCaissonCalcule = ((indiceLigne - 1) Mod (maxParCaisson * 4)) Mod maxParCaisson + 1
    Dim lettreIndex As Integer
    lettreIndex = ((indiceLigne - 1) \ maxParCaisson) Mod 4
    lettreCaissonCalculee = Chr(Asc("A") + lettreIndex)
    
    ' Construire le code de position complet
    numeroPosition = Format(colonneFacade, "00")
    codePosition = numeroCaissonCalcule & lettreCaissonCalculee & " " & numeroPosition
    
    ' DEBUG: Afficher les informations de calcul
    Dim msgDebug As String
    msgDebug = "INFORMATIONS DE NAVIGATION :" & vbCrLf & vbCrLf
    msgDebug = msgDebug & "Position sélectionnée :" & vbCrLf
    msgDebug = msgDebug & "• Ligne façade : " & ligneFacade & vbCrLf
    msgDebug = msgDebug & "• Colonne façade : " & colonneFacade & vbCrLf
    
    ' Vérification sécurisée de la fusion
    Dim estFusionne As Boolean
    On Error Resume Next
    estFusionne = celluleReference.MergeCells
    On Error GoTo 0
    
    msgDebug = msgDebug & "• Cellule fusionnée : " & IIf(estFusionne, "Oui", "Non") & vbCrLf
    msgDebug = msgDebug & "• Code calculé : " & codePosition & vbCrLf & vbCrLf
    msgDebug = msgDebug & "Recherche en cours dans la colonne H..."
    
    ' Chercher dans la colonne H de la feuille Accueil
    Dim derniereLigne As Long
    derniereLigne = wsAccueil.Cells(wsAccueil.Rows.Count, "A").End(xlUp).Row
    
    For ligneAccueil = 7 To derniereLigne
        If wsAccueil.Cells(ligneAccueil, 8).Value = codePosition Then
            ' Naviguer vers cette ligne
            wsAccueil.Activate
            wsAccueil.Cells(ligneAccueil, 1).Select
            MsgBox "? Navigation réussie !" & vbCrLf & _
                   "Ligne " & ligneAccueil & " - PDI : " & wsAccueil.Cells(ligneAccueil, 1).Value & vbCrLf & _
                   "Position façade : " & codePosition, vbInformation, "Navigation"
            Exit Sub
        End If
    Next ligneAccueil
    
    ' Si pas trouvé, afficher les détails pour debug
    msgDebug = msgDebug & vbCrLf & "? RÉSULTAT : Position non trouvée" & vbCrLf & vbCrLf
    msgDebug = msgDebug & "Codes présents en colonne H (échantillon) :" & vbCrLf
    For ligneAccueil = 7 To Application.Min(16, derniereLigne) ' Afficher les 10 premiers
        If wsAccueil.Cells(ligneAccueil, 8).Value <> "" Then
            msgDebug = msgDebug & "• Ligne " & ligneAccueil & " : " & wsAccueil.Cells(ligneAccueil, 8).Value & vbCrLf
        End If
    Next ligneAccueil
    
    MsgBox msgDebug, vbExclamation, "Debug Navigation"
End Sub

' =====================================================
' SUB : Afficher l'aide pour la navigation
' =====================================================
Sub AfficherAideNavigation()
    Dim msg As String
    msg = "AIDE NAVIGATION FAÇADE PDI" & vbCrLf & vbCrLf
    msg = msg & "NAVIGATION ALTERNATIVE :" & vbCrLf
    msg = msg & "   • Sélectionnez une case sur la façade" & vbCrLf
    msg = msg & "   • Cliquez sur le bouton 'Navigation Manuelle'" & vbCrLf
    msg = msg & "   • Vous serez dirigé vers la ligne correspondante" & vbCrLf & vbCrLf
    msg = msg & "BOUTONS :" & vbCrLf
    msg = msg & "   • Régénérer Façade : Recrée la façade avec les données actuelles" & vbCrLf
    msg = msg & "   • Accueil : Retourne à la feuille Accueil" & vbCrLf & vbCrLf
    msg = msg & "CODES COULEUR :" & vbCrLf
    msg = msg & "   • Rouge : Cases hors capacité (> " & ThisWorkbook.Sheets("Accueil").Range("C1").Value & "D)" & vbCrLf
    msg = msg & "   • Jaune : Cases marquées 'B' en colonne V" & vbCrLf
    msg = msg & "   • Couleurs diverses : Différentes voies" & vbCrLf & vbCrLf
    msg = msg & "SYMBOLES :" & vbCrLf
    msg = msg & "   • ? Triangle : Type 'Bat P'" & vbCrLf
    msg = msg & "   • ¦ Carré : Type 'Bat C'" & vbCrLf
    msg = msg & "   • ? Cercle : Voies multiples (affiché dans nom de voie)" & vbCrLf
    msg = msg & "   • HC : Hors Capacité en colonne AA"
    
    MsgBox msg, vbInformation, "Aide Navigation"
End Sub

' =====================================================
' FONCTION CORRIGÉE : Vérifier si un caisson dépasse la limite
' =====================================================
Function CaissonDepasse(codeCaisson As String, maxParCaisson As Integer) As Boolean
    ' Extraire le numéro et la lettre du code caisson
    ' Format : "1A", "2B", etc.
    Dim numero As Integer
    Dim lettre As String
    
    If Len(codeCaisson) >= 2 Then
        numero = val(Left(codeCaisson, Len(codeCaisson) - 1))
        lettre = Right(codeCaisson, 1)
        
        ' LOGIQUE CORRIGÉE : on dépasse si on est au-delà de [maxParCaisson]D
        ' Exemples avec maxParCaisson = 7 :
        ' - 1A à 7D : OK (dans la capacité)
        ' - 8D, 9D, etc. : DÉPASSE (hors capacité)
        ' - 1E, 2E, etc. : DÉPASSE (lettre après D)
        
        If lettre > "D" Then
            ' Toute lettre après D dépasse automatiquement
            CaissonDepasse = True
        ElseIf lettre = "D" And numero > maxParCaisson Then
            ' Pour la lettre D, on dépasse si le numéro > maxParCaisson
            CaissonDepasse = True
        Else
            ' Dans tous les autres cas, c'est dans la capacité
            CaissonDepasse = False
        End If
    Else
        CaissonDepasse = False
    End If
End Function

' =====================================================
' SUB AMÉLIORÉE : Mettre à jour la colonne H avec couleur
' =====================================================
Sub MettreAJourColonneHAvecCouleur(wsSource As Worksheet, dictCodes As Object, dictHorsCapacite As Object)
    Dim ligne As Long
    Dim cle As Variant
    
    ' Parcourir toutes les clés du dictionnaire (numéros de ligne)
    For Each cle In dictCodes.Keys
        ligne = CLng(cle)
        
        ' Mettre à jour la colonne H (colonne 8) avec le code calculé
        wsSource.Cells(ligne, 8).Value = dictCodes(cle)
        
        ' Si cette ligne est hors capacité, la colorer en rouge
        If dictHorsCapacite.Exists(ligne) Then
            With wsSource.Cells(ligne, 8)
                .Interior.Color = RGB(255, 0, 0) ' Fond rouge
                .Font.Color = RGB(255, 255, 255) ' Texte blanc
                .Font.Bold = True
            End With
        Else
            ' Réinitialiser le formatage pour les cases normales
            With wsSource.Cells(ligne, 8)
                .Interior.pattern = xlNone ' Pas de couleur de fond
                .Font.Color = RGB(0, 0, 0) ' Texte noir
                .Font.Bold = False
            End With
        End If
    Next cle
End Sub

' =====================================================
' FONCTION : Compter les cellules vides en fin de ligne
' =====================================================
Function CompterCellulesVidesFinLigne(ws As Worksheet, ligne As Long) As Integer
    Dim compte As Integer
    Dim col As Integer
    
    compte = 0
    
    ' Parcourir de la colonne Z (26) vers la gauche
    For col = 26 To 1 Step -1
        ' Vérifier les deux lignes du caisson
        If ws.Cells(ligne, col).Value = "" And ws.Cells(ligne + 1, col).Value = "" Then
            ' Si la cellule n'est pas fusionnée ou fait partie d'une zone vide
            If Not ws.Cells(ligne, col).MergeCells Or _
               (ws.Cells(ligne, col).MergeCells And ws.Cells(ligne, col).MergeArea.Cells(1, 1).Value = "") Then
                compte = compte + 1
            Else
                ' On a trouvé une cellule non vide, on arrête
                Exit For
            End If
        Else
            ' On a trouvé une cellule non vide, on arrête
            Exit For
        End If
    Next col
    
    CompterCellulesVidesFinLigne = compte
End Function

' =====================================================
' SUB : Mettre à jour les cellules vides dans Accueil - MODIFIÉE POUR DERNIÈRE LIGNE PAR CAISSON
' =====================================================
Sub MettreAJourCellulesVides(wsAccueil As Worksheet, wsFacade As Worksheet, colonneMiseAJour As String)
    ' Utiliser la nouvelle logique de calcul par caisson
    Call RecalculerCellulesVidesParCaisson(wsAccueil)
End Sub

' =====================================================
' FONCTION : Abréger les types de voies
' =====================================================
Function AbregerTypeVoie(nomVoie As String) As String
    Dim result As String
    result = nomVoie
    
    ' Remplacer les types de voies par leurs abréviations
    ' Ordre important : les plus longs d'abord pour éviter les conflits
    result = Replace(result, "Chemin de Grande communication", "CHDG", , , vbTextCompare)
    result = Replace(result, "Chemin de Liaison", "CHDL", , , vbTextCompare)
    result = Replace(result, "Chemin de Petite transport", "CRPT", , , vbTextCompare)
    result = Replace(result, "Impasse en cul-de-sac", "IMP-CUL", , , vbTextCompare)
    result = Replace(result, "Prolongement", "PROL", , , vbTextCompare)
    result = Replace(result, "Boulevard", "BD", , , vbTextCompare)
    result = Replace(result, "Avenue", "AV", , , vbTextCompare)
    result = Replace(result, "Route", "RTE", , , vbTextCompare)
    result = Replace(result, "Impasse", "IMP", , , vbTextCompare)
    result = Replace(result, "Chemin", "CH", , , vbTextCompare)
    result = Replace(result, "Place", "PL", , , vbTextCompare)
    result = Replace(result, "Allée", "ALL", , , vbTextCompare)
    result = Replace(result, "Square", "SQ", , , vbTextCompare)
    result = Replace(result, "Voie", "V", , , vbTextCompare)
    result = Replace(result, "Quai", "QU", , , vbTextCompare)
    result = Replace(result, "Passage", "PSG", , , vbTextCompare)
    result = Replace(result, "Sentier", "SENT", , , vbTextCompare)
    result = Replace(result, "Traversée", "TR", , , vbTextCompare)
    result = Replace(result, "Lotissement", "LOT", , , vbTextCompare)
    result = Replace(result, "Résidence", "RES", , , vbTextCompare)
    result = Replace(result, "Cité", "CIT", , , vbTextCompare)
    result = Replace(result, "Hameau", "H", , , vbTextCompare)
    result = Replace(result, "Parc", "PARC", , , vbTextCompare)
    result = Replace(result, "Pâture", "PAT", , , vbTextCompare)
    result = Replace(result, "Petite rue", "PTE", , , vbTextCompare)
    result = Replace(result, "Galerie", "GAL", , , vbTextCompare)
    result = Replace(result, "Places", "PL", , , vbTextCompare)
    result = Replace(result, "Ruelle", "RLE", , , vbTextCompare)
    result = Replace(result, "Promenade", "PR", , , vbTextCompare)
    result = Replace(result, "Esplanade", "ESPL", , , vbTextCompare)
    result = Replace(result, "Pont", "PT", , , vbTextCompare)
    result = Replace(result, "Vallée", "VAL", , , vbTextCompare)
    result = Replace(result, "Val", "VAL", , , vbTextCompare)
    
    ' Gérer les cas avec "de", "du", "des", "de la"
    result = Replace(result, " de la ", " ", , , vbTextCompare)
    result = Replace(result, " du ", " ", , , vbTextCompare)
    result = Replace(result, " des ", " ", , , vbTextCompare)
    result = Replace(result, " de ", " ", , , vbTextCompare)
    result = Replace(result, " d'", " ", , , vbTextCompare)
    
    ' Nettoyer les espaces doubles
    Do While InStr(result, "  ") > 0
        result = Replace(result, "  ", " ")
    Loop
    
    AbregerTypeVoie = Trim(result)
End Function

' =====================================================
' SUB : Ajouter le code caisson en colonne AA
' =====================================================
Sub AjouterCodeCaisson(ws As Worksheet, ligne As Long, code As String)
    Dim rngCode As Range
    
    ' Fusionner les 2 lignes en colonne AA
    Set rngCode = ws.Range(ws.Cells(ligne, 27), ws.Cells(ligne + 1, 27))
    rngCode.Merge
    
    ' Ajouter le code
    With rngCode
        .NumberFormat = "@" ' Format texte
        .Value = code
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .Font.Bold = True
        .Font.Size = 12
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin ' Bordures simples
        
        ' Si c'est "HC", colorer en rouge
        If code = "HC" Then
            .Interior.Color = RGB(255, 0, 0) ' Fond rouge
            .Font.Color = RGB(255, 255, 255) ' Texte blanc
        Else
            .Interior.pattern = xlNone ' Pas de couleur
            .Font.Color = RGB(0, 0, 0) ' Texte noir
        End If
    End With
End Sub

' =====================================================
' FONCTION : Conversion sécurisée en entier
' =====================================================
Function ConvertirEnEntier(valeur As Variant, valeurParDefaut As Integer) As Integer
    On Error Resume Next
    ConvertirEnEntier = CInt(valeur)
    If Err.Number <> 0 Then
        ConvertirEnEntier = valeurParDefaut
        Err.Clear
    End If
    On Error GoTo 0
End Function

' =====================================================
' FONCTION : Obtenir la couleur de texte adaptée
' =====================================================
Function ObtenirCouleurTexte(indexCouleur As Long) As Long
    Dim couleurRGB As Long
    Dim r As Integer, g As Integer, b As Integer
    Dim luminosite As Double
    
    ' Obtenir la valeur RGB de la couleur d'index
    couleurRGB = ThisWorkbook.Colors(indexCouleur)
    
    ' Extraire les composantes RGB
    r = couleurRGB Mod 256
    g = (couleurRGB \ 256) Mod 256
    b = (couleurRGB \ 65536) Mod 256
    
    ' Calculer la luminosité (formule standard)
    luminosite = (0.299 * r + 0.587 * g + 0.114 * b) / 255
    
    ' Si la couleur est sombre, texte blanc, sinon texte noir
    If luminosite < 0.5 Then
        ObtenirCouleurTexte = RGB(255, 255, 255) ' Blanc
    Else
        ObtenirCouleurTexte = RGB(0, 0, 0) ' Noir
    End If
End Function

' =====================================================
' SUB : Fusionner les cellules adjacentes avec même nom de voie
' =====================================================
Sub FusionnerVoiesAdjacentes(ws As Worksheet)
    Dim ligneVoie As Long
    Dim col As Long, colDebut As Long
    Dim nomVoieActuel As String, nomVoieSuivant As String
    Dim rngFusion As Range
    Dim derniereLigne As Long
    Dim derniereColonne As Long
    Dim couleurIndex As Long
    Dim couleurTexte As Long
    
    ' Trouver les limites de la feuille utilisée
    derniereLigne = ws.UsedRange.Rows.Count
    derniereColonne = 26 ' S'arrêter à la colonne Z
    
    ' Parcourir toutes les lignes de noms de voies (lignes 2, 4, 6, etc.)
    For ligneVoie = 2 To derniereLigne Step 2
        col = 1
        
        ' Parcourir les colonnes de cette ligne
        Do While col <= derniereColonne
            ' Ignorer les cellules vides
            If ws.Cells(ligneVoie, col).Value = "" Then
                col = col + 1
            Else
                ' Récupérer le nom de voie actuel (sans slash pour comparaison)
                nomVoieActuel = Trim(ws.Cells(ligneVoie, col).Value)
                
                ' Extraire le nom de voie sans le cercle blanc pour la comparaison
                Dim nomVoieComparaison As String
                If Left(nomVoieActuel, 1) = ChrW(&H25CB) Then
                    ' Enlever le cercle blanc et l'espace qui suit pour la comparaison
                    nomVoieComparaison = Trim(Mid(nomVoieActuel, 3))
                Else
                    nomVoieComparaison = nomVoieActuel
                End If
                
                ' Si c'est une voie multiple, ne pas fusionner
                If InStr(nomVoieComparaison, " / ") > 0 Then
                    ' Passer à la cellule suivante sans fusionner
                    If ws.Cells(ligneVoie, col).MergeCells Then
                        col = ws.Cells(ligneVoie, col).MergeArea.Column + _
                              ws.Cells(ligneVoie, col).MergeArea.Columns.Count
                    Else
                        col = col + 1
                    End If
                Else
                    ' Procéder à la fusion normale pour les voies simples
                    colDebut = col
                    
                    ' Mémoriser la couleur et vérifier si c'est rouge (hors capacité)
                    Dim estRouge As Boolean
                    estRouge = False
                    If ws.Cells(ligneVoie, col).Interior.Color = RGB(255, 0, 0) Then
                        estRouge = True
                        couleurIndex = xlNone ' On utilisera le rouge directement
                        couleurTexte = RGB(255, 255, 255)
                    ElseIf ws.Cells(ligneVoie, col).Interior.ColorIndex <> xlNone Then
                        couleurIndex = ws.Cells(ligneVoie, col).Interior.ColorIndex
                        couleurTexte = ws.Cells(ligneVoie, col).Font.Color
                    Else
                        couleurIndex = xlNone
                    End If
                    
                    ' Trouver la fin de la cellule fusionnée actuelle
                    If ws.Cells(ligneVoie, col).MergeCells Then
                        col = ws.Cells(ligneVoie, col).MergeArea.Column + _
                              ws.Cells(ligneVoie, col).MergeArea.Columns.Count - 1
                    End If
                    
                    ' Vérifier les cellules suivantes pour le même nom de voie
                    Do While col < derniereColonne
                        ' Vérifier la cellule suivante
                        If ws.Cells(ligneVoie, col + 1).Value = "" Then
                            Exit Do
                        End If
                        
                        nomVoieSuivant = Trim(ws.Cells(ligneVoie, col + 1).Value)
                        
                        ' Extraire le nom de voie sans le cercle blanc pour la comparaison
                        Dim nomVoieSuivantComparaison As String
                        If Left(nomVoieSuivant, 1) = ChrW(&H25CB) Then
                            ' Enlever le cercle blanc et l'espace qui suit pour la comparaison
                            nomVoieSuivantComparaison = Trim(Mid(nomVoieSuivant, 3))
                        Else
                            nomVoieSuivantComparaison = nomVoieSuivant
                        End If
                        
                        ' Ne pas fusionner si la cellule suivante contient des voies multiples
                        If InStr(nomVoieSuivantComparaison, " / ") > 0 Then
                            Exit Do
                        End If
                        
                        ' Si c'est le même nom de voie (en ignorant le cercle blanc), étendre la fusion
                        If nomVoieComparaison = nomVoieSuivantComparaison And nomVoieComparaison <> "" Then
                            ' Trouver la fin de la cellule suivante
                            If ws.Cells(ligneVoie, col + 1).MergeCells Then
                                col = ws.Cells(ligneVoie, col + 1).MergeArea.Column + _
                                      ws.Cells(ligneVoie, col + 1).MergeArea.Columns.Count - 1
                            Else
                                col = col + 1
                            End If
                        Else
                            Exit Do
                        End If
                    Loop
                    
                    ' Si on a trouvé plusieurs cellules adjacentes avec le même nom
                    If col > colDebut Then
                        ' Défusionner d'abord toutes les cellules concernées
                        For i = colDebut To col
                            If ws.Cells(ligneVoie, i).MergeCells Then
                                ws.Cells(ligneVoie, i).MergeArea.UnMerge
                            End If
                        Next i
                        
                        ' Refusionner l'ensemble
                        Set rngFusion = ws.Range(ws.Cells(ligneVoie, colDebut), ws.Cells(ligneVoie, col))
                        rngFusion.Merge
                        
                        ' Réappliquer le formatage avec le nom abrégé et le cercle blanc si nécessaire
                        Dim texteVoieFusionne As String
                        ' Vérifier si le texte original contenait un cercle blanc
                        If InStr(nomVoieActuel, ChrW(&H25CB)) > 0 Then
                            texteVoieFusionne = ChrW(&H25CB) & " " & AbregerTypeVoie(nomVoieComparaison)
                        Else
                            texteVoieFusionne = AbregerTypeVoie(nomVoieComparaison)
                        End If
                        
                        With rngFusion
                            .NumberFormat = "@" ' Format texte
                            .Value = texteVoieFusionne
                            .HorizontalAlignment = xlCenter
                            .VerticalAlignment = xlCenter
                            .Font.Bold = True
                            .WrapText = True
                            .Borders.LineStyle = xlContinuous
                            .Borders.Weight = xlThin ' Bordures simples pour la fusion
                            
                            ' Souligner si c'était une voie multiple
                            If InStr(nomVoieActuel, ChrW(&H25CB)) > 0 Then
                                .Font.Underline = xlUnderlineStyleSingle
                            End If
                            
                            ' Appliquer la couleur appropriée
                            If estRouge Then
                                .Interior.Color = RGB(255, 0, 0) ' Rouge pour hors capacité
                                .Font.Color = RGB(255, 255, 255) ' Texte blanc
                            ElseIf couleurIndex <> xlNone Then
                                .Interior.ColorIndex = couleurIndex
                                .Font.Color = couleurTexte
                            End If
                        End With
                        
                        ' APPLIQUER LA TAILLE DE POLICE OPTIMISÉE POUR LES VOIES FUSIONNÉES
                        Call AjusterTaillePoliceVoiesSelonLargeur(rngFusion, col - colDebut + 1)
                    End If
                    
                    col = col + 1
                End If
            End If
        Loop
    Next ligneVoie
End Sub

' =====================================================
' MACRO DE TEST : Vérifier la logique de dépassement
' =====================================================
Sub TesterLogiquleDepassement()
    Dim ws As Worksheet
    Dim maxPar As Integer
    Dim msg As String
    
    Set ws = ThisWorkbook.Sheets("Accueil")
    maxPar = val(ws.Range("C1").Value)
    If maxPar <= 0 Then maxPar = 4
    
    msg = "TEST DE LA LOGIQUE DE DÉPASSEMENT" & vbCrLf & vbCrLf
    msg = msg & "Valeur max par caisson (C1) : " & maxPar & vbCrLf & vbCrLf
    msg = msg & "EXEMPLES DE TESTS :" & vbCrLf
    
    ' Tester quelques codes
    msg = msg & "1A : " & IIf(CaissonDepasse("1A", maxPar), "DÉPASSE", "OK") & vbCrLf
    msg = msg & maxPar & "D : " & IIf(CaissonDepasse(maxPar & "D", maxPar), "DÉPASSE", "OK") & vbCrLf
    msg = msg & (maxPar + 1) & "D : " & IIf(CaissonDepasse((maxPar + 1) & "D", maxPar), "DÉPASSE", "OK") & vbCrLf
    msg = msg & "1E : " & IIf(CaissonDepasse("1E", maxPar), "DÉPASSE", "OK") & vbCrLf & vbCrLf
    
    msg = msg & "LIMITE : Tout au-delà de " & maxPar & "D devrait être en ROUGE avec HC" & vbCrLf
    msg = msg & "IMPORTANT : Une fois dépassé, même si ça repart à 1A, ça reste ROUGE !"
    
    MsgBox msg, vbInformation, "Test logique dépassement"
End Sub

' =====================================================
' MACRO DE TEST : Vérifier la structure des données
' =====================================================
Sub VerifierStructureDonnees()
    Dim ws As Worksheet
    Dim msg As String
    
    Set ws = ThisWorkbook.Sheets("Accueil")
    
    msg = "VÉRIFICATION DE LA STRUCTURE DES DONNÉES" & vbCrLf & vbCrLf
    msg = msg & "Valeur max par caisson (C1) : " & ws.Range("C1").Value & vbCrLf & vbCrLf
    msg = msg & "Exemple de la ligne 7 :" & vbCrLf
    msg = msg & "- Colonne A (N°) : " & ws.Cells(7, 1).Text & vbCrLf
    msg = msg & "- Colonne B (Nom voie) : " & ws.Cells(7, 2).Text & vbCrLf
    msg = msg & "- Colonne D (Observations) : " & ws.Cells(7, 4).Text & vbCrLf
    msg = msg & "- Colonne F (Type PDI) : " & ws.Cells(7, 6).Text & vbCrLf
    msg = msg & "- Colonne G (Largeur) : " & ws.Cells(7, 7).Text & vbCrLf
    msg = msg & "- Colonne V (Valeur B) : " & ws.Cells(7, 22).Text & vbCrLf & vbCrLf
    
    msg = msg & "RÉSULTAT ATTENDU :" & vbCrLf
    msg = msg & "Cellule du HAUT : " & ws.Cells(7, 1).Text & " - " & ws.Cells(7, 4).Text & vbCrLf
    msg = msg & "Cellule du BAS : " & ws.Cells(7, 2).Text
    
    MsgBox msg, vbInformation, "Structure des données"
End Sub

